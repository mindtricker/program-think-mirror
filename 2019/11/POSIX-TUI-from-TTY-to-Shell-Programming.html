<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="Python script by program.think@gmail.com" />
  <meta name="provider" content="program-think.blogspot.com" />
  <script src="../../scripts/jquery.min.js" type="text/javascript"></script>
  <script src="../../scripts/jquery-ui.min.js" type="text/javascript"></script>
  <link href="../../scripts/jquery-ui.min.css" rel="stylesheet" />
  <script type="text/javascript">window.rootNavigator = '../../' </script>
  <script src="../../scripts/base.js" type="text/javascript"></script>
  <link type="text/css" rel="stylesheet" href="../../css/program-think.css" />
  <link rel="icon" type="image/x-icon" href="../../images/favicon/blogspot.ico">
  <title>扫盲 Linux&#65286;UNIX 命令行&#8212;&#8212;从&#8220;电传打字机&#8221;聊到&#8220;shell 脚本编程&#8221; - 编程随想的博客</title>
</head>

<body>
  <div id="outer-wrapper">
    <div id="content-wrapper">
      <div id="main" style="width:67%;">
        <div class="widget Header" data-version="1" id="Header1">
          <div id="header-inner">
            <div class="titlewrapper">
              <h1 class="title">
                <a href="../../index.html">
                  编程随想的博客
                </a>
              </h1>
            </div>
            <div class="descriptionwrapper">
              <p class="description"></p>
              <hr>
            </div>
          </div>
        </div>

        <div class="post-content">
          <div class="post-toolbar">
            <div class="post-toolbar-1">
            </div>
            <div class="post-toolbar-2">
              <span class="post-timestamp" data="2019-11-10T21:02:00+08:00">2019年11月10日</span>
              <span class="post-comment-link">
                <a class="comment-link" href="#comments">评论数：301条</a>
              </span>
              <span class="post-labels">
                标签：
                <a href="../../tags/E7BC96E7A88B.html" class="tag">编程</a>  <a href="../../tags/IT.html" class="tag">IT</a>  <a href="../../tags/IT.E8BDAFE4BBB6E4BB8BE7BB8D.html" class="tag">IT.软件介绍</a>  <a href="../../tags/IT.Linux.html" class="tag">IT.Linux</a>  
              </span>
            </div>
          </div>

          <div>
            <h1 class="post-title entry-title">
              <a href="https://program-think.blogspot.com/" title="点击跳转到原文(Blogspot)地址">
              扫盲 Linux&#65286;UNIX 命令行&#8212;&#8212;从&#8220;电传打字机&#8221;聊到&#8220;shell 脚本编程&#8221;
              </a>
            </h1>

            <div class='post-header'>
              <div class='post-header-line-1'>
              <div class='post-inner-index'></div>
              </div>
            </div>
          </div>

          <div class="post">
            
<h2>&#9733;引子</h2><br>
&#12288;&#12288;首先&#65292;<br>
&#12288;&#12288;这篇是为了补前几年的&#8220;欠债&#8221;&#12290;这些年&#65292;俺写了好多篇 Linux 相关的技术教程&#12290;但还从来没有&#12304;系统性&#12305;地介绍 Linux 命令行相关的基本概念和基本知识&#12290;几年来&#65292;已经有不少读者催俺填上这个大坑&#65292;但俺比较懒&#65292;一直拖到现在&#65292;惭愧 :(<br>
&#12288;&#12288;其次&#65292;<br>
&#12288;&#12288;一个多月前&#65288;9月份&#65289;写了一篇 <a href="../../2019/09/Netcat-Tricks.html">netcat 的扫盲教程</a>&#65292;其中涉及了很多命令行相关的知识&#12290;很多菜鸟读者&#65292;如果缺乏这些基础知识&#65292;恐怕看不懂那篇 netcat 教程&#12290;再加上<a href="../../2019/10/Systematic-Learning.html">前几天的博文</a>谈到了&#12304;系统性学习&#12305;相关的方法论&#65292;并且还聊了&#12304;费曼学习法&#12305;的各种好处&#12290;<br>
&#12288;&#12288;今天这篇&#65292;算是俺第 N 次践行&#8220;费曼学习法&#8221;&#8212;&#8212;无论对俺还是读者&#65292;这都是&#12304;双赢&#12305;滴 :)<br>
<a name='more'></a><br>
<br>
<h2>&#9733;本文目标读者</h2><br>
&#12288;&#12288;虽然本文的标题号称是&#12304;扫盲&#12305;&#65292;但俺相信&#65306;<b>即使是一些 POSIX 系统的命令行&#12304;老手&#12305;&#65292;对本文中介绍的某些概念&#65292;可能也会有&#12304;欠缺&#12305;&#12290;</b><br>
&#12288;&#12288;因此&#65292;这篇教程既适合于命令行的新手&#65292;也值得某些&#12304;老手&#12305;看一看&#12290;<br>
<br>
&#12288;&#12288;由于本文介绍的是 POSIX 系统中&#12304;通用的&#12305;概念与知识&#12290;因此&#65292;包括 Linux&#12289;BSD 家族&#12289;macOS 等各种系统的用户&#65292;应该都能从中受益&#12290;<br>
&#12288;&#12288;&#65288;注&#65306;<a href="https://en.wikipedia.org/wiki/POSIX" target="_blank" rel="nofollow">POSIX</a> 是某种操作系统的标准/规范&#12290;各种 Linux 发行版以及所有的 UNIX 变种&#65292;包括 macOS&#65292;都属于&#8220;POSIX 系统&#8221;&#65289;<br>
<br>
&#12288;&#12288;如果你是这方面的&#12304;菜鸟&#12305;&#65292;并且想要掌握这个领域&#12290;&#12304;不要&#12305;企图只看一遍就完全理解本文的内容&#65288;可能需要看好几遍&#65289;&#12290;俺的建议是&#65306;要一边看&#65292;一边拿命令行的环境&#12304;实践&#12305;一下&#12290;<br>
<br>
<a name="teletype"> </a><br>
<h2>&#9733;一切都从&#12304;电传打字机&#12305;开始说起</h2><br>
&#12288;&#12288;&#65288;说完了&#8220;引子&#8221;与&#8220;目标读者&#8221;&#65292;开始切入正题&#65289;<br>
&#12288;&#12288;可能有些读者会纳闷&#8212;&#8212;&#8220;聊命令行的基本概念&#8221;&#65292;为啥要扯到&#8220;电传打字机&#8221;&#65311;是不是扯得太远了&#65311;<br>
&#12288;&#12288;俺来解释一下&#65306;<br>
&#12288;&#12288;IT 行业的很多基本概念都来自于&#12304;历史遗迹&#12305;&#12290;有时候你觉得某些东西很奇怪&#65288;并纳闷&#8220;为啥会设计成这样&#8221;&#65289;&#65307;而当你搞清楚历史的演变过程之后&#65292;自然就明白其中的原因&#12290;<br>
<br>
<h3>&#9671;在那遥远的&#12304;电报时代&#12305;</h3><br>
&#12288;&#12288;在计算机诞生之前&#65288;二战前&#65289;&#65292;&#12304;电报&#12305;属于高科技的玩意儿&#8212;&#8212;它能够瞬间把信息传送到另一个城市&#65288;甚至传送到大洋彼岸&#65289;&#12290;<br>
&#12288;&#12288;当年的电报线路&#65292;是以&#12304;字符&#12305;为单位发送信息&#12290;在线路两端使用&#12304;电传打字机&#12305;&#65292;就可以自动地把对方发过来的字符打印出来&#12290;<br>
<br>
<center><img src="../../images/2019/11/SO-SrkxjARZ0k4dADyEbtp9vYYHbv37f1R_iYFZzit2KJjjmeRjLqrXb0gRlHebYTYz1QeT9KzkiJaCneNrhmuBQZaXhlpt2QVDB1N0_3eigwXAZuDmQGq6wmUYjA7zIsyRgxRejW5c" alt="不见图 请翻墙"><br>
&#65288;上世纪40年代的电传打字机&#8212;&#8212;用于电报网&#65289;</center><br>
<h3>&#9671;&#8220;回车/换行&#8221;的来历</h3><br>
&#12288;&#12288;稍微懂点 IT 的同学&#65292;应该都听说过&#8220;回车/换行&#8221;&#65292;洋文分别称之为&#8220;carriage return&#8221;&#65286;&#8220;line feed&#8221;&#12290;在编程领域&#65292;这两个字符简称为 <code>\r</code> &#65286; <code>\n</code>&#12290;<br>
&#12288;&#12288;为啥会有这么两个玩意儿捏&#65311;<br>
&#12288;&#12288;因为在电传打字机时代&#65292;当打印完一行之后&#65292;需要用一个控制命令把&#8220;打印头&#8221;复位&#65288;移到打印纸的左边&#65289;&#65292;然后再用另一个控制命令把&#8220;打印头&#8221;往下移动一行&#12290;很自然地&#65292;这俩动作就对应了两个控制字符&#65288;CR &#65286; LF&#65289;&#65292;也就是所谓的&#8220;回车 &#65286; 换行&#8221;&#12290;<br>
<br>
<h3>&#9671;其它控制字符</h3><br>
&#12288;&#12288;如果你去留意一下 ASCII 字符表的开头部分&#65292;前面那32个字符都是控制字符&#65292;很多都源于遥远的&#12304;电报时代&#12305;&#12290;<br>
&#12288;&#12288;在本文后续的介绍中&#65292;还会再聊到这些&#8220;控制字符&#8221;&#12290;<br>
<br>
<a name="tty"> </a><br>
<h2>&#9733;终端&#65288;terminal/TTY&#65289;</h2><br>
<h3>&#9671;历史演变</h3><br>
&#12288;&#12288;&#8220;终端&#8221;一词&#65292;洋文称之为&#8220;<a href="https://en.wikipedia.org/wiki/Computer_terminal" target="_blank" rel="nofollow">terminal</a>&#8221;&#12290;有时候又被称作 TTY&#65292;而 TTY 这个简写就来自刚才介绍的&#12304;电传打字机&#12305;&#65288;teletype printer&#65289;&#12290;<br>
&#12288;&#12288;因为早期的大型机&#65292;其&#8220;终端&#8221;就是&#12304;电传打字机&#12305;&#12290;那时候的终端&#65292;也称作&#12304;硬件终端&#12305;&#12290;<br>
<br>
&#12288;&#12288;为啥会有&#8220;终端&#8221;这个概念捏&#65311;你依然需要了解历史的变迁&#12290;<br>
&#12288;&#12288;最早期的计算机&#65288;大型机&#65289;是&#12304;单任务&#12305;滴&#8212;&#8212;也就是说&#65292;每次只能干一件事情&#12290;<br>
&#12288;&#12288;到了60年代&#65292;出现了一个&#12304;革命性&#12305;的飞跃&#8212;&#8212;发明了&#12304;多任务&#12305;系统&#65292;当时叫做&#8220;<a href="https://en.wikipedia.org/wiki/Time-sharing" target="_blank" rel="nofollow">time-sharing</a>&#8221;&#65288;分时系统&#65289;&#12290;有了&#8220;分时系统&#8221;&#65292;就可以让多个人同时使用一台大型机&#12290;而为了让多个人同时操作这台大型机&#65292;就引入了&#12304;终端&#12305;的概念&#12290;每一台大型机安装多个终端&#65292;每个操作员都在各自的终端上进行操作&#65292;互不干扰&#12290;<br>
<br>
<h3>&#9671;&#65288;跑题&#65289;&#8220;约翰&#183;麦卡锡&#8221;其人</h3><br>
&#12288;&#12288;聊到这里&#65292;稍微跑题一下&#65306;<br>
&#12288;&#12288;最早的&#8220;分时系统&#8221;由 IT 超级大牛&#8220;约翰&#183;麦卡锡&#8221;&#65288;<a href="https://en.wikipedia.org/wiki/John_McCarthy_(computer_scientist)" target="_blank" rel="nofollow">John McCarthy</a>&#65289;设计&#12290;此人不仅仅是&#8220;分时系统它爹&#8221;&#65292;还是&#8220;Lisp 语言它爹&#8221;&#65292;另外还参与设计了编程语言&#8220;ALGOL 60&#8221;&#12290;而这个&#8220;ALGOL 60&#8221;编程语言虽然知道的人不多&#65292;但该语言深刻影响了后续的 Ada&#12289;BCPL&#12289;C&#12289;Pascal......<br>
&#12288;&#12288;为了让你体会这只大牛到底有多牛&#12290;俺引用另一个牛人保罗&#183;格雷汉姆&#65288;&#12298;<a href="https://docs.google.com/document/d/17i49-SpeKz1wRG5S-HPonO-lXJHD99h62gDsQ64NWXo/" target="_blank">黑客与画家</a>&#12299;作者&#65289;的观点&#8212;&#8212;他认为在所有编程语言中&#65292; Lisp 与 C 是两座无法超越的高峰&#12290;而&#8220;约翰&#183;麦卡锡&#8221;亲自发明了 Lisp 语言&#65292;然后又深刻地影响了 C 语言&#12290;<br>
&#12288;&#12288;另外&#65292;麦卡锡这只大牛还参与创立了&#8220;MIT 人工智能实验室&#8221;与&#8220;斯坦福人工智能实验室&#8221;&#12290;前者涌现出一大批早期的黑客&#65292;其中包括大名鼎鼎的 <a href="https://en.wikipedia.org/wiki/Richard_Stallman" target="_blank" rel="nofollow">Richard Stallman</a>&#65288;此人开创了&#65306;自由软件运动&#12289;GNU 社区&#12289;GCC&#12289;GDB&#12289;GNU Emacs ......&#65289;&#12290;<br>
<br>
<center><img src="../../images/2019/11/0Yiucax8D7skki_Z5csmfmOhFXAc6nUnQfHik6WDoNRMPX4OJeqjq7GZcuHrjYFrBiPmqOunexkfby3c0NI7blTa1d_yDoELrPfIVVYFIHqJLHlQM8X94Ql4IKSyGsKuesGRYbJZKgU" alt="不见图 请翻墙"><br>
&#65288;超级大牛约翰&#183;麦卡锡&#65289;</center><br>
<h3>&#9671;&#12304;远程&#12305;终端</h3><br>
&#12288;&#12288;跑题结束&#65292;言归正传&#12290;<br>
&#12288;&#12288;&#8220;终端&#8221;的好处不光是&#8220;多任务&#8221;&#65292;而且还可以让用户在&#12304;远程&#12305;进行操作&#12290;这种情况下&#65292;&#8220;终端&#8221;通过 modem&#65288;调制解调器&#65289;与&#8220;主机&#8221;相连&#12290;这种玩法很类似于&#8212;&#8212;互联网普及初期的拨号上网&#12290;示意图如下&#65306;<br>
<br>
<center><img src="../../images/2019/11/iUIOjl4GY8O419YJ45c1BN4ri4U2eLJThOEq_Ff_6_gdfGwz76imgEqf6kHp0pgs1iGr0544VL5bTcRGkKaw42mz25Z0vYqEWXhbWwOKS9Y4Nh2UDfN_6LuM-PK1jhtDUtkGbHgV27k" alt="不见图 请翻墙"><br>
&#65288;通过 modem 实现的&#12304;远程&#12305;终端&#65289;</center><br>
&#12288;&#12288;最早的&#8220;终端&#8221;&#65292;本质上就是&#8220;电传打字机&#8221;&#8212;&#8212;以&#8220;打字机&#8221;作为输入&#65307;以&#8220;打印纸&#8221;作为输出&#12290;这类终端&#65292;比较经典的是如下这款&#65306;<br>
<br>
<center><img src="../../images/2019/11/3tqr5yVvG9QF7vW_J45SWY8aMmGekLQZZNKOP48Vvi9V71qz9v45vbTs25tN6stF13qotXRkyuC_o76FLzYYAbDKzRXFNcSiKnoy5H-6BpRzQ2ZdR9ON1vjdfYYpThUHpthIYv9MoL0" alt="不见图 请翻墙"><br>
&#65288;Teletype Model 33 ASR&#65289;</center><br>
&#12288;&#12288;到了上世纪70年初&#65292;终于有了带&#12304;屏幕&#12305;的远程终端&#12290;<a href="https://en.wikipedia.org/wiki/Digital_Equipment_Corporation" target="_blank" rel="nofollow">DEC 公司</a>的 VT05 是第一款基于 CRT 显示器的远程终端&#12290;<br>
<br>
<center><img src="../../images/2019/11/SDvmTqKHE5lh3PPbrTUGvuX7V8Ux4fv3TdWvB7Ga8BbAVMKUJ8mwn9qp0UqI_6YEDYwhbrEqOWa2M3ifzrTTT5zrpzS-kJwijICRVQDldIfl2W3ra3WQuPxPzWD7I9u8d45z84l04dM" alt="不见图 请翻墙"><br>
&#65288;VT05 终端&#65289;</center><br>
<h3>&#9671;内部结构示意图</h3><br>
&#12288;&#12288;下面这张是大型机时代&#65292;&#8220;终端&#8221;与&#8220;进程&#8221;通讯的示意图&#12290;<br>
&#12288;&#12288;图中的 <code>UART</code> 是洋文&#8220;Universal Asynchronous Receiver and Transmitter&#8221;的缩写&#65288;相关维基百科链接在&#8220;<a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter" target="_blank" rel="nofollow">这里</a>&#8221;&#65289;&#12290;LDISC 是洋文&#8220;line discipline&#8221;的简写&#65288;相关维基百科链接在&#8220;<a href="https://en.wikipedia.org/wiki/Line_discipline" target="_blank" rel="nofollow">这里</a>&#8221;&#65289;&#12290;<br>
&#12288;&#12288;通俗地说&#65292;UART 用来处理物理线路的字符传输&#65288;比如&#65306;&#8220;错误校验&#8221;&#12289;&#8220;流控&#8221;&#12289;等&#65289;&#65307;LDISC 用来撮合底层的&#8220;硬件驱动&#8221;与上层的&#8220;系统调用&#8221;&#65292;并完成某些&#8220;控制字符&#8221;的处理与翻译&#12290;<br>
<br>
<center><img src="../../images/2019/11/wzvdclkzzYDah1LxS_lTCQqAbxdePKSr-w1XT7c91axw-_CuT7aATNsEuHxbWBYIOvhbifp8hrwLDkBpOXVQajgX5ZSDfcjvoqjjIpiQVV0EVbaldvA1geO_FHxMe40DMFZ9RfG7iSA" alt="不见图 请翻墙"><br>
&#65288;TTY 示意图1&#65306;使用&#12304;硬件终端&#12305;的大型机内部结构图&#65289;</center><br>
<h3>&#9671;如今的含义</h3><br>
&#12288;&#12288;如今&#65292;&#8220;终端&#8221;一词的含义已经扩大了&#8212;&#8212;<b>用来指&#65306;基于&#12304;文本&#12305;的输入输出机制&#12290;</b><br>
&#12288;&#12288;在本文后续的章节中&#65292; terminal 与 TTY 这两个术语基本上是同义词&#12290;<br>
<br>
<a name="tty-mode"> </a><br>
<h2>&#9733;终端的3种&#12304;缓冲模式&#12305;&#8212;&#8212;字符模式&#12289;行模式&#12289;屏模式</h2><br>
<h3>&#9671;字符模式&#65288;character mode&#65289;</h3><br>
&#12288;&#12288;又要说回到&#12304;电传打字机&#12305;&#12290;<br>
&#12288;&#12288;在本文开头&#65292;已经聊过这个玩意儿&#65292;并且提到&#8212;&#8212;它是基于&#12304;字符&#12305;传输滴&#12290;也就是说&#65292;操作员每次在&#8220;电传打字机&#8221;上按键&#65292;对应的字符会立即通过线路发送给对方&#12290;这就是最传统的&#12304;字符模式&#12305;<br>
&#12288;&#12288;通俗地说&#65292;&#8220;字符模式&#8221;也就是&#12304;无缓冲&#12305;的模式&#12290;<br>
<br>
<h3>&#9671;行模式&#65288;line mode&#65289;</h3><br>
&#12288;&#12288;不客气地说&#65292;&#8220;字符模式&#8221;是非常傻逼滴&#65281;因为如果你不小心按错键&#65292;这个错误也会立即发送出去&#12290;<br>
&#12288;&#12288;比如说&#65292;你在输入一串很长的命令&#65292;结果输到半当中&#65292;敲错一个按键&#65292;整个命令就废了&#8212;&#8212;要重新再输入一遍&#12290;<br>
&#12288;&#12288;所以&#65292;当早期的程序员对&#8220;字符模式&#8221;实在忍无可忍之后&#65292;终于发明了&#12304;行模式&#12305;&#12290;<br>
&#12288;&#12288;&#12304;行模式&#12305;也叫做&#8220;行缓冲&#8221;&#12290;也就是说&#65292;终端会把你当前输入的这行先缓冲在本地&#12290;只有当你最终按了&#12304;回车键&#12305;&#65292;才会把这一整行发送出去&#12290;如果你不小心敲错了一个字符&#65292;可以赶紧用&#8220;退格键&#8221;删掉重输这个字符&#12290;<br>
&#12288;&#12288;因此&#65292;这种模式称之为&#12304;行缓冲&#12305;&#12290;<br>
<br>
&#12288;&#12288;顺便说一下&#65306;<br>
&#12288;&#12288;早期的标准键盘&#65292;&#12304;没有&#12305;方向键&#65288;&#8220;上下左右&#8221;这4个键&#65289;&#12290;不信的话&#65292;可以去看本文前面贴的那张&#8220;Teletype Model 33 ASR&#8221;的照片&#12290;<br>
&#12288;&#12288;因为无论是&#8220;字符模式&#8221;还是&#8220;行模式&#8221;&#65292;都没这个需求&#12290;<br>
<br>
<h3>&#9671;屏模式&#65288;screen mode/block mode&#65289;</h3><br>
&#12288;&#12288;&#8220;行模式&#8221;进一步的发展就是&#12304;屏模式&#12305;&#12290;这个玩意儿也叫&#8220;全屏缓冲&#8221;&#65292;顾名思义&#65292;终端会缓冲当前屏幕的内容&#12290;<br>
&#12288;&#12288;在这种模式下&#65292;用户可以利用方向键&#65292;操纵光标&#65288;cursor&#65289;在屏幕上四处游走&#12290;<br>
&#12288;&#12288;开发这种类型的软件&#65292;比较复杂&#8212;&#8212;程序员至少需要做如下工作&#65306;<br>
1. 保存整个屏幕的状态<br>
2. 根据键盘输入&#65292;操纵光标&#65288;cursor&#65289;移动<br>
3. 控制屏幕的哪些区域是光标可达&#65292;哪些是不可达&#65307;<br>
4. 对于光标可达的部分&#65292;控制哪些是&#8220;可编辑&#8221;&#65292;哪些是&#8220;只读&#8221;&#65307;<br>
5. 根据&#8220;光标移动&#8221;以及某些&#8220;特定的按键&#8221;&#65288;比如&#8220;翻页键&#8221;&#65289;&#65292;重新绘制屏幕<br>
......<br>
&#12288;&#12288;后来&#65292;为了简化&#8221;屏模式&#8220;的编程&#65292;专门搞了一个叫做 curses 的编程库&#12290;如今的&#8220;ncurses 库&#8221;就是从 curses 衍生出来滴&#65288;前面加了一个 n 表示 new&#65289;&#12290;<br>
<br>
<center><img src="../../images/2019/11/nPGfx1VIMvI26G-L4q9jqaw-RYqRLkHIj3vjgOMHzxAFQMHgOEry2YyN4mXFPAxqvNPl4EwqJr0Q34Z9sMl_8HPNmm1eT-FAkJyU8FCJcSPovg8wb3UZJT5CIbdKz-zmeNdX0J2pFvk" alt="不见图 请翻墙"><br>
&#65288;&#8220;重编译 Linux 内核&#8221;的配置界面&#65292;基于 ncurses 实现&#65289;</center><br>
&#12288;&#12288;前面说了&#8212;&#8212;早期的键盘&#12304;没&#12305;方向键&#12290;有了这个&#12304;屏模式&#12305;之后&#65292;键盘上才开始增加了&#8220;方向键&#8221;&#65288;所以&#8220;方向键&#8221;位于键盘的扩展区&#65289;<br>
<br>
<h3>&#9671;小结</h3><br>
&#12288;&#12288;上述这三种模式&#65292;第1种基本淘汰&#65288;仅限于极少数场景&#65289;&#65307;第3种用得也不多&#12290;与本文关系比较密切的&#65292;其实是&#12304;第2种&#12305;&#8212;&#8212;行模式&#12290;<br>
&#12288;&#12288;为了加深你的印象&#65292;用 <code>cat</code> 命令来举例&#65288;注&#65306;这个命令其实与&#8220;猫&#8221;&#12304;无关&#12305;&#65292;而是 concatenate 的简写&#65289;<br>
&#12288;&#12288;大部分情况下&#65292;都是用它来显示某个文件的内容&#65292;比如说&#65306;<code>cat 文件名</code> &#12290;但如果你运行 <code>cat</code>&#12304;没&#12305;加任何参数&#65292;那么它就会尝试读取你在终端的输入&#65292;然后把读到的文本再原样输出到终端&#12290;<br>
<br>
<center><img src="../../images/2019/11/PPet_RllllnSmYALmxV56ohy5NZz1kj76GzbmcvM9HJDrqY6h74otCFL1E0rG_lEKnALViM8zv2E4BOj4bUUTixzD_QTTXsmoh0-U3dxJROpiAfvW2vHZ69s2vpYlq88-6FBngqgzSQ" alt="不见图 请翻墙"><br>
&#65288;动画&#65306;演示&#8220;行模式&#8221;的效果&#65289;</center><br>
&#12288;&#12288;在上述动画中&#65292;你的输入并&#12304;没有&#12305;直接传递给 <code>cat</code> 进程&#12290;要一直等到你按下&#12304;回车键&#12305;&#65292;<code>cat</code> 进程才收到你的输入&#65292;并立即打印了输出&#12290;<br>
<br>
<a name="tty-echo"> </a><br>
<h2>&#9733;终端的&#12304;回显&#12305;</h2><br>
<h3>&#9671;&#8220;回显&#8221;是啥&#65311;</h3><br>
&#12288;&#12288;在刚才那个 gif 动画中&#65292;当俺逐个输入 <code>test</code> 的每个字母&#65292;这些字母也会逐个显示在屏幕上&#12290;这种做法叫做&#12304;回显&#12305;&#12290;<br>
<br>
<h3>&#9671;&#8220;回显&#8221;的打开与关闭&#65288;启用/禁用&#65289;</h3><br>
&#12288;&#12288;虽然&#8220;回显&#8221;很人性化&#65292;但某些特殊的场合是&#12304;不想&#12305;&#8220;回显&#8221;滴&#65292;比如当你输入密码/口令的时候&#12290;<br>
&#12288;&#12288;因此&#65292;终端提供了某种机制&#65292;使得程序能够控制&#8220;回显&#8221;的启用/禁用&#12290;<br>
&#12288;&#12288;对于大多数终端&#65292;可以用&#12304;<code>Ctrl + S</code>&#12305;禁用&#8220;回显&#8221;&#65292;然后用&#12304;<code>Ctrl + Q</code>&#12305;启用&#8220;回显&#8221;&#12290;<br>
&#12288;&#12288;如果你在禁用&#8220;回显&#8221;的情况下输入一些文本&#65292;当你重新启用&#8220;回显&#8221;的瞬间&#65292;这些文本会一起出现在屏幕上&#12290;<br>
<br>
&#12288;&#12288;顺便说一下&#65306;<br>
&#12288;&#12288;由于&#12304;<code>Ctrl + S</code>&#12305;在 Windows 上是很常见的组合键&#12290;某些菜鸟刚开始玩 Linux 命令行的时候&#65292;会习惯性地按这个组合键&#65292;结果就禁用了回显&#12290;这时候&#65292;任何键盘输入都没有反应&#12290;菜鸟就以为终端死掉了&#12290;<br>
<br>
<h3>&#9671;历史演变</h3><br>
&#12288;&#12288;对于 Windows 用户来说&#65292;&#12304;<code>Ctrl + S</code>&#12305;实在太常用了&#65292;很容易误按&#12290;肯定有大量的用户吐槽过 POSIX 终端的这个快捷键&#12290;<br>
&#12288;&#12288;那么&#65292;为啥要用这两个快捷键来控制&#8220;回显&#8221;捏&#65311;俺又要第 N 次说到&#12304;电传打字机&#12305;了&#12290;<br>
&#12288;&#12288;由于这玩意儿的输出是&#12304;打印纸&#12305;&#65292;其速率比较&#12304;慢&#12305;&#12290;一旦&#8220;对方发送字符的速率&#8221;高于&#8220;自己这边的打印速率&#8221;&#65292;就需要向对方发一个控制信号&#65292;让对方暂停发送&#65307;等到自己这边打印完了&#65292;再发送另一个控制字符&#65292;通知对方继续&#12290;<br>
&#12288;&#12288;&#65288;注&#65306;上述这种玩法&#65292;通信领域行话称之为&#8220;流量控制/流控&#8221;&#65289;<br>
&#12288;&#12288;当年用来表示&#8220;暂停发送&#8221;的控制字符&#65292;对应的就是&#12304;<code>Ctrl + S</code>&#12305;&#65307;用来&#8220;恢复发送&#8221;的控制字符&#65292;也正是&#12304;<code>Ctrl + Q</code>&#12305;&#12290;<br>
<br>
<a name="system-console"> </a><br>
<h2>&#9733;&#65288;早期的&#65289;系统控制台/物理控制台&#65288;system console&#65289;</h2><br>
&#12288;&#12288;&#65288;前面说了&#65289;在&#12304;没&#12305;发明&#8220;分时系统&#8221;之前&#65292;当时的计算机只能执行&#12304;单任务&#12305;&#12290;因此&#65292;那时候的大型机只有&#12304;一个&#12305;操作界面&#65292;称之为&#12304;控制台&#12305;&#12290;<br>
&#12288;&#12288;话说那时的&#8220;控制台&#8221;&#65292;真的是一个台子&#65288;参见下图&#65289;&#12290;<br>
<br>
<center><img src="../../images/2019/11/vc0kCy3x_3ds8LNeFUpgcE7HljoCBVAD1T-857bjeMUGIBweBrX32gZ27A5c7I2ChXLOljlh3h8_1iIYp39EvlNSn9w5x5zu5CTxWlO6W1aBV6qilF9pt0aq7MXCcZkq2SHMKS_5pt8" alt="不见图 请翻墙"><br>
&#65288;上世纪50年代&#65292;IBM 公司 704 大型机的控制台&#65289;</center><br>
&#12288;&#12288;后来发明了&#8220;分时系统&#8221;&#12290;如刚才所说&#8212;&#8212;&#8220;分时系统&#8221;使得大型机可以具备多个终端&#12290;在这种情况下&#65292;你可以把&#8220;控制台&#8221;通俗地理解为&#8220;本地终端&#8221;&#65292;而&#12304;不&#12305;是&#8220;控制台&#8221;的那些终端&#65292;称之为&#8220;远程终端&#8221;&#12290;<br>
&#12288;&#12288;在那个年代&#65292;计算机属于&#12304;非常非常稀缺&#12305;的资源&#12290;于是拥有大型机的公司&#65292;就可以&#12304;出租计算资源&#12305;&#65292;获得一笔相当可观的收入&#12290;他们把大型机的某个&#8220;远程终端&#8221;租给外来人员使用&#65292;然后根据&#8220;时间/空间&#8221;收取费用&#12290;由于资源的稀缺性&#65292;当年的 CPU 是按&#12304;秒&#12305;计费&#65292;而内存是按&#12304;KB&#12305;计费&#12290;<br>
&#12288;&#12288;由于&#8220;远程终端&#8221;可能会被&#12304;外人&#12305;使用&#65292;因此对&#8220;远程终端&#8221;的&#12304;权限&#12305;要进行一些限制&#12290;如果要进行一些高级别的操作&#65288;比如&#8220;关闭整个系统&#8221;&#65289;&#65292;就只能限制在&#12304;控制台&#12305;&#65288;本地终端&#65289;进行&#12290;有些公司为了安全起见&#65292;还会把&#8220;控制台&#8221;单独锁在某个&#8220;secured room&#8221;里面&#12290;<br>
<br>
<center><img src="../../images/2019/11/5AlRxQhR00CvQ3DSO-idsyShNRJAOMIGL1J5I3b1UE1kW1dZVE5gU8mBenZUF_DMxwi0nHYd6ju7J6JsdApfarb3E_1_jBJQ2fL4SMm60k34xVToDm41jWoHfZOY32nZEhJW247zx3U" alt="不见图 请翻墙"><br>
&#65288;上世纪60年代&#65292;DEC 公司 PDP-7 小型机的控制台&#65289;</center><br>
<a name="virtual-console"> </a><br>
<h2>&#9733;&#65288;如今的&#65289;虚拟控制台&#65288;virtual console&#65289;</h2><br>
&#12288;&#12288;到了 PC 时代&#65292;传统意义上的&#12304;控制台&#12305;已经看不到了&#12290;但 console 这个术语保留了下来&#12290;<br>
<br>
<h3>&#9671;从&#8220;物理 console&#8221;到&#8220;虚拟 console&#8221;</h3><br>
&#12288;&#12288;早期大型机的 console 是&#12304;独占&#12305;硬件滴&#8212;&#8212;&#8220;键盘/显示器&#8221;固定用于某个 console 滴&#12290;<br>
&#12288;&#12288;&#12304;现代&#12305;的 POSIX 系统&#65292;衍生出&#8220;virtual console&#8221;的概念&#8212;&#8212;可以让几个不同的 console&#12304;共用&#12305;一套硬件&#65288;键盘/显示器&#65289;&#12290;&#8220;virtual&#8221;一词就是这么来滴&#12290;<br>
&#12288;&#12288;再重复唠叨一下&#65306;不论是早期的&#8220;物理控制台&#8221;还是后来的&#8220;虚拟控制台&#8221;&#65292;都属于广义上的&#8220;终端&#8221;&#12290;<br>
<br>
<h3>&#9671;举例&#65306;Linux 的 virtual console</h3><br>
&#12288;&#12288;假设你的 Linux 系统没安装图形界面&#65288;或者默认不启用图形界面&#65289;&#65292;当系统启动完成之后&#65292;你会在屏幕上看到一个文本模式的登录提示&#12290;这个界面就是 virtual console 的界面&#12290;<br>
&#12288;&#12288;在默认情况下&#65292;Linux 内置了&#12304;6个&#12305;virtual console 用于命令行操作&#65292;然后把第7个 virtual console 预留给图形系统&#12290;你可以使用 <code>Alt + Fn</code> 或 <code>Ctrl + Alt + Fn</code> 在这几个 console 之间切换&#65288;注&#65306;上述所说的 <code>Fn</code> 指的是 F1&#12289;F2... 之类的功能键&#65289;&#12290;<br>
<br>
<h3>&#9671;虚拟控制台的&#12304;内部结构&#12305;</h3><br>
<center><img src="../../images/2019/11/8rNRQNmIjTgBgt2N9RQQuzPJ4FP-03PcZfURXegbfEWowJ2XpAVNm3beOKXEVOJIbFmrDUQi3EqylMhxr2igKvHVp95rP1cyKgtl8He00YemHrCUAtOzjZSE48C6bkWibmun8pJFOEI" alt="不见图 请翻墙"><br>
&#65288;TTY 示意图2&#65306;&#12304;虚拟控制台&#12305;的内部结构图&#65289;</center><br>
<a name="terminal-emulator"> </a><br>
<h2>&#9733;终端模拟器&#65288;terminal emulator&#65289;</h2><br>
&#12288;&#12288;请注意上面那张示意图&#65292;图中出现了一个&#12304;终端模拟器&#12305;&#65292;这就是本章节要说的东东&#12290;<br>
&#12288;&#12288;如果你对比前面的&#12304;TTY 示意图1&#12305;与&#12304;TTY 示意图2&#12305;的变化&#65292;会发现&#8212;&#8212;&#8220;UART &#65286; UART 驱动&#8221;没了&#65292;然后多了这个&#12304;终端模拟器&#12305;&#12290;<br>
&#12288;&#12288;多出来的这个玩意儿相当于加了一个&#12304;抽象层&#12305;&#65292;模拟出早期硬件终端的效果&#65292;因此就&#12304;无需改动&#12305;系统内核中的其它部分&#65292;比如&#65306;LDISC&#65288;<a href="https://en.wikipedia.org/wiki/Line_discipline" target="_blank" rel="nofollow">line discipline</a>&#65289;<br>
&#12288;&#12288;请注意&#65292;这个场景下的&#8220;终端模拟器&#8221;位于操作系统&#12304;内核&#12305;&#12290;换句话说&#65292;它属于&#12304;内核态&#12305;的模拟器&#12290;正是因为它处于这个地位&#65292;所以能够在&#8220;驱动&#8221;&#65286;&#8220;LDISC&#8221;之间进行协调&#12290;<br>
<br>
<a name="pty"> </a><br>
<h2>&#9733;伪终端&#65288;PTY/pseudotty/pseudoterminal&#65289;</h2><br>
<h3>&#9671;从&#8220;文本模式&#8221;到&#8220;图形模式&#8221;</h3><br>
&#12288;&#12288;前面讲的那些&#65292;都是&#12304;文本模式&#12305;&#65288;文本界面&#65289;&#12290;<br>
&#12288;&#12288;话说到了上世纪80年代&#65292;随着&#12304;图形界面&#12305;的兴起&#65292;就出现某种需求&#8212;&#8212;想在图形界面下使用&#8220;&#12304;文本&#12305;终端&#8221;&#12290;于是就出现了&#8220;<a href="https://en.wikipedia.org/wiki/Pseudoterminal" target="_blank" rel="nofollow">伪终端</a>&#8221;的概念&#12290;<br>
&#12288;&#12288;通俗地说&#65292;&#8220;伪终端&#8221;就是用某个图形界面的软件来模拟传统的&#8220;文本终端&#8221;的各种行为&#12290;前面说了&#65292;TTY 这个缩写相当于&#8220;终端&#8221;的同义词&#65307;因此&#8220;pseudotty&#8221; 就衍生出 PTY 这个缩写&#12290;<br>
<br>
<h3>&#9671;从&#8220;&#12304;内核态&#12305;终端模拟器&#8221;到&#8220;&#12304;用户态&#12305;终端模拟器&#8221;</h3><br>
&#12288;&#12288;在上一个章节中&#65292;emulator 运行在系统内核中&#65292;因此是&#8220;内核态模拟器&#8221;&#65307;<br>
&#12288;&#12288;等到后来搞&#8220;伪终端&#8221;的时候&#65292;就直接把这个玩意儿从&#12304;内核态&#12305;转到&#12304;用户态&#12305;&#8212;&#8212;让它直接运行在&#12304;桌面环境&#12305;&#12290;如此一来&#65292;用户就可以直接在桌面环境中使用&#8220;终端模拟器&#8221;&#12290;<br>
&#12288;&#12288;当&#8220;终端模拟器&#8221;变为&#12304;用户态&#12305;&#65292;它就&#12304;无法&#12305;直接与&#8220;键盘驱动 or 显卡驱动&#8221;打交道&#12290;在这种情况下&#65292;由&#8220;GUI 系统&#8221;&#65288;比如&#65306;X11&#65289;负责与这些驱动打交道&#65292;然后再把用户的输入输出转交给&#8220;终端模拟器&#8221;&#12290;<br>
<br>
&#12288;&#12288;下面这张示意图是 <a href="https://en.wikipedia.org/wiki/Xterm" target="_blank" rel="nofollow">xterm</a>&#12290;别看它长得丑&#65292;它的出现也算是&#8220;里程碑&#8221;了&#12290;<br>
<br>
<center><img src="../../images/2019/11/2GRHQZetZPor718nRQB0D4JPscPyssaw4c2ufUOa-EF73PWb-SmTFNJYjILwZ5znmpzX6qEdHrT5-1R83TmZAKUVzr4IhfdRMYmpZQmZC16qqIcaaJOESrJUX798-qtrtUSIE9lEUH4" alt="不见图 请翻墙"><br>
&#65288;xterm&#8212;&#8212;&#8220;图形化终端模拟器&#8221;的祖师爷&#65289;</center><br>
<h3>&#9671;内部结构示意图</h3><br>
&#12288;&#12288;很多人把&#8220;emulator&#8221;与&#8220;PTY&#8221;混为一谈&#12290;实际上两者处于&#12304;不同&#12305;层次&#12290;<br>
&#12288;&#12288;在操作系统内部&#65288;内核&#65289;&#65292;PTY 分为两部分实现&#65292;分别叫做&#8220;PTY master&#8221; &#65286; &#8220;PTY slave&#8221;&#12290;master 负责与&#8220;terminal emulator&#8221;打交道&#65307;而用户通过 emulator 里面的 shell 启动的其它进程&#65292;则与 slave 打交道&#12290;<br>
&#12288;&#12288;在这个环节中&#65292;&#8220;PTY slave&#8221;又进一步缩写为&#8220;PTS&#8221;&#12290;如果你用 <code>ps</code> 命令查看系统中的所有进程&#65292;经常会看到 PTS 之类的字样&#65292;指的就是这个玩意儿&#12290;对普通用户而言&#65292;看到的是&#8220;终端模拟器&#8221;的界面&#65292;至于 PTY 内部的 master &#65286; slave&#65292;通常是感觉不到滴&#12290;<br>
<br>
&#12288;&#12288;为了让大伙儿更加直观&#65292;再放一张 PTY 的结构示意图&#12290;<br>
<br>
<center><img src="../../images/2019/11/58f8TOJpw7rR6_oGBLI9nVPiW1jBVddKBH30UTzWL3n8pyY4RSvF19SAJK-lkymlteMNeyffOHDXOXKYnHehTF2-2Hep1Q4bhwBTHdDkax3uDy1kR-3a75DvxvH-LD2ggRTXUojHmy4" alt="不见图 请翻墙"><br>
&#65288;TTY 示意图3&#65306;&#12304;伪终端&#12305;的内部结构图&#65289;</center><br>
<a name="shell"> </a><br>
<h2>&#9733;shell&#8212;&#8212;命令行解释器</h2><br>
&#12288;&#12288;费了好多口水&#65292;咱们终于聊到 shell 了&#12290;<br>
&#12288;&#12288;顺便吐槽一下&#65306;<br>
&#12288;&#12288;扫盲命令行的教程&#65292;很少会像俺这样&#65292;从最基本的概念说起&#12290;其导致的后果就是&#8212;&#8212;很多人&#65288;甚至包括很多 Linux 程序员&#65289;都搞不清&#8220;shell&#12289;terminal&#12289;console&#12289;TTY&#12289;PTY&#12289;PTS&#8221;这些概念到底有啥区别&#12290;<br>
&#12288;&#12288;在&#12298;<a href="../../2019/10/Systematic-Learning.html">如何&#12304;系统性学习&#12305;&#8212;&#8212;从&#8220;媒介形态&#8221;聊到&#8220;DIKW 模型&#8221;</a>&#12299;一文中&#65292;俺特别强调了&#12304;基本概念/基础知识&#12305;的重要性&#12290;这也就是俺为啥前面要费这么多口水的原因&#12290;<br>
<br>
<h3>&#9671;shell VS terminal</h3><br>
&#12288;&#12288;前面所说的&#8220;终端&#8221;&#65288;terminal&#65289;&#65292;本质上是&#65306;<b>基于&#12304;文本&#12305;的输入输出机制</b>&#12290;它并&#12304;不&#12305;理解具体的命令及其语法&#12290;<br>
&#12288;&#12288;于是就需要引入 shell 这个玩意儿&#8212;&#8212;shell 负责解释你输入的命令&#65292;并根据你输入的命令&#65292;执行某些动作&#65288;包括&#65306;启动其它进程&#65289;&#12290;<br>
<br>
<h3>&#9671;常见 shell 举例</h3><br>
&#12288;&#12288;常见的 shell 包括如下这些&#65288;为避免排名纠纷&#65292;按字母序列出&#65289;&#65306;<br>
<blockquote style="background-color:#DDD;">bash<br>
csh<br>
fish<br>
ksh<br>
zsh</blockquote><br>
&#12288;&#12288;在维基百科的&#8220;<a href="https://en.wikipedia.org/wiki/Comparison_of_command_shells" target="_blank" rel="nofollow">这个页面</a>&#8221;&#65292;列出了各种各样的 shell 及其功能特性的对照表&#12290;<br>
&#12288;&#12288;如今影响力最大的 shell 是 <a href="https://en.wikipedia.org/wiki/Bash_(Unix_shell)" target="_blank" rel="nofollow">bash</a>&#65288;没有之一&#65289;&#12290;其名称源自&#8220;Bourne-again shell&#8221;&#65292;是 GNU 社区对 <a href="https://en.wikipedia.org/wiki/Bourne_shell" target="_blank" rel="nofollow">Bourne shell</a> 的重写&#65292;使之符合自由软件&#65288;GPL 协议&#65289;&#12290;<br>
&#12288;&#12288;本文后续章节对 shell 的举例&#65292;如果没有做特殊说明&#65292;均指 bash 这个 shell&#12290;<br>
<br>
<br>
<h2>&#9733;shell 的基本功能</h2><br>
<h3>&#9671;显示&#12304;命令行提示符&#12305;</h3><br>
&#12288;&#12288;当你打开一个 shell&#65292;会看闪烁的光标左侧显示一个东东&#65292;那个玩意儿就是&#12304;命令行提示符&#12305;&#65288;参见下图&#65289;<br>
<center><img src="../../images/2019/11/q5gzYkmF9TWwGKHNRJKXgE2EhnVrHdCuKSb_bij_33qGNGlHgLCg-FUmFqTGG0ySOa2r7ftvwcW8H1p1CwnGt_9F9q1Kb2PeeZlACYUk5B540yV0AxoLDcfaeSjjT62NeuEGh2hlYi8" alt="不见图 请翻墙"><br>
&#65288;截图中的&#8220;命令行提示符&#8221;包含了&#65306;用户名&#12289;当前路径&#12289;$分隔符&#65289;</center><br>
&#12288;&#12288;很多 shell 的&#8220;命令行提示符&#8221;都会包含&#12304;当前路径&#12305;&#12290;当你用 <code>cd</code> 命令切换目录&#65292;提示符也会随之改变&#12290;这有助于你搞清楚当前在哪个目录下&#65292;<b>可以有效避免误操作</b>&#12290;<br>
&#12288;&#12288;下面这张图演示了&#8212;&#8212;&#8220;命令行提示符&#8221;随着当前目录的变化而变化&#12290;<br>
<center><img src="../../images/2019/11/RY0bVcLsYb8NFwMCu2XFeYEtaNopq9mI-XHZguPCFF7ojalynKSebm1LWVrENzZk_8msixbqyzGae8y5MxysSu2Q_GNl7N9l8AGt9ltXwsr5nUt-XWIuQH0l-scWPyO0qkm-y_D1oJs" alt="不见图 请翻墙"></center><br>
&#12288;&#12288;大部分 shell 都可以让你自定义这个&#12304;命令行提示符&#12305;&#65292;使之显示更多的信息量&#12290;<br>
&#12288;&#12288;比如说&#65292;可以让它显示&#65306;当前的时间&#12289;主机名&#12289;上一个命令的退出码......<br>
&#12288;&#12288;&#65288;注&#65306;如果你需要开多个&#12304;远程&#12305;终端&#65292;去操作多个&#12304;不同&#12305;的系统&#65292;&#8220;主机名&#8221;就蛮有用&#65289;<br>
<br>
<h3>&#9671;解析用户输入的&#12304;命令行&#12305;</h3><br>
&#12288;&#12288;假设你想看一下 <code>/home</code> 这个目录下有哪些子目录&#65292;可以在 shell 中运行了如下命令&#65306;<br>
<br>
<pre class="shell" style="background-color:Black;color:LawnGreen;">ls /home
</pre><br>
&#12288;&#12288;当你输入这串命令并敲回车键&#65292;shell 会拿到这一行&#65292;然后它会分析出&#65292;空格前面的 <code>ls</code> 是一个外部命令&#65292;空格后面的 <code>/home</code> 是该命令的参数&#12290;<br>
&#12288;&#12288;然后 shell 会启动这个外部命令对应的进程&#65292;并把上述参数作为该进程的启动参数&#12290;<br>
<br>
<h3>&#9671;内部命令 VS 外部命令</h3><br>
&#12288;&#12288;&#65288;刚才提到了&#12304;外部命令&#12305;这个词汇&#65292;顺便解释一下&#65289;<br>
&#12288;&#12288;通俗地说&#65292;&#8220;内部命令&#8221;就是内置在 shell 中的命令&#65307;而&#8220;外部命令&#8221;则对应了某个具体的&#12304;可执行文件&#12305;&#12290;<br>
&#12288;&#12288;当你在 shell 中执行&#8220;外部命令&#8221;&#65292;shell 会启动对应的可执行文件&#65292;从而创建出一个&#8220;子进程&#8221;&#65307;而如果是&#8220;内部命令&#8221;&#65292;就&#12304;不&#12305;产生子进程&#12290;<br>
&#12288;&#12288;那么&#65292;如何判断某个命令是否为&#8220;外部命令&#8221;捏&#65311;<br>
&#12288;&#12288;比较简单的方法是&#8212;&#8212;用如下方式来帮你查找&#12290;如果某个命令能找到对应的可执行文件&#65292;就是&#8220;外部命令&#8221;&#65307;反之则是&#8220;内部命令&#8221;&#12290;<br>
<pre class="shell" style="background-color:Black;color:LawnGreen;">whereis 命令名称
</pre><br>
<h3>&#9671;翻译&#12304;通配符&#12305;</h3><br>
&#12288;&#12288;玩过命令行的同学&#65292;应该都知道&#65306;&#8220;星号&#8221;&#65288;<code>*</code>&#65289;与&#8220;问号&#8221;&#65288;<code>?</code>&#65289;可以作为通配符&#65292;用来模糊匹配文件名&#12290;<br>
&#12288;&#12288;当你在 shell 中执行的命令包含了上述两个通配符&#65292;实际上是 shell 先把&#8221;通配符&#8220;翻译成具体的文件名&#65292;然后再传给相应命令&#12290;<br>
<br>
<h3>&#9671;翻译某些&#12304;特殊符号&#12305;</h3><br>
&#12288;&#12288;比如说&#65306;在 POSIX 系统中&#65292;通常用 <code>~</code> 来表示当前用户的&#12304;主目录&#12305;&#65288;home 目录&#65289;&#12290;<br>
&#12288;&#12288;如果你在 shell 中用到了 <code>~</code> 这个符号&#65292;shell 会先把该符号翻译成&#8220;home 目录的&#12304;全路径&#12305;&#8221;&#65292;然后再传给相应命令&#12290;<br>
<br>
<h3>&#9671;翻译&#12304;别名&#12305;</h3><br>
&#12288;&#12288;很多 POSIX 的 shell 都支持用 <code>alias</code> 命令设置别名&#65288;把一个较长的命令串&#65292;用一个较短的别名来表示&#65289;&#12290;<br>
&#12288;&#12288;设置了别名之后&#65292;当你在 shell 中使用&#8220;别名&#8221;&#65292;由 shell 帮你翻译成原先的命令串&#12290;<br>
<br>
&#12288;&#12288;举例&#65306;<br>
&#12288;&#12288;在&#12298;<a href="../../2019/09/Netcat-Tricks.html">扫盲 netcat&#65288;网猫&#65289;的 N 种用法&#8212;&#8212;从&#8220;网络诊断&#8221;到&#8220;系统入侵&#8221;</a>&#12299;一文中&#65292;俺使用如下命令创建了 <code>nc-tor</code> 这个别名&#12290;<br>
<pre class="shell" style="background-color:Black;color:LawnGreen;">alias nc-tor='nc -X 5 -x 127.0.0.1:9050'
</pre>&#12288;&#12288;设置完之后&#65292;当你在 shell 中执行了这个 <code>nc-tor</code> 命令&#65292;shell 会把它自动翻译成 <code>nc -X 5 -x 127.0.0.1:9050</code><br>
<br>
<h3>&#9671;历史命令</h3><br>
&#12288;&#12288;大部分 shell 都会记录历史命令&#12290;你可以使用某些设定的快捷键&#65288;通常是&#12304;向上&#12305;的方向键&#65289;&#65292;重新运行之前执行过的命令&#12290;<br>
<br>
<h3>&#9671;自动补全</h3><br>
&#12288;&#12288;很多 shell 都具备自动补全的功能&#12290;<br>
&#12288;&#12288;该功能不仅指&#8220;命令&#8221;本身的自动补全&#65292;还包括对&#8220;命令的参数&#8221;进行自动补全&#12290;<br>
<br>
<h3>&#9671;操作&#8220;环境变量&#8221;</h3><br>
&#12288;&#12288;关于这部分&#65292;在下面的&#8220;环境变量&#8221;章节单独聊&#12290;<br>
<br>
<h3>&#9671;&#8220;管道&#8221;与&#8220;重定向&#8221;</h3><br>
&#12288;&#12288;关于这部分&#65292;在下面的&#8220;管道&#8221;章节单独聊&#12290;<br>
<br>
<h3>&#9671;&#8220;进程控制&#8221;与&#8220;作业控制&#8221;</h3><br>
&#12288;&#12288;关于这部分&#65292;在下面的&#8220;进程控制&#8221;与&#8220;作业控制&#8221;章节单独聊&#12290;<br>
<br>
<a name="process"> </a><br>
<h2>&#9733;进程的启动与退出</h2><br>
<h3>&#9671;进程的&#12304;启动&#12305;及其&#12304;父子关系&#12305;</h3><br>
&#12288;&#12288;一般来说&#65292;每个&#8220;进程&#8221;都是由另一个进程启动滴&#12290;如果&#8220;进程A&#8221;创建了&#8220;进程B&#8221;&#65292;则 A 是&#12304;父进程&#12305;&#65292;B 是&#12304;子进程&#12305;&#65288;这个&#8220;父子关系&#8221;很好理解&#8212;&#8212;因为完全符合直觉&#65289;<br>
&#12288;&#12288;有些同学会问&#65292;那最早的&#12304;第一个&#12305;进程是谁启动滴&#65311;<br>
&#12288;&#12288;一般来说&#65292;第一个进程由&#12304;操作系统内核&#12305;&#65288;kernel&#65289;亲自操刀运行起来&#65307;而 kernel 又是由&#8220;引导扇区&#8221;中的&#8220;boot loader&#8221;加载&#12290;<br>
<br>
<h3>&#9671;进程树</h3><br>
&#12288;&#12288;在 POSIX 系统&#65288;Linux &#65286; UNIX&#65289;&#65292;所有的进程构成一个&#12304;单根树&#12305;的层次关系&#12290;进程之间的&#8220;父子关系&#8221;&#65292;体现在&#8220;进程树&#8221;就是树上的&#12304;父子节点&#12305;&#12290;<br>
&#12288;&#12288;你可以使用如下命令&#65292;查看当前系统的&#8220;进程树&#8221;&#12290;<br>
<pre class="shell" style="background-color:Black;color:LawnGreen;">pstree
</pre><br>
<center><img src="../../images/2019/11/oyi3HQTSxSr8Jyov0B1gGtwvQrjuWsScmpmZamLS8KfpLAIUzUZ5AaZem5fcOnYsAGewJoVKviqGMirk8QVRFfPFC3YYe-Dbh_-czN3M0M_HHgOQh0BvxrGMVPnj6g4wrlmiJZwPVBM" alt="不见图 请翻墙"><br>
&#65288;&#8220;进程树&#8221;的效果图&#12290;注&#65306;为了避免暴露俺的系统信息&#65292;特意&#12304;不&#12305;用自己系统的截图&#65289;</center><br>
<h3>&#9671;初始进程</h3><br>
&#12288;&#12288;一般情况下&#65292;POSIX 系统的&#8220;进程树&#8221;的&#12304;根节点&#12305;就是系统开机之后&#12304;第一个&#12305;创建的进程&#65292;并且其进程编号&#65288;PID&#65289;通常是 1&#12290;这个进程称之为&#8220;初始进程&#8221;&#12290;<br>
&#12288;&#12288;&#65288;注&#65306;上述这句话并&#12304;不够&#12305;严密&#8212;&#8212;因为某些 UNIX 衍生系统的&#8220;进程树&#8221;&#65292;位于根节点的进程&#12304;不是&#12305;&#8220;初始化进程&#8221;&#12290;这种情况与本文的主题没太大关系&#65292;俺不打算展开讨论&#65289;<br>
&#12288;&#12288;对于&#8220;大部分 UNIX 衍生系统&#8221;以及&#8220;2010年之前的 Linux 发行版&#8221;&#65292;系统中的&#8220;初始进程&#8221;名叫 <code>init</code>&#65307;<br>
&#12288;&#12288;如今越来越多的 Linux 发行版采用 <a href="https://en.wikipedia.org/wiki/Systemd" target="_blank" rel="nofollow">systemd</a> 来完成系统引导之后的初始化工作&#12290;在这些发行版中&#65292;&#8220;初始进程&#8221;名叫 <code>systemd</code>&#12290;<br>
<br>
&#12288;&#12288;你可以用如下命令显示&#8220;进程树&#8221;中每个节点的&#8220;进程编号&#8221;&#65288;PID&#65289;&#65292;然后就能看到编号为 1 的&#8220;初始进程&#8221;&#12290;<br>
<pre class="shell" style="background-color:Black;color:LawnGreen;">pstree -p
</pre><br>
<h3>&#9671;进程的三种死法</h3><br>
&#12288;&#12288;关于进程如何死亡&#65292;大致有如下三种情况&#65306;<br>
<br>
&#12288;&#12288;<b>自然死亡</b><br>
&#12288;&#12288;如果某个进程把它该干的事情都干完了&#65292;自然就会退出&#12290;<br>
&#12288;&#12288;这种是最常见的情况&#65292;也是最优雅的死法&#12290;俺习惯称作&#12304;自然死亡&#12305;&#12290;<br>
<br>
&#12288;&#12288;<b>自杀</b><br>
&#12288;&#12288;如果某个进程的工作干到半当中&#65292;突然收到某个通知&#65292;让它立即退出&#12290;<br>
&#12288;&#12288;这时候&#65292;进程会赶紧处理一些善后工作&#65292;然后自行了断&#8212;&#8212;这就是&#12304;自杀&#12305;&#12290;<br>
<br>
&#12288;&#12288;<b>它杀</b><br>
&#12288;&#12288;比&#8220;自杀&#8221;更粗暴的方式称之为&#12304;它杀&#12305;&#12290;也就是让&#8220;操作系统内核&#8221;直接把进程干掉&#12290;<br>
&#12288;&#12288;在这种情况下&#65292;进程&#12304;不会&#12305;收到任何通知&#65292;因此也&#12304;不&#12305;可能进行任何善后事宜&#12290;<br>
<br>
&#12288;&#12288;&#65288;注&#65306;上述三种死法纯属比喻&#65292;以加深大伙儿的印象&#65307;不必太较真&#12290;十年前俺刚开博客&#65292;写过几篇帖子谈&#8220;<a href="../../2009/02/cxx-object-destroy-overview.html">C++ 对象之死</a>&#8221;&#65292;也用过类似比喻&#65289;<br>
&#12288;&#12288;关于&#8220;自杀&#65286;它杀&#8221;的方式&#65292;会涉及到&#12304;信号&#12305;&#12290;在下一个章节&#65292;俺会单独讨论&#12304;进程控制&#12305;&#65292;并会详细介绍&#8220;信号&#8221;的机制&#12290;<br>
<br>
<h3>&#9671;&#8220;孤儿进程&#8221;及其&#8220;领养&#8221;</h3><br>
&#12288;&#12288;如果某个进程死了&#65288;退出了&#65289;&#65292;而它的子进程还&#12304;没&#12305;死&#65292;那么这些子进程就被形象地称之为&#8220;孤儿&#8221;&#65292;然后会被上述提到的&#12304;初始进程&#12305;&#8220;领养&#8221;&#8212;&#8212;&#8220;初始进程&#8221;作为&#8220;孤儿进程&#8221;的父进程&#12290;<br>
&#12288;&#12288;对应到&#8220;进程树&#8221;&#8212;&#8212;&#8220;孤儿进程&#8221;会被重新调整到&#8220;进程树根节点&#8221;的&#12304;直接下级&#12305;&#12290;<br>
<br>
<a name="signal"> </a><br>
<h2>&#9733;&#8220;进程控制&#8221;与&#8220;信号&#8221;</h2><br>
<h3>&#9671;用&#12304;Ctrl + C&#12305;杀进程</h3><br>
&#12288;&#12288;为了演示这个效果&#65292;你可以执行如下命令&#65306;<br>
<pre class="shell" style="background-color:Black;color:LawnGreen;">ping 127.0.0.1
</pre><br>
&#12288;&#12288;如果是 Windows 系统里的 <code>ping</code> 命令&#65292;它只会进行4次&#8220;乒操作&#8221;&#65292;然后就自己退出了&#65307;<br>
&#12288;&#12288;但对于 POSIX 系统里面的 <code>ping</code> 命令&#65292;它会永远运行下去&#65288;直到被杀掉&#65289;&#12290;<br>
&#12288;&#12288;当 ping 在运行的时候&#65292;只要你按下 <code>Ctrl + C</code> 这个组合键&#65292;就可以立即终止这个 <code>ping</code> 进程&#12290;<br>
<br>
<h3>&#9671;&#8220;Ctrl + C&#8221;背后的原理&#8212;&#8212;&#12304;信号&#12305;&#65288;signal&#65289;</h3><br>
&#12288;&#12288;当你按下了 <code>Ctrl + C</code> 这个组合键&#65292;当前正在执行的进程会收到一个叫做&#12304;SIGINT&#12305;的信号&#12290;<br>
&#12288;&#12288;如果进程内部定义了针对该信号的处理函数&#65292;那么就会去执行这个函数&#65292;完成该函数定义的一些动作&#12290;一般而言&#65292;该函数会进行一些善后工作&#65292;然后进程退出&#12290;<br>
&#12288;&#12288;如果进程&#12304;没有&#12305;定义相应的处理函数&#65292;则会执行一个&#12304;默认动作&#12305;&#12290;对于 SIGINT 这个信号而言&#65292;默认动作就是&#8220;进程退出&#8221;&#12290;<br>
&#12288;&#12288;上述这2种情况&#65292;都属于前面所说的自杀&#12290;这2种属于&#12304;常规情况&#12305;&#12290;<br>
<br>
&#12288;&#12288;下面再来说&#12304;特殊情况&#12305;&#8212;&#8212;有时候 <code>Ctrl + C</code>&#12304;无法&#12305;让进程退出&#12290;为啥会这样捏&#65311;<br>
&#12288;&#12288;假如说&#65292;编写某个进程的程序员&#65292;定义了该信号的处理函数&#65292;但在这个函数内部&#65292;并&#12304;没有&#12305;执行&#8220;进程退出&#8221;这个动作&#12290;那么当该进程收到 SIGINT 信号之后&#65292;自然就&#12304;不会&#12305;退出&#12290;这种情况称之为&#8212;&#8212;<b>信号被该进程&#12304;屏蔽&#12305;了</b>&#12290;<br>
<br>
<h3>&#9671;&#12304;谁&#12305;发出&#8220;Ctrl + C&#8221;对应的信号&#65311;</h3><br>
&#12288;&#12288;很多人&#65288;包括很多玩命令行的老手&#65289;都有一个&#12304;误解&#12305;&#8212;&#8212;他们误以为是 shell 发送了 SIGINT 信号给当前进程&#12290;<b>其实不然&#65281;</b><br>
&#12288;&#12288;在上述 ping 的例子中&#65292;当 ping 进程在持续运行之时&#65292;你的键盘输入是关联到 ping 进程的&#8220;标准输入&#8221;&#65288;stdin&#65289;&#12290;在这种情况下&#65292;shell 根本&#12304;无法&#12305;获取你的按键信息&#12290;<br>
&#12288;&#12288;实际上&#65292;是&#12304;终端&#12305;获取了你的 <code>Ctrl + C</code> 组合键信息&#65292;并发送了 SIGINT 信号&#12290;因为&#12304;终端&#12305;处于更底层&#65292;它负责承载你所有的输入输出&#12290;因此&#65292;它当然可以截获用户的某个特殊的组合键&#65288;比如&#65306;<code>Ctrl + C</code>&#65289;&#65292;并执行某些特定的动作&#12290;<br>
&#12288;&#12288;聊到这里&#65292;大伙儿会发现&#8212;&#8212;<br>
如果没有正确理解&#8220;终端&#8221;与&#8220;shell&#8221;这两者的关系&#65292;就会犯很多错误&#65288;造成很多误解&#65289;&#12290;<br>
<br>
&#12288;&#12288;有的读者可能会问&#65306;&#8220;终端&#8221;如何知道&#12304;当前进程&#12305;是哪一个&#65311;&#65288;能想到这点&#65292;通常是比较爱思考滴&#65289;<br>
&#12288;&#12288;俺来解答一下&#65306;<br>
&#12288;&#12288;当 shell 启动了某个进程&#65292;它当然可以拿到这个进程的编号&#65288;pid&#65289;&#65292;于是 shell 会调用某个系统 API&#65288;比如 <code>tcsetpgrp</code>&#65289;把&#8220;进程编号&#8221;与 shell 所属的&#8220;终端&#8221;关联起来&#12290;<br>
&#12288;&#12288;当&#8220;终端&#8221;需要发送 SIGINT 信号时&#65292;再调用另一个系统 API&#65288;比如 <code>tcgetpgrp</code>&#65289;&#65292;就可以知道当前进程的编号&#12290;<br>
<br>
<h3>&#9671;对比杀进程的几个信号&#65306;SIGINT&#12289;SIGTERM&#12289;SIGQUIT&#12289;SIGKILL</h3><br>
&#12288;&#12288;<b>SIGINT</b><br>
&#12288;&#12288;在大部分 POSIX 系统的各种终端上&#65292;<code>Ctrl + C</code> 组合键触发的就是这个信号&#12290;<br>
&#12288;&#12288;通常情况下&#65292;进程收到这个信号后&#65292;做完相关的善后工作&#65292;就自行了断&#65288;自杀&#65289;&#12290;<br>
<br>
&#12288;&#12288;<b>SIGTERM</b><br>
&#12288;&#12288;这个信号基本类似于 SIGINT&#12290;<br>
&#12288;&#12288;它是 <code>kill</code> &#65286; <code>killall</code> 这两个命令&#12304;默认&#12305;使用的信号&#12290;<br>
&#12288;&#12288;也就是说&#65292;当你用这俩命令杀进程&#65292;并且&#12304;没有&#12305;指定信号类型&#65292;那么 <code>kill</code> 或 <code>killall</code> 用的就是这个 SIGTERM 信号&#12290;<br>
<br>
&#12288;&#12288;<b>SIGQUIT</b><br>
&#12288;&#12288;这个信号类似于前两个&#65288;SIGINT &#65286; SIGINT&#65289;&#65292;差别在于&#8212;&#8212;进程在退出前会执行&#8220;<a href="https://en.wikipedia.org/wiki/Core_dump" target="_blank" rel="nofollow">core dump</a>&#8221;操作&#12290;<br>
&#12288;&#12288;一般而言&#65292;只有程序员才会去关心&#8220;core dump&#8221;这个玩意儿&#65292;所以这里就不细聊了&#12290;<br>
<br>
&#12288;&#12288;<b>SIGKILL</b><br>
&#12288;&#12288;在杀进程的几个信号中&#65292;这个信号是是最牛逼的&#65288;也是最粗暴的&#65289;&#12290;<br>
&#12288;&#12288;前面三个信号都是&#12304;可屏蔽&#12305;滴&#65292;而这个信号是&#12304;不可屏蔽&#12305;滴&#12290;<br>
&#12288;&#12288;当某个进程收到了&#12304;SIGKILL&#12305;信号&#65292;该进程自己&#12304;完全没有&#12305;处理信号的机会&#65292;而是由操作系统内核直接把这个进程干掉&#12290;<br>
&#12288;&#12288;此种行为可以形象地称之为&#8220;它杀&#8221;&#12290;<br>
&#12288;&#12288;当你用下列这些命令杀进程&#65292;本质上就是在发送这个信号进行&#12304;它杀&#12305;&#12290;&#12304;SIGKILL&#12305;这个信号的编号是 <code>9</code>&#65292;下列这些命令中的 <code>-9</code> 参数就是这么来滴&#12290;<br>
<pre class="shell" style="background-color:Black;color:LawnGreen;">kill -9 进程号
kill -KILL 进程号

killall -9 进程名称
killall -KILL 进程名称
killall -SIGKILL 进程名称
</pre><br>
&#12288;&#12288;为了方便对照上述这4种&#65292;俺放一个表格如下&#65306;<br>
<center><table border="1" cellspacing="0" cellpadding="3"><tbody>
<tr style="background:lightgrey;"><th>信号名称</th><th>编号</th><th>能否屏蔽</th><th>默认动作</th><th>俗称</th></tr>
<tr><td>SIGINT</td><td>2</td><td>YES</td><td>进程自己退出</td><td>自杀</td></tr>
<tr><td>SIGTERM</td><td>15</td><td>YES</td><td>进程自己退出</td><td>自杀</td></tr>
<tr><td>SIGQUIT</td><td>3</td><td>YES</td><td>执行 core dump<br>
进程自己退出</td><td>自杀</td></tr>
<tr><td>SIGKILL</td><td>9</td><td>NO</td><td>进程被内核干掉</td><td>它杀</td></tr>
</tbody></table></center><br>
<h3>&#9671;&#12304;它杀&#12305;的危险性与副作用</h3><br>
&#12288;&#12288;请注意&#65306;<b>&#12304;它杀&#12305;是一种比较危险的做法&#65292;可能导致一些&#12304;副作用&#12305;&#12290;</b>只有当你用其它各种方式都无法干掉某个进程&#65292;才考虑用这招&#12290;<br>
&#12288;&#12288;有读者在评论区问到了&#8220;它杀的副作用&#8221;&#65292;俺简单解释一下&#65306;<br>
&#12288;&#12288;一方面&#65292;当操作系统用这种方式杀掉某个进程&#65292;虽然可以把很多内存相关的资源释放掉&#65292;但&#12304;内存之外&#12305;的资源&#65292;内核就管不了啦&#65307;另一方面&#65292;由于进程遭遇&#8220;它杀&#8221;&#65292;无法完成某些善后工作&#12290;<br>
&#12288;&#12288;基于上述两点&#65292;就&#12304;有可能&#12305;会产生副作用&#12290;另外&#65292;&#8220;副作用的严重程度&#8221;取决于不同类型的软件&#12290;无法一概而论&#12290;<br>
<br>
&#12288;&#12288;<b>举例1&#65306;</b><br>
&#12288;&#12288;某个进程正在保存文件&#12290;这时候遭遇&#8220;它杀&#8221;可能会导致文件损坏&#12290;<br>
&#12288;&#12288;&#65288;注&#65306;虽然某些操作系统能做到&#8220;写操作的原子性&#8221;&#65292;但数据存储可能会涉及多个写操作&#12290;当进程在作&#12304;多个&#12305;关键性写操作时&#65292;遭遇它杀&#12290;可能导致数据文件&#12304;逻辑上&#12305;的损坏&#65289;<br>
<br>
&#12288;&#12288;<b>举例2&#65306;</b><br>
&#12288;&#12288;还有更复杂的情况&#65292;比如涉及跨主机的网络通讯&#12290;某个进程可能向&#12304;远程&#12305;的某个网络服务分配了某个远程的资源&#65292;当进程&#8220;自然死亡 or 自杀&#8221;&#65292;它会在&#8220;善后工作&#8221;释放这个资源&#65307;而如果死于内核的&#8220;它杀&#8221;&#65292;这个远程的资源就&#12304;没&#12305;释放&#12290;<br>
<br>
<h3>&#9671;kill VS killall</h3><br>
&#12288;&#12288;这两个的差别在于&#8212;&#8212;前者用&#8220;进程号&#8221;&#65292;后者用&#8221;进程名&#8220;&#65288;也就是可执行文件名&#65289;&#12290;<br>
&#12288;&#12288;对于新手而言&#65292;<br>
如果用 <code>kill</code> 命令&#65292;你需要先用 <code>ps</code> 命令打印出当前进程清单&#65292;然后找到你要杀的进程的编号&#65307;而如果要用 <code>killall</code> 命令&#65292;就比较省事&#65288;比较傻瓜化&#65289;&#12290;但万一碰到有多个&#12304;同名&#12305;进程在运行&#65292;而你只想干掉其中一个&#65292;那么就得老老实实用 <code>kill</code> 了&#12290;<br>
<br>
<h3>&#9671;进程退出码</h3><br>
&#12288;&#12288;任何一个进程退出的时候&#65292;都对应某个&#12304;整数类型&#12305;的&#8220;退出码&#8221;&#12290;<br>
&#12288;&#12288;按照 POSIX 系统&#65288;UNIX &#65286; Linux&#65289;的传统惯例&#8212;&#8212;<br>
当&#8220;退出码&#8221;为&#12304;零&#12305;&#65292;表示&#8220;成功 or 正常状态&#8221;&#65307;<br>
当&#8220;退出码&#8221;&#12304;非零&#12305;&#65292;表示&#8220;失败 or 异常状态&#8221;&#12290;<br>
<br>
<h3>&#9671;暂停进程</h3><br>
&#12288;&#12288;刚才聊&#8220;杀进程&#8221;的时候提到了&#8220;自杀 VS 它杀&#8221;&#12290;前者比较&#8220;温柔&#8221;&#65307;而后者比较&#8220;粗暴&#8221;&#12290;<br>
&#12288;&#12288;对于暂停进程&#65292;也有&#8220;温柔 &#65286; 野蛮&#8221;两种玩法&#12290;而且也是用 <code>kill</code> 命令发信号&#12290;<br>
<br>
&#12288;&#12288;<b>&#12304;温柔&#12305;式暂停&#65288;SIGTSTP&#65289;</b><br>
<pre class="shell" style="background-color:Black;color:LawnGreen;">kill -TSTP 进程编号
</pre>&#12288;&#12288;这个&#12304;SIGTSTP&#12305;信号类似前面提及的&#12304;SIGINT&#12305;&#8212;&#8212;<br>
1. 两者默认都绑定到组合键&#65288;&#12304;SIGINT&#12305;默认绑定到组合键&#12304;<code>Ctrl + C</code>&#12305;&#65307;&#12304;SIGTSTP&#12305;默认绑定到组合键&#12304;<code>Ctrl + Z</code>&#12305;&#65289;<br>
2. 这两个快捷键都是由&#12304;终端&#12305;截获&#65292;并发出相应的信号&#65288;具体原理参见本章节的某个小节&#65289;<br>
3. 两者都是&#12304;可&#12305;屏蔽的信号&#12290;也就是说&#65292;如果某个进程屏蔽了&#12304;SIGTSTP&#12305;信号&#65292;你就&#12304;无法&#12305;用该方式暂停它&#12290;这时候你就得改用&#12304;粗暴&#12305;的方式&#65288;如下&#65289;&#12290;<br>
<br>
&#12288;&#12288;<b>&#12304;粗暴&#12305;式暂停&#65288;SIGSTOP&#65289;</b><br>
<pre class="shell" style="background-color:Black;color:LawnGreen;">kill -STOP 进程编号
</pre>&#12288;&#12288;这个&#12304;SIGSTOP&#12305;信号与前面提及的&#12304;SIGKILL&#12305;有某种相同之处&#8212;&#8212;这两个信号都属于&#12304;不可屏蔽&#12305;的信号&#12290;也就是说&#65292;收到&#12304;SIGSTOP&#12305;信号的进程&#12304;无法&#12305;抗拒被暂停&#65288;suspend&#65289;的命运&#12290;<br>
<br>
&#12288;&#12288;与&#8220;杀进程&#8221;的风格类似&#8212;&#8212;当你想要暂停某进程&#65292;应该先尝试&#8220;温柔&#8221;的方法&#65292;搞不定再用&#8220;粗暴&#8221;的方法&#65288;套用咱们天朝的老话叫&#8220;先礼后兵&#8221;&#65289;&#12290;<br>
<br>
<h3>&#9671;恢复进程</h3><br>
&#12288;&#12288;当你想要重新恢复&#65288;resume&#65289;被暂停的进程&#65292;就用如下命令&#65288;该命令发送信号&#12304;SIGCONT&#12305;&#65289;<br>
<pre class="shell" style="background-color:Black;color:LawnGreen;">kill -CONT 进程编号
</pre><br>
<h3>&#9671;引申阅读</h3><br>
&#12288;&#12288;除了前面几个小节提到的信号&#65292;POSIX 系统还支持其它一些信号&#65292;具体参见维基百科的&#8220;<a href="https://en.wikipedia.org/wiki/Signal_(IPC)" target="_blank" rel="nofollow">这个页面</a>&#8221;&#12290;<br>
<br>
<a name="job"> </a><br>
<h2>&#9733;作业控制&#65288;job&#65289;</h2><br>
&#12288;&#12288;聊完了&#8220;进程控制&#8221;&#65292;再来聊&#8220;作业控制&#8221;&#12290;<br>
&#12288;&#12288;&#65288;注&#65306;这里所说的&#8220;作业&#8221;是从洋文 job 翻译过来滴&#65289;<br>
<br>
<h3>&#9671;啥是&#8220;作业&#8221;&#65311;</h3><br>
&#12288;&#12288;&#8220;作业&#8221;是 shell 相关的术语&#65292;用来表示&#12304;进程组&#12305;的概念&#65288;每个作业就是一组进程&#65289;&#12290;<br>
&#12288;&#12288;比如说&#65292;当你用&#8220;管道符&#8221;把若干命令串起来执行&#65292;这几个命令对应的进程就被视作&#12304;一组&#12305;&#12290;<br>
&#12288;&#12288;&#65288;注&#65306;&#8220;管道符&#8221;的用法&#65292;后面某个章节会介绍&#65289;<br>
<br>
<h3>&#9671;同步执行&#65288;前台执行&#65289; VS 异步执行&#65288;后台执行&#65289;</h3><br>
&#12288;&#12288;大部分情况下&#65292;你在 shell 中执行的命令都是&#8220;同步执行&#8221;&#65288;或者叫&#8220;前台执行&#8221;&#65289;&#12290;对于这种方式&#65292;只有当命令运行完毕&#65292;你才会重新看到 shell 的&#8220;命令行提示符&#8221;&#12290;<br>
&#12288;&#12288;如果你以&#8220;异步执行&#8221;的方式启动某个外部命令&#65292;在这个命令还没有执行完的时候&#65292;你就可以重新看到&#8220;命令行提示符&#8221;&#12290;<br>
<br>
&#12288;&#12288;请注意&#65306;<br>
&#12288;&#12288;对于&#12304;短&#12305;寿命的外部命令&#65288;耗时很短的外部命令&#65289;&#65292;&#8220;同步/异步&#8221;两种方式其实&#12304;没&#12305;啥区别&#12290;比如 <code>ls</code> 命令通常很快就执行完毕&#65292;你就感觉不到上述两种方式的差异&#12290;<br>
&#12288;&#12288;只有当你执行了某个&#12304;长&#12305;寿命的外部命令&#65288;其执行时间至少达到若干秒&#65289;&#65292;上述这两种方式才会体现出差别&#12290;<br>
<br>
&#12288;&#12288;到目前为止&#65292;本文之前聊的命令执行方式&#65292;都属于&#8220;同步执行&#8221;&#65307;如果想用&#12304;异步&#12305;&#65292;需要在整个命令的最末尾追加一个半角的 <code>&amp;</code> 符号&#12290;<br>
<br>
&#12288;&#12288;<b>&#12304;同步&#12305;方式举例</b><br>
&#12288;&#12288;下列命令以&#12304;同步&#12305;的方式启动火狐浏览器&#65292;只有当你关闭了火狐&#65292;才会重新看到 shell 的命令行提示符&#12290;<br>
<pre class="shell" style="background-color:Black;color:LawnGreen;">firefox
</pre><br>
&#12288;&#12288;<b>&#12304;异步&#12305;方式举例</b><br>
&#12288;&#12288;下列命令以&#12304;异步&#12305;的方式启动火狐浏览器&#12290;你刚敲完回车&#65292;就会重新看到 shell 的&#8220;命令行提示符&#8221;&#65288;此时火狐依然在运行&#65289;<br>
<pre class="shell" style="background-color:Black;color:LawnGreen;">firefox &amp;
</pre><br>
&#12288;&#12288;以&#8220;同步&#8221;方式启动的进程&#65292;称作&#8220;&#12304;前台&#12305;进程&#8221;&#65307;反之&#65292;以&#8220;异步&#8221;方式启动的进程&#65292;称作&#8220;&#12304;后台&#12305;进程&#8221;&#12290;<br>
<br>
<h3>&#9671;&#8220;前台&#8221;切换到&#8220;后台&#8221;</h3><br>
&#12288;&#12288;假设当前的 shell 正在执行某个长寿命的&#12304;前台&#12305;进程&#65292;你可以按&#12304;<code>Ctrl + Z</code>&#12305;&#65292;就可以让该进程变为&#12304;后台&#12305;进程&#8212;&#8212;此时你立即可以看到&#8220;命令提示符&#8221;&#12290;<br>
&#12288;&#12288;只要你不是太健忘&#65292;应该记得前一个章节有提到过&#12304;<code>Ctrl + Z</code>&#12305;这个组合键&#8212;&#8212;它用来实现&#8221;&#12304;温柔&#12305;式暂停&#8220;&#65292;其原理是&#65306;向目标进程发送&#12304;SIGTSTP&#12305;信号&#12290;<br>
<br>
<h3>&#9671;&#8220;后台&#8221;切换到&#8220;前台&#8221;</h3><br>
&#12288;&#12288;假设当前 shell 正在执行某个后台进程&#12290;由于该进程在&#12304;后台&#12305;执行&#65292;此时有&#8220;命令提示符&#8221;&#65292;然后你在 shell 中执行 <code>fg</code> 命令&#65292;就可以把该后台进程切换到&#12304;前台&#12305;&#12290;<br>
<br>
&#12288;&#12288;某些爱思考的同学会问了&#8212;&#8212;如果同时启动了&#12304;多个&#12305;&#8220;后台进程&#8221;&#65292;<code>fg</code> 命令会切换哪一个捏&#65311;<br>
&#12288;&#12288;在这种情况下&#65292;<code>fg</code> 命令切换的是&#12304;最后启动&#12305;的那个&#12290;<br>
<br>
&#12288;&#12288;如果你有 N 个&#8220;后台进程&#8221;&#65292;你想把其中的某个切换为&#8220;前台进程&#8221;&#65292;这时候就需要用到 <code>jobs</code> 命令&#12290;该命令与乔布斯同名 :)<br>
&#12288;&#12288;举例&#65306;<br>
&#12288;&#12288;假设俺同时启动了 vim 与 emacs 作为后台进程&#65292;先用 <code>jobs</code> 命令列出所有的后台进程&#12290;假设该命令的输出是如下这个样子&#12290;<br>
<pre class="shell" style="background-color:Black;color:LawnGreen;">$ jobs
[1]  running    vim
[2]  running    emacs
</pre>&#12288;&#12288;在上述的终端窗口&#65292;中括号里面的数字称作&#8220;job id&#8221;&#12290;你可以用 <code>fg</code> 命令搭配&#8220;job id&#8221;&#65292;把某个后台进程切换到前台&#12290;<br>
&#12288;&#12288;&#65288;在本例中&#65289;如果你想切换 emacs 到前台&#65292;就运行 <code>fg %2</code>&#65292;如果想切换 vim 就运行 <code>fg %1</code>&#65288;以此类推&#65289;<br>
<br>
<h3>&#9671;引申阅读</h3><br>
&#12288;&#12288;想进一步了解&#8220;作业控制&#8221;&#65292;可以参考维基百科&#65288;<a href="https://en.wikipedia.org/wiki/Job_control_(Unix)" target="_blank" rel="nofollow">这个链接</a>&#65289;&#12290;<br>
<br>
<a name="environment-variable"> </a><br>
<h2>&#9733;环境变量&#65288;environment variable&#65289;</h2><br>
<h3>&#9671;&#8220;环境变量&#8221;是啥&#65311;</h3><br>
&#12288;&#12288;所谓的&#8220;环境变量&#8221;&#65292;你可以通俗理解为某种&#12304;名值对&#12305;&#8212;&#8212;每个&#8220;环境变量&#8221;都有自己的&#12304;名称&#12305;和&#12304;值&#12305;&#12290;并且名称必须是&#12304;唯一&#12305;滴&#12290;<br>
<br>
<h3>&#9671;如何添加并修改&#8220;环境变量&#8221;&#65311;</h3><br>
&#12288;&#12288;在 bash&#65288;或兼容 bash 的其它 shell&#65289;&#65292;你可以用 <code>export</code> 设置环境变量&#12290;比如下面这个命令行设置了一个&#8220;环境变量&#8221;&#65292;其名称是 <code>abc</code>&#65292;其值是 <code>xyz</code><br>
<pre class="shell" style="background-color:Black;color:LawnGreen;">export abc=xyz
</pre><br>
&#12288;&#12288;假如你要设置的&#12304;值&#12305;包含空格&#65292;记得用双引号引用该值&#65288;示例如下&#65289;&#12290;<br>
<pre class="shell" style="background-color:Black;color:LawnGreen;">export abc="program think"
</pre><br>
&#12288;&#12288;由于&#8220;环境变量&#8221;的名称具有&#12304;唯一性&#12305;&#65292;当你设置&#12304;同名&#12305;的&#8220;环境变量&#8221;就等同于对它的&#12304;修改&#12305;&#12290;<br>
<br>
<h3>&#9671;如何查看&#8220;环境变量&#8221;&#65311;</h3><br>
&#12288;&#12288;设置完之后&#65292;你可以用 <code>env</code> 命令查看&#12290;该命令会列出&#12304;当前 shell&#12305;中的&#12304;全部&#12305;&#8220;环境变量&#8221;&#12290;<br>
<br>
<h3>&#9671;&#8220;环境变量&#8221;的&#12304;可见性&#12305;和&#12304;可继承性&#12305;</h3><br>
&#12288;&#12288;某个进程设置的&#8220;环境变量&#8221;&#65292;其&#12304;可见性&#12305;仅限于该进程及其子进程&#65288;也就是&#8220;进程树&#8221;中&#65292;该进程所在的那个枝节&#65289;&#12290;<br>
&#12288;&#12288;基于上述的&#12304;可见性&#12305;原则&#65292;你在某个 shell 中设置的&#8220;环境变量&#8221;&#65292;只在&#8220;该 shell 进程本身&#8221;&#65292;以及通过该 shell 进程启动的&#8220;其它子进程&#8221;&#65292;才能看到&#12290;<br>
<br>
&#12288;&#12288;另外&#65292;如果系统关机&#65292;所有进程都会退出&#65292;那么你采用上一个小节&#65288;export 方式&#65289;设置的&#8220;环境变量&#8221;也就随之消失了&#12290;<br>
&#12288;&#12288;为了让某个&#8220;环境变量&#8221;永久生效&#65292;需要把相应的 <code>export</code> 命令添加到该 shell 的初始化配置文件中&#12290;对于 bash 而言&#65292;也就是 <code>~/.bashrc</code> 或者 <code>~/.profile</code><br>
&#12288;&#12288;估计有些同学会问&#65306;上述这两个初始化配置文件&#65292;有啥差别捏&#65311;<br>
&#12288;&#12288;俺如果有空&#65292;会单独写一篇关于 bash 的定制教程&#65292;到时候再聊这个话题&#12290;<br>
<br>
<h3>&#9671;&#8220;环境变量&#8221;有啥用&#65311;</h3><br>
&#12288;&#12288;通俗地说&#65292;&#8220;环境变量&#8221;是某种比较简单的&#8220;IPC 机制&#8221;&#65288;进程通讯机制&#65289;&#65292;可以让两个进程共享某个简单的文本信息&#12290;<br>
&#12288;&#12288;举例&#65306;<br>
&#12288;&#12288;很多知名的软件&#65288;比如&#65306;curl&#12289;emacs&#65289;都支持&#8220;以环境变量设置代理&#8221;&#12290;<br>
&#12288;&#12288;如果你按照它的约定&#65292;在 shell 中设置了约定名称和格式的&#8220;环境变量&#8221;&#65292;然后在&#12304;同一个&#12305;shell 中启动这个软件&#65292;&#65288;由于环境变量的&#12304;可继承性&#12305;&#65289;该软件就会看到这个&#8220;环境变量&#8221;&#65292;并根据&#8220;环境变量&#8221;包含的信息&#65292;设置代理&#12290;<br>
<br>
<a name="standard-stream"> </a><br>
<h2>&#9733;&#8220;标准流&#8221;&#65288;standard stream&#65289;与&#8220;重定向&#8221;&#65288;redirection&#65289;</h2><br>
<h3>&#9671;进程的3个&#8220;标准流&#8221;</h3><br>
&#12288;&#12288;在 POSIX 系统&#65288;Linux &#65286; UNIX&#65289;中&#65292;每个进程都内置了三个&#8220;标准流&#8221;&#65288;<a href="https://en.wikipedia.org/wiki/Standard_streams" target="_blank" rel="nofollow">standard stream</a>&#65289;&#65292;分别称作&#65306;&#8220;标准输入流&#8221;&#65288;stdin&#65289;&#65292;&#8220;标准输出流&#8221;&#65288;stdout&#65289;&#65292;&#8220;标准错误输出流&#8221;&#65288;stderr&#65289;&#12290;<br>
&#12288;&#12288;当进程启动后&#65292;在默认情况下&#65292;stdin 对接到终端的&#12304;输入&#12305;&#65307;stdout &#65286; stderr 对接到终端的&#12304;输出&#12305;&#12290;示意图如下&#65306;<br>
<br>
<center><img src="../../images/2019/11/JEfAB2UXDSRwczojJZOXEDAK5xH4E6YdksxZuIqq_5Tfe6xjwHrbeYX5EETlsHxQYk1Wm_wXg-ajpjIu3lHzYLeYJML5xxQQgsuhnZodUcC5jbtdLQ7_AflDdUkEfAthqHqBly3CQPo" alt="不见图 请翻墙"><br>
&#65288;三个&#12304;标准流&#12305;的示意图&#65289;</center><br>
&#12288;&#12288;如果你是程序员&#65292;俺补充一下&#65306;<br>
&#12288;&#12288;当你在程序中打开某个文件&#65292;会得到一个&#8220;文件描述符&#8221;&#65288;洋文叫&#8220;<a href="https://en.wikipedia.org/wiki/File_descriptor" target="_blank" rel="nofollow">file descriptor</a>&#8221;&#65292;简称 fd&#65289;&#12290;fd 本身是个整数&#65292;程序员可以通过 fd 对该文件进行读写&#12290;<br>
&#12288;&#12288;而进程的三个&#12304;标准流&#12305;&#65292;就相当于是三个特殊的 fd&#12290;当进程启动时&#65292;操作系统就已经把这三个 fd 准备好了&#12290;<br>
&#12288;&#12288;由于这三个玩意儿是预先备好滴&#65292;所以它们的数值分别是&#65306;0&#12289;1&#12289;2&#65288;参见上图中 # 后面的数字&#65289;&#12290;<br>
<br>
<h3>&#9671;演示&#8220;标准流&#8221;的实际效果</h3><br>
&#12288;&#12288;在本文前面的某个章节&#65292;俺已经用 gif 动画演示了终端的&#8220;行模式&#8221;&#12290;<br>
&#12288;&#12288;动画中的 <code>cat</code> 命令同样可以用来演示&#8220;标准输入输出&#8221;&#12290;俺把那个动画再贴一次&#12290;<br>
<br>
<center><img src="../../images/2019/11/PPet_RllllnSmYALmxV56ohy5NZz1kj76GzbmcvM9HJDrqY6h74otCFL1E0rG_lEKnALViM8zv2E4BOj4bUUTixzD_QTTXsmoh0-U3dxJROpiAfvW2vHZ69s2vpYlq88-6FBngqgzSQ" alt="不见图 请翻墙"><br>
&#65288;动画&#65306;&#8220;标准输入输出&#8221;的效果&#65289;</center><br>
&#12288;&#12288;请注意&#65292;第1行 <code>test</code> 是针对 <code>cat</code> 进程的&#12304;输入&#12305;&#65292;对应于&#12304;stdin&#12305;&#65288;你之所以能看到这行&#65292;是因为前面所说的&#12304;终端回显&#12305;&#65289;<br>
&#12288;&#12288;第2行 <code>test</code> 是 <code>cat</code> 进程拿到输入文本之后的原样输出&#65292;对应于&#12304;stdout&#12305;&#12290;<br>
<br>
<h3>&#9671;&#8220;标准流&#8221;的&#12304;<a href="https://en.wikipedia.org/wiki/Redirection_(computing)" target="_blank" rel="nofollow">重定向</a>&#12305;</h3><br>
&#12288;&#12288;所谓的&#12304;重定向&#12305;大体上分两种&#65306;<br>
<br>
&#12288;&#12288;<b>1. &#12304;输入流&#12305;重定向</b><br>
&#12288;&#12288;把某个文件重定向为 stdin&#65307;此时进程通过 stdin 读取的是该文件的内容&#12290;<br>
&#12288;&#12288;这种玩法使用小于号&#65288;<code>&lt;</code>&#65289;<br>
<br>
&#12288;&#12288;<b>2. &#12304;输出流&#12305;重定向</b><br>
&#12288;&#12288;把 stdout 重定向到某个文件&#65307;此时进程写入 stdout 的内容会&#12304;覆盖 or 追加&#12305;到这个文件&#12290;<br>
&#12288;&#12288;这种玩法使用&#12304;单个&#12305;大于号&#65288;<code>&gt;</code>&#65289;或&#12304;两个&#12305;大于号&#65288;<code>&gt;&gt;</code>&#65289;&#12290;前者用于&#12304;覆盖&#12305;文件内容&#65292;后者用于&#12304;追加&#12305;文件内容&#12290;<br>
<br>
&#12288;&#12288;另外&#65292;有时候你会看到 <code>2&gt;&amp;1</code> 这种写法&#12290;它表示&#65306;把 stderr 合并到 stdout&#12290;<br>
&#12288;&#12288;&#65288;注&#65306;前面俺提到过&#8212;&#8212;stdout 是&#8220;数值为 1 的文件描述符&#8221;&#65307;stderr 是&#8220;数值为 2 的文件描述符&#8221;&#65289;<br>
<br>
<h3>&#9671;&#12304;重定向&#12305;举例</h3><br>
&#12288;&#12288;<b>cat 的例子</b><br>
&#12288;&#12288;下面这个命令把某个文件重定向到 <code>cat</code> 的 stdin&#12290;<br>
<pre class="shell" style="background-color:Black;color:LawnGreen;">cat &lt; 文件名
</pre><br>
&#12288;&#12288;很多菜鸟容易把上面的命令与下面的命令搞混淆&#12290;<br>
&#12288;&#12288;请注意&#65306;上面的命令用的是&#12304;输入重定向&#12305;&#65292;而下面的命令用的是&#12304;命令行参数&#12305;&#12290;<br>
<pre class="shell" style="background-color:Black;color:LawnGreen;">cat 文件名
</pre><br>
&#12288;&#12288;<code>cat</code> 命令还可以起到类似&#8220;文件复制&#8221;的效果&#12290;<br>
&#12288;&#12288;比如你已经有个 <code>文件1</code>&#65292;用下面这种玩法&#65292;会创建出一个内容完全相同的 <code>文件2</code>&#12290;<br>
<pre class="shell" style="background-color:Black;color:LawnGreen;">cat &lt; 文件1 &gt; 文件2
</pre>&#12288;&#12288;某些同学可能会问了&#65306;既然能这么玩&#65292;为啥还需要用 <code>cp</code> 命令进行文件复制捏&#65311;<br>
&#12288;&#12288;原因在于&#65306;<code>cat</code> 的玩法&#65292;只保证内容一样&#65292;其它的不管&#65307;而 <code>cp</code> 除了复制文件内容&#65292;还会确保&#8220;目标文件&#8221;与&#8220;源文件&#8221;具有相同的属性&#65288;比如 mode&#65289;&#12290;<br>
<br>
&#12288;&#12288;<b>更多的例子</b><br>
&#12288;&#12288;在之前那篇&#12298;<a href="../../2019/09/Netcat-Tricks.html">扫盲 netcat&#65288;网猫&#65289;的 N 种用法&#8212;&#8212;从&#8220;网络诊断&#8221;到&#8220;系统入侵&#8221;</a>&#12299;&#65292;里面介绍了十多种 nc 的玩法&#12290;很多都用到了&#12304;重定向&#12305;&#12290;<br>
<br>
<a name="anonymous-pipe"> </a><br>
<h2>&#9733;匿名管道&#65288;anonymous pipe&#65289;</h2><br>
<h3>&#9671;&#8220;匿名管道&#8221;的&#12304;原理&#12305;</h3><br>
&#12288;&#12288;在大部分 shell 中&#65292;使用竖线符号&#65288;<code>|</code>&#65289;来表示&#12304;管道符&#12305;&#12290;用它来创建一个&#12304;<a href="https://en.wikipedia.org/wiki/Anonymous_pipe" target="_blank" rel="nofollow">匿名管道</a>&#12305;&#65292;使得前一个命令&#65288;进程&#65289;的&#8220;标准输出&#8221;关联到后一个命令&#65288;进程&#65289;的&#8220;标准输入&#8221;&#12290;<br>
<br>
<h3>&#9671;举例</h3><br>
&#12288;&#12288;俺曾经在&#8220;<a href="../../2013/01/cross-host-use-gfw-tool.html">这篇博文</a>&#8221;中介绍过&#8212;&#8212;如何用 <code>netstat</code> 查看当前系统的监听端口&#12290;<br>
&#12288;&#12288;对于 Windows 系统&#65292;可以用如下命令&#65306;<br>
<pre class="shell" style="background-color:Black;color:LawnGreen;">netstat -an | find "LISTEN"
</pre>&#12288;&#12288;对于 POSIX 系统&#65292;可以用如下命令&#65306;<br>
<pre class="shell" style="background-color:Black;color:LawnGreen;">netstat -an | grep "LISTEN"
</pre><br>
&#12288;&#12288;在上述两个例子中&#65292;都用到了&#12304;管道符&#12305;&#12290;因为 <code>netstat -an</code> 这个命令的输出可能会很多&#65292;先把它的输出通过&#12304;匿名管道&#12305;丢给某个专门负责过滤的命令&#65288;比如&#65306;POSIX 的 grep 或 Windows 的find&#65289;&#12290;当这个过滤命令拿到 <code>netstat</code> 的输出内容&#65292;再根据你在命令行参数中指定的&#12304;关键字&#12305;&#65288;也就是上述例子中的 <code>LISTEN</code>&#65289;&#65292;过滤出包含&#12304;关键字&#12305;的那些&#12304;行&#12305;&#12290;<br>
&#12288;&#12288;最终&#65292;你看到的是&#8220;过滤命令&#8221;&#65288;grep 或 find&#65289;的输出&#12290;<br>
<br>
<h3>&#9671;&#12304;串联的&#12305;匿名管道&#65288;chained pipeline&#65289;</h3><br>
&#12288;&#12288;前面的例子&#65292;可以用来列出当前系统中所有的监听端口&#12290;<br>
&#12288;&#12288;现在&#65292;假设你运行了 Tor Browser&#65292;然后想看看它到底有没有开启 <code>9150</code> 这个监听端口&#65292;那么你就可以在上述命令中进行&#12304;二次过滤&#12305;&#65288;具体命令大致如下&#65289;&#12290;这就是所谓的&#12304;串联&#12305;&#12290;<br>
<pre class="shell" style="background-color:Black;color:LawnGreen;">netstat -an | grep "LISTEN" | grep "9150"
</pre><br>
<h3>&#9671;&#8220;匿名管道&#8221;与&#8220;作业&#8221;&#65288;进程组&#65289;</h3><br>
&#12288;&#12288;用&#8220;匿名管道&#8221;串起来的多个进程&#65292;构成一个&#8220;作业&#8221;&#65288;这点前面提到了&#65289;&#12290;<br>
&#12288;&#12288;你可以尝试执行某个长寿命的&#65292;带管道符的命令行&#65292;然后用 <code>Ctrl + Z</code> 切到后台&#65292;再执行 <code>jobs</code> 看一下&#65292;就能看出&#8212;&#8212;该命令行对应的&#12304;多个&#12305;进程属于同一个 job&#12290;<br>
<br>
<a name="batch"> </a><br>
<h2>&#9733;批处理&#65288;batch&#65289;</h2><br>
<h3>&#9671;啥是&#8220;批处理&#8221;&#65311;</h3><br>
&#12288;&#12288;通俗地说就是&#65306;同时执行多个命令&#12290;<br>
&#12288;&#12288;为了支持&#8220;批处理&#8221;&#65292;shell 需要提供若干语法规则&#12290;而且不同类型的 shell&#65292;用来搞&#8220;批处理&#8221;的语法规则也存在差异&#12290;<br>
&#12288;&#12288;在本章节中&#65292;俺以 bash 来举例&#12290;<br>
<br>
<h3>&#9671;&#12304;无&#12305;条件的&#8220;批处理&#8221;</h3><br>
&#12288;&#12288;如果你把多个命令写在同一行&#65292;并且命令之间用半角分号隔开&#65292;这种玩法就属于&#12304;无条件&#12305;的批处理执行&#12290;<br>
&#12288;&#12288;举例&#65306;<br>
&#12288;&#12288;假设当前目录下有一个 <code>abc.txt</code> 文件&#65292;然后要在当前目录下创建一个名为 <code>xxx</code> 的子目录&#65292;并把 <code>abc.txt</code> 移动到这个新创建的子目录中&#12290;你可以用如下方式搞定&#65288;只用&#12304;一行&#12305;命令&#65289;<br>
<pre class="shell" style="background-color:Black;color:LawnGreen;">mkdir ./xxx/; mv abc.txt ./xxx/
</pre><br>
&#12288;&#12288;为啥这种方式叫做&#8220;&#12304;无条件&#12305;批处理&#8221;捏&#65311;因为不管前一个&#8220;子命令&#8221;是否成功&#65292;都会继续执行下一个&#8220;子命令&#8221;&#12290;<br>
<br>
&#12288;&#12288;请注意&#65306;<br>
&#12288;&#12288;虽然俺上述举例只使用了两个&#8220;子命令&#8221;&#65292;但实际上这种玩法可以把 N 个&#8220;子命令&#8221;串起来&#12290;<br>
<br>
<h3>&#9671;&#12304;有&#12305;条件的&#8220;批处理&#8221;</h3><br>
&#12288;&#12288;与&#8220;无条件&#8221;相对应的&#65292;当然是&#8220;有条件&#8221;啦&#12290;<br>
&#12288;&#12288;这种玩法的意思是&#8212;&#8212;后一个&#8220;子命令&#8221;是否执行&#65292;取决于&#12304;前一个&#12305;&#8220;子命令&#8221;的结果&#65288;成功 or 失败&#65289;&#12290;<br>
&#12288;&#12288;&#65288;注&#65306;如何界定&#8220;成功/失败&#8221;&#65292;请参见前面某个章节聊到的&#12304;进程退出码&#12305;&#65289;<br>
&#12288;&#12288;&#12304;有&#12305;条件的批处理&#65292;常见的方式有两种&#65292;分别是&#12304;逻辑与&#12305;&#12289;&#12304;逻辑或&#12305;&#12290;<br>
<br>
&#12288;&#12288;<b>逻辑与&#65288;语法&#65306;<code>&amp;&amp;</code>&#65289;</b><br>
&#12288;&#12288;只要前面的某个&#8220;子命令&#8221;&#12304;失败&#12305;了&#65292;就&#12304;不再&#12305;执行后续的&#8220;子命令&#8221;&#12290;<br>
&#12288;&#12288;举例&#65306;<br>
&#12288;&#12288;还是拿前一个小节的例子&#12290;如下方式使用了&#8220;逻辑与&#8221;&#12290;如果创建子目录失败&#65292;就&#12304;不再&#12305;执行&#8220;移动文件&#8221;的操作<br>
<pre class="shell" style="background-color:Black;color:LawnGreen;">mkdir ./xxx/ &amp;&amp; mv abc.txt ./xxx/
</pre><br>
&#12288;&#12288;<b>逻辑或&#65288;语法&#65306;<code>||</code>&#65289;</b><br>
&#12288;&#12288;只要前面的某个&#8220;子命令&#8221;&#12304;成功&#12305;了&#65292;就&#12304;不再&#12305;执行后续的&#8220;子命令&#8221;&#12290;<br>
&#12288;&#12288;举例&#65306;<br>
&#12288;&#12288;把上述例子进一步扩充&#65292;变为如下&#65306;<br>
<pre class="shell" style="background-color:Black;color:LawnGreen;">mkdir ./xxx/ &amp;&amp; mv abc.txt ./xxx/ || echo "FAILED!!!"
</pre><br>
&#12288;&#12288;这个有点复杂&#65292;俺稍微解释一下&#65306;<br>
&#12288;&#12288;你把前面两句看作一个&#12304;整体&#12305;&#12290;其执行的逻辑参见前面所说的&#8220;逻辑与&#8221;&#12290;然后这个&#8220;整体&#8221;与后面的那句 <code>echo</code> 再组合成&#12304;逻辑或&#12305;的关系&#12290;<br>
&#12288;&#12288;也就是说&#65292;如果前面的&#8220;整体&#8221;成功了&#65292;那么就&#12304;不&#12305;执行 <code>echo</code>&#65288;&#12304;不&#12305;打印错误信息&#65289;&#65307;反之&#65292;如果前面的&#8220;整体&#8221;失败了&#65292;就会打印错误信息&#12290;<br>
<br>
<br>
<h2>&#9733;shell 脚本</h2><br>
&#12288;&#12288;虽然前一个章节拿 bash 来举例&#12290;但其实有很多其它类型的 shell 都支持类似的&#8220;批处理&#8221;机制&#12290;<br>
&#12288;&#12288;只要某个 shell 支持刚才所说的&#12304;有条件批处理&#12305;的机制&#65292;它就已经很接近&#12304;编程语言&#12305;了&#12290;<br>
&#12288;&#12288;于是很自然地&#65292;那些 shell 的作者就会把 shell 逐步发展成某种&#12304;脚本语言&#12305;的解释器&#12290;然后就有了如今的&#8220;shell script&#8221;&#65288;shell 脚本&#65289;和&#8220;shell 编程&#8221;&#12290;<br>
&#12288;&#12288;由于&#8220;shell 编程&#8221;这个话题比较大&#12290;哪怕俺只聊 bash 这一类 shell 的编程&#65292;也足够写上几万字的博文&#12290;考虑到本文已经很长了&#65292;这个话题就不再展开&#12290;<br>
&#12288;&#12288;对此感兴趣的同学&#65292;可以参考俺分享的电子书&#12290;具体参见<a href="https://github.com/programthink/books" target="_blank">电子书清单</a>的如下几本&#65288;这几本都位于&#12304;IT类 / 操作系统 / 使用教程&#12305;分类目录下&#65289;<br>
&#12298;<a href="https://docs.google.com/document/d/1Zw8XD56F6rCi899UxIE-0sKoXWr2WGqiUNcRl70kIYk/" target="_blank">Shell 脚本学习指南</a>&#12299;&#65288;Classic Shell Scripting&#65289;<br>
&#12298;<a href="https://docs.google.com/document/d/1Nk83xAbRUdcgqUBSfDCwozA3-EUFeBz-nrpf1G7x-j0/" target="_blank">Linux 与 UNIX Shell 编程指南</a>&#12299;&#65288;Linux and UNIX Shell Programming&#65289;<br>
&#12298;<a href="https://docs.google.com/document/d/1BYSgrSViVZyDTQcuhWEFAc_uc0YZvkIoQYLmv0yWo_A/" target="_blank">高级 Bash 脚本编程指南</a>&#12299;&#65288;Advanced Bash-Scripting Guide&#65289;<br>
&#12288;&#12288;上述这几本&#65292;都属于俺在&#12298;<a href="../../2019/10/Systematic-Learning.html">如何&#12304;系统性学习&#12305;&#8212;&#8212;从&#8220;媒介形态&#8221;聊到&#8220;DIKW 模型&#8221;</a>&#12299;中提到的&#12304;入门性读物&#12305;&#12290;最后一本书的名称中虽然有&#8220;高级&#8221;字样&#65292;不过别怕&#8212;&#8212;其内容的5个部分&#65292;有4部分都是在讲基础的东西&#65292;只有最后一部分才稍微有一点点深度&#12290;<br>
<br>
<br>
<h2>&#9733;结尾</h2><br>
&#12288;&#12288;由于这篇涉及的内容比较杂&#65292;跨度也比较大&#12290;可能会有一些俺没覆盖到的地方&#12290;欢迎在博客留言中补充&#12290;<br>
&#12288;&#12288;如果你发现本文的错误之处&#65292;也欢迎批评指正 :)<br>
<br>
<br>
<b>俺博客上&#65292;和本文相关的帖子&#65288;需翻墙&#65289;</b>&#65306;<br>
&#12298;<a href="../../2013/10/linux-newbie-guide.html">扫盲 Linux&#65306;新手如何搞定 Linux 操作系统</a>&#12299;<br>
&#12298;<a href="../../2013/10/linux-distributions-guide.html">扫盲 Linux&#65306;如何选择发行版</a>&#12299;<br>
&#12298;<a href="../../2019/09/Netcat-Tricks.html">扫盲 netcat&#65288;网猫&#65289;的 N 种用法&#8212;&#8212;从&#8220;网络诊断&#8221;到&#8220;系统入侵&#8221;</a>&#12299;<br>
&#12298;<a href="../../2013/01/cross-host-use-gfw-tool.html">多台电脑如何&#12304;共享&#12305;翻墙通道&#8212;&#8212;兼谈&#12304;端口转发&#12305;的几种方法</a>&#12299;<br>
&#12298;<a href="../../2019/04/Proxy-Tricks.html">如何让&#12304;不支持&#12305;代理的网络软件&#65292;通过代理进行联网&#65288;不同平台的 N 种方法&#65289;</a>&#12299;<br>
&#12298;<a href="../../2012/10/system-vm-0.html">扫盲操作系统虚拟机</a>&#12299;&#65288;系列&#65289;<br>
&#12298;<a href="../../2019/10/Systematic-Learning.html">如何&#12304;系统性学习&#12305;&#8212;&#8212;从&#8220;媒介形态&#8221;聊到&#8220;DIKW 模型&#8221;</a>&#12299;
<div class='post-copyright'>
<b>版权声明</b><br>本博客所有的原创文章&#65292;作者皆保留版权&#12290;转载必须包含本声明&#65292;保持本文完整&#65292;并以超链接形式注明作者<a href='mailto:program.think@gmail.com'>编程随想</a>和本文原始地址&#65306;<br>
<a href="../../2019/11/POSIX-TUI-from-TTY-to-Shell-Programming.html" id="OriginalPostUrl">https://program-think.blogspot.com/2019/11/POSIX-TUI-from-TTY-to-Shell-Programming.html</a>
</div>
<div style='clear: both;'></div>

          </div>

          <div>
            <hr style="margin-left: 30px;">
          </div>

          <div class="comments" id="comments" init_num="301">
            <a name="comments"></a>
            <h4 id="comments-label"></h4>
            <div id="comments-toolbar"></div>
            <div id="comments-warning">
              <noscript>
                由于你的浏览器【禁用了】JavaScript 脚本，所以无法发布新的评论 :(

                <br>另外，本文的评论数超过200，缺乏 JS 脚本支持，只能显示前面的200条 :(
              </noscript>
            </div>
            <div id="comments-loading"></div>
            <div id="comments-content">
              <div id="comment-holder">
              </div>
            </div>
            <p class="comment-footer">
            </p>
            <div class="comment-form">
              <a name="comment-form"></a>
              <p>
              </p>
              <a href="https://www.blogger.com/comment/frame/309067092108702669?postID=309067092108702669&amp;hl=zh-CN"
                id="comment-editor-src"></a>
            </div>
            <p></p>
            <div id="backlinks-container">
              <div id="Blog1_backlinks-container">
              </div>
            </div>
          </div>
        </div>

      </div>

      <script src="../../scripts/slogan.js"></script>
      <script src="../../scripts/pako.es5.min.js"></script>
      <script src="../../comments/309067092108702669.js"></script>
      <script src="../../scripts/comments.js"></script>

      <div id="sidebar-wrapper">
        <div class="sidebar section" id="sidebar">

          <div class="widget HTML" id="BlogAbout">
            <div class="widget-content">
              <img src="../../images/thinker.jpg" alt="编程随想的Logo" title="编程随想的Logo"><br>
              <br>
              <img src="../../images/favicon/blogspot.ico" height="16" width="16" />
              <a href="https://program-think.blogspot.com/" target="_blank">博客主站点 (BlogSpot)</a><br>
              <img src="../../images/favicon/gmail.ico" height="16" width="16" />
              <a href="mailto:program.think@gmail.com" target="_blank">俺的邮箱 (Gmail)</a><br>
              <img src="../../images/favicon/github.ico" height="16" width="16" />
              <a href="https://github.com/programthink" target="_blank">俺的收藏 (GitHub)</a><br>
              <img src="../../images/favicon/twitter.ico" height="16" width="16" />
              <a href="https://twitter.com/programthink" target="_blank">俺的推特 (@programthink)</a><br>
            </div>
          </div>

          <div class="widget HTML" id="BlogFeed">
            <h2 class="title">订阅博客</h2>
            <div class="widget-content">
              <a href="https://feeds2.feedburner.com/programthink" target="_blank" title="RSS 订阅">
                <img src="../../images/feed-icon-animated.gif" alt="RSS 订阅" border="0"></a>　　　
              <a href="2013/06/email-subscription.html" title="邮件订阅">
                <img src="../../images/email-icon.png" alt="邮件订阅" border="0"></a><br>
            </div>
          </div>

          <div class="widget Text" id="BlogDesc">
            <h2 class="title">博客主要内容</h2>
            <div class="widget-content">
              ★提升思维能力<br>
              ★普及政治常识<br>
              ★扫盲翻墙姿势<br>
              ★揭露党国嘴脸<br>
              ★网络安全教程<br>
              ★软件开发技术
            </div>
          </div>

          <div class="widget Label" id="BlogTags">
            <h2>分类标签</h2>
            <div class="widget-content list-label-widget-content">
              <ul>
                <li><a href="../../tags/IT.html" class="tag">IT</a> (208)</li>
                <li><a href="../../tags/IT.Linux.html" class="tag">IT.Linux</a> (6)</li>
                <li><a href="../../tags/IT.E4B89AE7958CE8AF84E8AEBA.html" class="tag">IT.业界评论</a> (16)</li>
                <li><a href="../../tags/IT.E4BABAE5B7A5E699BAE883BD.html" class="tag">IT.人工智能</a> (3)</li>
                <li><a href="../../tags/IT.E4BFA1E681AFE5AE89E585A8.html" class="tag">IT.信息安全</a> (100)</li>
                <li><a href="../../tags/IT.E7BD91E7BB9C.html" class="tag">IT.网络</a> (22)</li>
                <li><a href="../../tags/IT.E7BFBBE5A299.html" class="tag">IT.翻墙</a> (50)</li>
                <li><a href="../../tags/IT.E8BDAFE4BBB6E4BB8BE7BB8D.html" class="tag">IT.软件介绍</a> (50)</li>
                <li><a href="../../tags/E4B9A6E8AF842FE5BDB1E8AF84.html" class="tag">书评/影评</a> (56)</li>
                <li><a href="../../tags/E5869BE4BA8B.html" class="tag">军事</a> (17)</li>
                <li><a href="../../tags/E58D9AE5AEA2E9809AE5918A.html" class="tag">博客通告</a> (34)</li>
                <li><a href="../../tags/E58E86E58FB2.html" class="tag">历史</a> (85)</li>
                <li><a href="../../tags/E5A496E4BAA4.html" class="tag">外交</a> (26)</li>
                <li><a href="../../tags/E5ADA6E4B9A0E696B9E6B395.html" class="tag">学习方法</a> (14)</li>
                <li><a href="../../tags/E5ADA6E4BC9AE6809DE88083.html" class="tag">学会思考</a> (24)</li>
                <li><a href="../../tags/E5BF83E79086E5ADA6.html" class="tag">心理学</a> (31)</li>
                <li><a href="../../tags/E694BFE6B2BB.html" class="tag">政治</a> (281)</li>
                <li><a href="../../tags/E694BFE6B2BB.E585ABE58DA6.html" class="tag">政治.八卦</a> (19)</li>
                <li><a href="../../tags/E694BFE6B2BB.E585B1E4BAA7E8BF90E58AA8.html" class="tag">政治.共产运动</a> (12)</li>
                <li><a href="../../tags/E694BFE6B2BB.E5B8B8E8AF86.html" class="tag">政治.常识</a> (22)</li>
                <li><a href="../../tags/E694BFE6B2BB.E69D83E8B4B5.html" class="tag">政治.权贵</a> (27)</li>
                <li><a href="../../tags/E694BFE6B2BB.E6B395E588B6.html" class="tag">政治.法制</a> (22)</li>
                <li><a href="../../tags/E694BFE6B2BB.E79C9FE79086E983A8.html" class="tag">政治.真理部</a> (37)</li>
                <li><a href="../../tags/E694BFE6B2BB.E88590E8B4A5.html" class="tag">政治.腐败</a> (26)</li>
                <li><a href="../../tags/E69599E882B2.html" class="tag">教育</a> (9)</li>
                <li><a href="../../tags/E697B6E4BA8BE8AF84E8AEBA.html" class="tag">时事评论</a> (176)</li>
                <li><a href="../../tags/E78EAFE4BF9D.html" class="tag">环保</a> (13)</li>
                <li><a href="../../tags/E7A791E699AE.html" class="tag">科普</a> (8)</li>
                <li><a href="../../tags/E7AEA1E79086.html" class="tag">管理</a> (16)</li>
                <li><a href="../../tags/E7BB8FE6B58E.html" class="tag">经济</a> (44)</li>
                <li><a href="../../tags/E7BC96E7A88B.html" class="tag">编程</a> (69)</li>
                <li><a href="../../tags/E7BC96E7A88B.C.html" class="tag">编程.C</a> (15)</li>
                <li><a href="../../tags/E7BC96E7A88B.Java.html" class="tag">编程.Java</a> (12)</li>
                <li><a href="../../tags/E7BC96E7A88B.Python.html" class="tag">编程.Python</a> (8)</li>
                <li><a href="../../tags/E7BC96E7A88B.E5A49AE7BABFE7A88B.html" class="tag">编程.多线程</a> (6)</li>
                <li><a href="../../tags/E7BC96E7A88B.E5BC80E6BA90E9A1B9E79BAE.html" class="tag">编程.开源项目</a> (10)</li>
                <li><a href="../../tags/E7BC96E7A88B.E680A7E883BDE4BC98E58C96.html" class="tag">编程.性能优化</a> (6)</li>
                <li><a href="../../tags/E7BC96E7A88B.E69EB6E69E84.html" class="tag">编程.架构</a> (7)</li>
                <li><a href="../../tags/E7BC96E7A88B.E7AE97E6B395.html" class="tag">编程.算法</a> (3)</li>
                <li><a href="../../tags/E7BC96E7A88B.E8BDAFE4BBB6E5B7A5E7A88B.html" class="tag">编程.软件工程</a> (13)</li>
                <li><a href="../../tags/E8818CE59CBAE782B9E6BBB4.html" class="tag">职场点滴</a> (22)</li>
                <li><a href="../../tags/E8BDACE8BDBD.html" class="tag">转载</a> (153)</li>
              </ul>
            </div>
          </div>

          <div class="widget Label" id="BlogRecommend">
            <div class="widget-content">
              <h2>推荐帖子（翻墙技术）</h2>
              <ul>
                <li><a href='../../2009/05/how-to-break-through-gfw.html'>如何翻墙（全方位入门扫盲）</a></li>
                <li><a href='../../2011/09/gfw-faq.html'>常见翻墙问题答疑</a></li>
                <li><a href='../../2011/03/how-to-get-gfw-tools.html'>获取翻墙软件方法大全</a></li>
                <li><a href='../../2013/01/cross-host-use-gfw-tool.html'>多台电脑如何共享翻墙通道</a></li>
                <li><a href='../../2013/11/tor-faq.html'>关于 Tor 的常见问题解答</a></li>
                <li><a href='../../2009/07/break-through-berlin-wall.html'>学习一下德国人民的翻墙精神</a></li>
              </ul>
              <h2>推荐帖子（信息安全）</h2>
              <ul>
                <li><a href='../../2021/03/Computer-Networks-Overview.html'>计算机网络通讯的【系统性】扫盲——从“基本概念”到“OSI 模型”</a></li>
                <li><a href='../../2019/01/Security-Guide-for-Political-Activists.html'>为啥朝廷总抓不到俺——十年反党活动的安全经验汇总</a>
                </li>
                <li><a href='../../2015/08/Technology-and-Freedom.html'>“对抗专制、捍卫自由”的 N 种技术力量</a></li>
                <li><a href='../../2010/06/howto-prevent-hacker-attack-0.html'>如何防止黑客入侵（系列）</a></li>
                <li><a href='../../2013/06/privacy-protection-0.html'>如何保护隐私（系列）</a></li>
                <li><a href='../../2010/04/howto-cover-your-tracks-0.html'>如何隐藏你的踪迹，避免跨省追捕（系列）</a></li>
                <li><a href='../../2012/10/system-vm-0.html'>扫盲操作系统虚拟机 (系列)</a></li>
                <li><a href='../../2015/10/VeraCrypt.html'>扫盲 VeraCrypt——跨平台的 TrueCrypt 替代品</a></li>
                <li><a href='../../2011/05/recommend-truecrypt.html#index'>TrueCrypt 的扫盲教程和高级教程（VeraCrypt 也适用）</a></li>
                <li><a href='../../2011/05/file-encryption-overview.html'>文件加密的扫盲介绍</a></li>
                <li><a href='../../2013/07/online-backup-virtual-encrypted-disk.html'>文件备份技巧：组合“虚拟加密盘”与“网盘”</a></li>
                <li><a href='../../2013/02/file-integrity-check.html'>扫盲文件完整性校验——关于散列值和数字签名</a></li>
                <li><a href='../../2009/05/social-engineering-0-overview.html'>扫盲“社会工程学”（系列）</a></li>
              </ul>
              <h2>推荐帖子（提升个人能力）</h2>
              <ul>
                <li><a href='../../2020/12/Study-and-Life.html'>学习与人生——700篇博文之感悟</a></li>
                <li><a href='../../2019/10/Systematic-Learning.html'>如何【系统性学习】——从“媒介形态”聊到“DIKW 模型”</a></li>
                <li><a href='../../2013/09/knowledge-structure.html'>如何完善自己的知识结构</a></li>
                <li><a href='../../2013/04/how-to-read-book.html'>《如何阅读一本书》——书评及内容纲要</a></li>
                <li><a href='../../2015/12/Hobbies-and-Interests.html'>什么是【真正的】兴趣爱好？以及它有啥好处？</a></li>
                <li><a href='../../2009/02/study-technology-in-three-steps.html'>学习技术的三部曲：WHAT、HOW、WHY</a></li>
                <li><a href='../../2012/03/think-what-how-why.html'>用提问促进思维——再谈 WHAT HOW WHY 三部曲</a></li>
                <li><a href='../../2015/06/The-Mythical-Theories-of-Success.html'>成功学批判——简述其危害性及各种谬误</a></li>
                <li><a
                    href='../../2018/12/Book-Review-Antifragile-Things-That-Gain-from-Disorder.html'>读书笔记：《反脆弱——从不确定性中获益》</a>
                </li>
                <li><a href='../../2009/07/book-review-are-your-lights-on.html'>书评：《你的灯亮着吗？——找到问题的真正所在》</a></li>
              </ul>
              <h2>推荐帖子（洗脑与反洗脑）</h2>
              <ul>
                <li><a href='../../2014/02/brainwash-and-idiot.html'>聊聊洗脑和脑残——分析“脑残的起源”和“脑残的觉醒”</a></li>
                <li><a href='../../2013/05/difference-between-fact-and-opinion.html'>批判性思维扫盲——学会区分“事实”与“观点”</a></li>
                <li><a href='../../2011/03/logical-fallacies.html'>扫盲逻辑谬误——以五毛言论为反面教材</a></li>
                <li><a href='../../2014/12/brainwash-using-real-data.html'>比“欺骗”更狡猾的洗脑——基于【真实数据】进行忽悠</a></li>
                <li><a href='../../2014/01/doublethink.html'>比“欺骗”更有效的洗脑——基于【双重思想】的思维控制</a></li>
                <li><a href='../../2014/01/anti-brainwashing-and-enlightenment.html'>如何用互联网进行“反洗脑”和“政治启蒙”</a></li>
                <li><a href='../../2010/10/book-review-asking-right-questions.html'>书评：《学会提问——批判性思维指南》</a></li>
              </ul>
              <h2>推荐帖子（心理学）</h2>
              <ul>
                <li><a href='../../2019/03/Why-Thinking-Hard-So-Hard.html'>为什么独立思考这么难——谈谈心理学的成因，并分享俺的经验</a></li>
                <li><a href='../../2014/05/fans-and-idolatry.html'>不要成为“粉丝”——谈谈“偶像崇拜”的成因和危害</a></li>
                <li><a href='../../2012/12/emperor-complex.html'>天朝民众的心理分析：圣君情结</a></li>
                <li><a href='../../2012/06/stockholm-syndrome.html'>天朝民众的心理分析：斯德哥尔摩综合症</a></li>
                <li><a href='../../2014/09/oversimplification.html'>各种【一元化思维】的谬误——从“星座理论”到“共产主义社会”</a></li>
                <li><a href='../../2015/05/Survivorship-Bias.html'>思维的误区：幸存者偏见——顺便推荐巴菲特最著名的演讲</a></li>
                <li><a href='../../2014/06/sunk-cost-fallacy-and-loss-aversion.html'>思维的误区：从“沉没成本谬误”到“损失厌恶情结”</a></li>
                <li><a href='../../2010/02/about-mental-model.html'>认识你自己——有关心智模式的扫盲介绍</a></li>
                <li><a href='../../2010/04/how-to-attribute-success-failure.html'>你是如何看待【成败】的？——兼谈【有效归因】</a></li>
                <li><a href='../../2012/01/stockdale-paradox.html'>如何面对【逆境】？——兼谈“斯托克戴尔悖论”</a></li>
                <li><a href='../../2012/06/book-review-road-less-traveled.html'>书评：《少有人走的路——心智成熟的旅程》</a></li>
                <li><a href='../../2009/05/halo-effect.html'>光环效应引发的认知误区</a></li>
              </ul>
              <h2>推荐帖子（政治）</h2>
              <ul>
                <li><a
                    href='../../2018/09/Book-Review-The-Errors-of-Marxism-Leninism.html'>为什么马克思是错的——全面批判马列主义的知名著作导读</a>
                </li>
                <li><a href='../../2020/04/Government-and-System-Robustness.html'>“政治体制”与“系统健壮性”——基于“复杂性科学”的思考</a></li>
                <li><a href='../../2011/06/june-fourth-incident-0.html'>回顾“六四”（系列）</a></li>
                <li><a href='../../2011/12/revolution-0.html'>谈革命（系列）</a></li>
                <li><a href='../../2018/07/Forty-Years-of-China-USA-Relations.html'>从量变到质变——中美关系40年</a></li>
                <li><a href='../../2018/08/USA-Containment-Strategies-in-Cold-War.html'>苏联是如何被慢慢勒死的？——聊聊冷战中美国的遏制战略</a>
                </li>
                <li><a href='../../2015/01/Communism-Nazism-Caesaropapism.html'>人类自由的三大死敌——谈谈“共产运动、纳粹主义、政教合一”的共性</a>
                </li>
                <li><a
                    href='../../2013/12/political-concepts-state-citizenship-etc.html'>政治常识扫盲：理清“国家、政体、公民、政府、政党”等概念</a>
                </li>
                <li><a href='../../2014/02/freedom-of-speech.html'>政治常识扫盲：澄清“言论自由”的各种误区</a></li>
                <li><a href='../../2012/07/form-of-government.html'>扫盲常见的政治体制</a></li>
                <li><a href='../../2016/06/USA-Separation-of-Powers-with-Balances.html'>聊聊美国政体中的权力制衡——不仅仅是三权分立</a></li>
                <li><a href='../../2016/11/USA-Elections.html'>美国选举制度为啥这样设计？——兼谈其历史演变</a></li>
                <li><a href='../../2010/11/institutionalize.html'>谈谈体制化，并推荐《肖申克的救赎》</a></li>
                <li><a href='../../2013/04/more-supervision-less-thankfulness.html'>对政府——多些“监督问责”，少些“煽情感动”</a></li>
                <li><a href='../../2012/03/national-people-congress.html'>看看全国人大代表都是啥货色——兼谈“议会道路的改良”行不通</a></li>
                <li><a href='../../2012/10/history-of-red-khmers.html'>最“纯正”的共产主义政权——红色高棉简史</a></li>
              </ul>
              <h2>推荐帖子（历史）</h2>
              <ul>
                <li><a href='../../2019/11/Brief-History-of-the-Berlin-Wall.html'>美苏冷战的缩影——柏林墙简史</a></li>
                <li><a href='../../2014/07/artists-and-ccp.html'>面对共产党——民国人文大师的众生相</a></li>
                <li><a href='../../2012/05/three-years-famine-0.html'>谈谈三年大饥荒（系列）</a></li>
                <li><a href='../../2016/01/Taiwan-Political-Movements.html'>台湾民主运动与独立运动简史</a></li>
                <li><a href='../../2010/09/censorship-of-images.html'>看看真理部是如何 PS 照片的</a></li>
                <li><a href='../../2013/08/korean-war.html'>谈谈真理部对朝鲜战争的忽悠</a></li>
                <li><a href='../../2010/09/sino-japanese-war.html'>谈谈真理部对抗战历史的篡改</a></li>
                <li><a href='../../2014/04/history-china-fallen-behind-europe.html'>中国是从哪个朝代开始落后于西方？</a></li>
                <li><a href='../../2011/03/ccp-vs-japanese.html'>谁是最可恨的人？——写给仇日愤青们</a></li>
                <li><a href='../../2015/11/Why-Islam-Is-Different-from-Other-Religions.html'>伊斯兰教为何如此奇葩？</a></li>
                <li><a href='../../2015/01/Islamic-Extremism.html'>伊斯兰教极端主义溯源</a></li>
              </ul>
              <h2>推荐帖子（编程技术）</h2>
              <ul>
                <li><a href='../../2012/05/weekly-share-5.html'>学习编程语言的3篇好文章</a></li>
                <li><a href='../../2009/08/why-choose-python-0-overview.html'>为什么俺推荐 Python（系列）</a></li>
                <li><a href='../../2009/03/producer-consumer-pattern-0-overview.html'>架构设计：生产者/消费者模式</a></li>
                <li><a href='../../2009/02/multi-process-vs-multi-thread.html'>架构设计：进程还是线程？</a></li>
                <li><a href='../../2009/02/how-to-choose-opensource-project.html'>如何选择开源项目？</a></li>
                <li><a href='../../2009/02/cxx-object-destroy-overview.html'>C++ 对象是怎么死的？（系列）</a></li>
                <li><a href='../../2009/01/cxx-cross-platform-develop-0-overview.html'>C++ 的移植性和跨平台开发（系列）</a></li>
                <li><a href='../../2009/03/java-performance-tuning-0-overview.html'>Java 性能优化（系列）</a></li>
                <li><a href='../../2009/01/defect-of-java-beginner-0-overview.html'>Java 新手的通病（系列）</a></li>
              </ul>
              <h2>推荐帖子（职场与管理）</h2>
              <ul>
                <li><a href='../../2019/12/Time-and-Life.html'>时间与人生——跨入本世纪20年代的随想</a></li>
                <li><a href='../../2018/06/weekly-share-121.html'>德鲁克谈【自我管理】——《哈佛商业评论》最受欢迎的文章</a></li>
                <li><a href='../../2011/03/hiring-experience-0.html'>俺的招聘经验（系列）</a></li>
                <li><a href='../../2009/04/defect-of-hire.html'>招聘的误区</a></li>
                <li><a href='../../2016/04/Andy-Grove-Quotes-on-Leadership.html'>硅谷 CEO 们的教父——分享安迪·格鲁夫的管理经验</a></li>
                <li><a href='../../2009/01/0.html'>如何成为优秀开发人员（系列）</a></li>
              </ul>

            </div>
          </div>

          <div class="widget HTML" id="BlogSearch">
            <h2 class="title">博客站内搜索 (需联网)</h2>
            <div class="widget-content">
              <img src="../../images/search/google.png" alt="Google" border="0"><br>
              <form method="GET" action="https://encrypted.google.com/search" target="_blank">
                <input name="ie" value="UTF-8" type="hidden">
                <input name="oe" value="UTF-8" type="hidden">
                <input name="sitesearch" value="program-think.blogspot.com" type="hidden">
                <input name="q" size="32" maxlength="128" type="text">
                <input name="search" value="Google" type="submit">
              </form>
              <br>
              <img src="../../images/search/bing.png" alt="Bing" border="0"><br>
              <form method="GET" action="http://www.bing.com/search" target="_blank">
                <input name="q1" value="site:program-think.blogspot.com" type="hidden">
                <input name="q" size="32" maxlength="128" type="text">
                <input name="search" value="Bing" type="submit">
              </form>
            </div>
          </div>

          <div class="widget BlogArchive" id="BlogArchive">
            <h2>历史归档</h2>
            <div class="widget-content">
              <ul>
                <li><a href="../../archive/2021.html">2021</a> (10)</li>
                <li><a href="../../archive/2020.html">2020</a> (28)</li>
                <li><a href="../../archive/2019.html">2019</a> (39)</li>
                <li><a href="../../archive/2018.html">2018</a> (31)</li>
                <li><a href="../../archive/2017.html">2017</a> (34)</li>
                <li><a href="../../archive/2016.html">2016</a> (37)</li>
                <li><a href="../../archive/2015.html">2015</a> (61)</li>
                <li><a href="../../archive/2014.html">2014</a> (76)</li>
                <li><a href="../../archive/2013.html">2013</a> (96)</li>
                <li><a href="../../archive/2012.html">2012</a> (109)</li>
                <li><a href="../../archive/2011.html">2011</a> (58)</li>
                <li><a href="../../archive/2010.html">2010</a> (40)</li>
                <li><a href="../../archive/2009.html">2009</a> (93)</li>
              </ul>
            </div>
          </div>

        </div> <!--sidebar-->
      </div> <!--sidebar-wrapper-->

    </div> <!-- end content-wrapper -->
  </div> <!-- end outer-wrapper -->
</body>
<script>
jQuery(function($)
{
  function initArticleInnerLinks()
  {
    if($(".post h2").length == 0)
    {
      $(".post-inner-index").hide();
      return;
    }

    $(".post-inner-index").css("padding-bottom", "2em")
        .append("<div><b style='font-size:120%;'>文章目录</b></div>");

    $(".post h2").each(
      function(nIndex)
      {
        var sHash = "head-"+(nIndex+1);
        $(this).before("<a name='"+sHash+"'> </a>");
        var sTitle = $(this).html().replace(/<.+?>|/g, "");
        $(".post-inner-index").append("<a href='#"+sHash+"'>"+sTitle+"</a><br/>");
      }
    );
  }

  $(document).ready(
    function()
    {
      try
      {
        initArticleInnerLinks();
        $(document).tooltip({
          content: Tooltip.content,
          open: function(event, ui) { Tooltip.open(event, ui, 3000); }
        });
      }
      catch(err)
      {
        reportError("init: Catch exception:\n" + err);
      }
    }
  );
});
</script>
</html>