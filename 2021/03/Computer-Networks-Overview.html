<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="Python script by program.think@gmail.com" />
  <meta name="provider" content="program-think.blogspot.com" />
  <script src="../../scripts/jquery.min.js" type="text/javascript"></script>
  <script src="../../scripts/jquery-ui.min.js" type="text/javascript"></script>
  <link href="../../scripts/jquery-ui.min.css" rel="stylesheet" />
  <script type="text/javascript">window.rootNavigator = '../../' </script>
  <script src="../../scripts/base.js" type="text/javascript"></script>
  <link type="text/css" rel="stylesheet" href="../../css/program-think.css" />
  <link rel="icon" type="image/x-icon" href="../../images/favicon/blogspot.ico">
  <title>计算机网络通讯的&#12304;系统性&#12305;扫盲&#8212;&#8212;从&#8220;基本概念&#8221;到&#8220;OSI 模型&#8221; - 编程随想的博客</title>
</head>

<body>
  <div id="outer-wrapper">
    <div id="content-wrapper">
      <div id="main" style="width:67%;">
        <div class="widget Header" data-version="1" id="Header1">
          <div id="header-inner">
            <div class="titlewrapper">
              <h1 class="title">
                <a href="../../index.html">
                  编程随想的博客
                </a>
              </h1>
            </div>
            <div class="descriptionwrapper">
              <p class="description"></p>
              <hr>
            </div>
          </div>
        </div>

        <div class="post-content">
          <div class="post-toolbar">
            <div class="post-toolbar-1">
            </div>
            <div class="post-toolbar-2">
              <span class="post-timestamp" data="2021-03-18T21:15:00+08:00">2021年3月18日</span>
              <span class="post-comment-link">
                <a class="comment-link" href="#comments">评论数：499条</a>
              </span>
              <span class="post-labels">
                标签：
                <a href="../../tags/IT.E7BFBBE5A299.html" class="tag">IT.翻墙</a>  <a href="../../tags/IT.E7BD91E7BB9C.html" class="tag">IT.网络</a>  <a href="../../tags/IT.E4BFA1E681AFE5AE89E585A8.html" class="tag">IT.信息安全</a>  
              </span>
            </div>
          </div>

          <div>
            <h1 class="post-title entry-title">
              <a href="https://program-think.blogspot.com/" title="点击跳转到原文(Blogspot)地址">
              计算机网络通讯的&#12304;系统性&#12305;扫盲&#8212;&#8212;从&#8220;基本概念&#8221;到&#8220;OSI 模型&#8221;
              </a>
            </h1>

            <div class='post-header'>
              <div class='post-header-line-1'>
              <div class='post-inner-index'></div>
              </div>
            </div>
          </div>

          <div class="post">
            
&#12288;&#12288;近期老是在写政治博文&#65292;又有两个月左右没写技术博文了&#12290;某些技术型的读者&#65292;背地里肯定骂俺太懒&#12290;今天搞了一篇内容特别长&#65292;信息量特别多的&#12290;喜欢看技术博文的读者&#65292;可以慢慢消化&#12290;<br>
<br>
<h2>&#9733;本文的目标读者</h2>
<br>
&#12288;&#12288;今天这篇的标题是&#8220;扫盲&#8221;&#65292;也就是说&#65306;即使那些完全不懂 IT 领域&#65292;也不懂通讯领域的读者&#65292;依然能看懂&#65288;至少能看懂一部分&#65289;&#12290;为了做到这点&#65292;俺会尽量使用通俗的比喻&#65292;并适当加一些示意图&#12290;<br>
&#12288;&#12288;另外&#65292;就算你已经比较了解网络通讯领域&#65292;本文中提到的某些部分&#65292;也可能是你所不知道的&#12290;也就是说&#65306;懂行的同学&#65292;看看此文&#65292;也会有帮助&#12290;<br>
&#12288;&#12288;本文的标题特地强调了&#12304;系统性&#12305;&#8212;&#8212;俺希望这篇教程能帮助读者对&#8220;计算机网络&#8221;这个领域进行系统性学习&#65288;何为&#8220;系统性学习&#8221;&#65311;请看<a href="../../2019/10/Systematic-Learning.html">这篇教程</a>&#65289;<br>
&#12288;&#12288;为了做到&#12304;系统性&#12305;这个目的&#65292;这篇教程很长&#12290;俺开博12年&#65292;这篇的长度估计能排到前5名&#12290;建议大伙儿慢慢看&#65292;不要着急&#12290;<br>
<a name='more'></a><br>
<br>
<h2>&#9733;基本概念</h2>
<br>
&#12288;&#12288;为了足够通俗&#65292;俺先要介绍一些基本概念&#12290;<br>
<br>
<h3>&#9671;信道&#65288;<a href="https://en.wikipedia.org/wiki/Communication_channel" target="_blank" rel="nofollow">channel</a>&#65289;</h3>
<br>
&#12288;&#12288;这是通讯领域非常基本的概念&#65292;肯定要先聊聊它&#12290;<br>
&#12288;&#12288;通俗地说&#65292;信道就是&#8220;传送信息的通道&#8221;&#12290;<br>
<br>
<h3>&#9671;信道的类型</h3>
<br>
&#12288;&#12288;首先&#65292;信道可以从广义上分为&#8220;物理信道 &#65286; 逻辑信道&#8221;&#12290;<br>
&#12288;&#12288;顾名思义&#65292;&#8220;物理信道&#8221;就是直接使用某种&#12304;物理介质&#12305;来传送信息&#65307;至于&#8220;逻辑信道&#8221;&#8212;&#8212;是基于&#8220;物理信道&#8221;之上抽象出来的玩意儿&#65288;待会儿讲到&#8220;协议栈&#8221;的时候再聊&#65289;&#12290;<br>
<br>
<h3>&#9671;信道的带宽</h3>
<br>
&#12288;&#12288;&#8220;带宽&#8221;指的是&#65306;某个信道在单位时间内最大能传输多少比特的信息&#12290;<br>
&#12288;&#12288;请注意&#65306;<br>
&#12288;&#12288;电气领域 &#65286; 计算机领域都有&#8220;带宽&#8221;这个概念&#65292;但两者的定义不太一样&#12290;电气领域所说的&#8220;带宽&#8221;指的是&#8220;模拟带宽&#8221;&#65292;单位是&#8220;赫兹/Hz&#8221;&#65307;计算机领域所说的&#8220;带宽&#8221;指&#8220;数字带宽&#8221;&#65292;单位是&#8220;比特率&#8221;或&#8220;字节率&#8221;&#12290;<br>
&#12288;&#12288;后续章节提到&#8220;带宽&#8221;&#65292;都是指计算机领域的术语&#12290;<br>
<br>
<h3>&#9671;带宽的单位&#8212;&#8212;容易把外行绕晕</h3>
<br>
&#12288;&#12288;&#8220;比特率&#8221;或&#8220;字节率&#8221;很容易搞混淆&#12290;用英文表示的话&#8212;&#8212;大写字母 <code>B</code> 表示&#12304;字节&#12305;&#65307;小写字母 <code>b</code> 表示&#12304;比特&#12305;&#12290;<br>
<br>
&#12288;&#12288;由于带宽的数字通常很大&#65292;要引入&#8220;K&#12289;M&#12289;G&#8221;之类的字母表示数量级&#65292;于是又引出一个很扯蛋的差异&#8212;&#8212;&#8220;10进制&#8221;与&#8220;2进制&#8221;的差异&#12290;<br>
&#12288;&#12288;&#12304;10进制&#12305;的 <code>K</code> 表示 1000&#65307;<code>M</code> 表示 1000x1000&#65288;1百万&#65289;<br>
&#12288;&#12288;&#12304;2进制&#12305;的 <code>K</code> 表示 1024&#65288;2的10次方&#65289;&#65307;<code>M</code> 表示 1024x1024&#65288;2的20次方&#65289;<br>
&#12288;&#12288;为了避免扯皮&#65292;后来国际上约定了一个规矩&#65306;对&#12304;2进制&#12305;的数量级要加一个小写字母 <code>i</code>&#12290;比如说&#65306;<code>Ki</code> 表示 1024&#65307;<code>Mi</code> 表示 1024x1024 ...... 以此类推&#12290;<br>
&#12288;&#12288;举例&#65306;<br>
&#12288;&#12288;1Kbps 表示&#8220;1000比特每秒&#8221;<br>
&#12288;&#12288;1KiBps 表示&#8220;1024字节每秒&#8221;<br>
<br>
<h3>&#9671;信道的工作模式&#65306;单工 VS 半双工 VS 全双工</h3>
<br>
&#12288;&#12288;再来说说信道的工作模式&#12290;大致可以分为如下三种&#12290;为了让大伙儿比较好理解&#65292;俺对每一种都举相应的例子&#12290;<br>
<br>
&#12288;&#12288;<b>单工&#65288;simplex&#65289;</b><br>
&#12288;&#12288;比如&#8220;电台广播&#8221;就是典型的&#12304;单工&#12305;&#12290;&#8220;电台&#8221;可以发信号给&#8220;收音机&#8221;&#65292;但&#8220;收音机&#8221;&#12304;不能&#12305;发信号给&#8220;电台&#8221;&#12290;<br>
<br>
&#12288;&#12288;<b>半双工&#65288;half-duplex&#65289;</b><br>
&#12288;&#12288;比如&#8220;单条铁路轨道&#8221;&#65292;就是典型的&#12304;半双工&#12305;&#12290;火车在单条铁轨上&#65292;可以有两种运行方向&#65307;但对于同一个瞬间&#65292;只能选其中一个方向&#65288;否则就撞车了&#65289;&#12290;<br>
<br>
&#12288;&#12288;<b>全双工&#65288;full-duplex&#65289;</b><br>
&#12288;&#12288;比如&#8220;光纤&#8221;就是典型的&#12304;全双工&#12305;&#12290;在同一根光导纤维中&#65292;可以有多个光束&#12304;同时相向&#12305;传播&#65292;互相不会干扰对方&#12290;<br>
<br>
<h3>&#9671;端点</h3>
<br>
&#12288;&#12288;为了叙述方便&#65292;俺把参与通讯的对象&#65288;主体&#65289;称作&#8220;通讯端点&#8221;&#65292;简称&#8220;端点&#8221;&#12290;<br>
&#12288;&#12288;这里的&#8220;端点&#8221;是广义的&#65292;可以是硬件&#65288;比如某个网卡&#65289;&#65292;也可以是软件&#65288;比如某个应用程序&#65289;&#12290;<br>
<br>
<h3>&#9671;单播&#12289;组播/多播&#12289;广播&#12289;选播</h3>
<br>
&#12288;&#12288;对于&#8220;网络通讯&#8221;&#65292;至少得有 N 个端点参与&#65292;并且&#12304;N &#8805; 2&#12305;才有意义&#12290;<br>
&#12288;&#12288;当 N 个端点构成一个网络&#65292;这时候就会涉及到&#8220;单播&#12289;组播&#12289;广播&#8221;这几个概念&#12290;<br>
&#12288;&#12288;通俗地说&#65306;<br>
单播&#65288;unicast&#65289;&#8212;&#8212;发送给网络中的指定的&#12304;单个&#12305;端点<br>
组播/多播&#65288;multicast&#65289;&#8212;&#8212;发送给网络中的指定的&#12304;多个&#12305;端点<br>
广播&#65288;broadcast&#65289;&#8212;&#8212;发送给网络中的&#12304;所有&#12305;端点<br>
选播&#65288;anycast&#65289;&#8212;&#8212;发送给网络中随机选择的&#12304;单个&#12305;端点<br>
<br>
<h3>&#9671;通讯协议&#65288;protocol&#65289;</h3>
<br>
&#12288;&#12288;所谓的&#8220;通讯协议&#8221;就是&#65306;参与通讯的各方所采用的某种&#12304;约定&#12305;&#12290;只有大家都遵守这个约定&#65292;才有可能相互传递信息&#12290;<br>
&#12288;&#12288;打个比方&#65306;如果两个人要用自然语言交流&#65292;前提是&#65306;双方使用相同&#65288;或相互兼容&#65289;的自然语言&#12290;<br>
&#12288;&#12288;&#8220;通讯协议&#8221;就类似某种自然语言&#65292;参与通讯的多个端点&#65292;都必须能理解这个语言&#12290;<br>
<br>
<br>
<h2>&#9733;从&#8220;分层&#8221;到&#8220;参考模型&#8221;</h2>
<br>
<h3>&#9671;分层</h3>
<br>
&#12288;&#12288;在聊&#8220;分层&#8221;之前&#65292;先说说&#8220;分工&#8221;&#12290;比如在一个公司中&#65292;通常设有不同的工种/岗位&#65292;这就&#12304;分工&#12305;&#12290;<br>
&#12288;&#12288;对于网络通讯也是如此&#65292;不太可能用一种通讯协议完成所有的信息传递任务&#65288;注&#65306;对于特别简单的网络&#65292;或许有可能只用单一协议&#65307;但如今的网络通讯已经很复杂&#65292;用&#12304;单个&#12305;通讯协议包办所有事情&#65292;已经不太可能&#65289;<br>
&#12288;&#12288;一旦采用了多种通讯协议&#65292;这几种协议之间&#65292;该如何配合捏&#65311;<br>
&#12288;&#12288;在网络通讯领域&#65292;采用的是&#12304;分层&#12305;的设计思路&#12290;多个层次的协议在一起协同工作&#65292;技术上称作&#8220;协议栈&#8221;&#65288;洋文叫做&#8220;protocol stack&#8221;&#65289;&#12290;<br>
<br>
<h3>&#9671;协议栈的原理</h3>
<br>
&#12288;&#12288;对于多层次的协议栈&#12290;每个层次都有各自的&#8220;端点&#8221;&#65288;进行通讯的主体&#65289;&#12290;处于&#12304;同一层次&#12305;的两个端点会使用该层次的协议进行通讯&#65288;注&#65306;同一个层次的协议&#65292;可能只有一个&#65292;也可能有多个&#65289;&#12290;<br>
&#12288;&#12288;除了最顶层&#65292;每个层次的端点会向其&#12304;直接&#12305;上层提供&#8220;服务&#8221;&#65307;除了最底层&#65292;每个层次的端点会调用&#12304;直接&#12305;下层提供的&#8220;服务&#8221;&#65288;这里所说的&#8220;服务&#8221;指某种&#8220;编程接口&#8221;&#65292;技术行话叫 API&#65289;&#12290;<br>
<br>
<center><img src="../../images/2021/03/bK34KOVTYWmZNuIOY-0CxbJn1tR8LV_-78VflTiRK3rFM_YjVPa6lSbdxU58ICNFqTo2ghGjicgekyoZ4CNdFDe7ucMEM3BVHDA48S44mNn7e7Rf-5L3XDxYrjGDUpFp3AvkLDxb78w" alt="不见图 请翻墙"><br>
&#65288;&#8220;协议栈&#8221;的示意图&#65289;</center>
<br>
<center><img src="../../images/2021/03/qfAnnow_Fl7VudJd1GS39MJxLfXymYvKQ7ISRvYoSG4RKl8AltCB2Ru86zf78ABHd3ZrzI6sNF9Z65I9z8-He26A7hSInp-Pf2Quduw26FHGWMb2VK5YK-yLWnG8F2UibWqgzYwGSaU" alt="不见图 请翻墙"><br>
&#65288;&#8220;服务&#8221;与&#8220;协议&#8221;之间的关系&#65289;</center>
<br>
<h3>&#9671;逻辑信道</h3>
<br>
&#12288;&#12288;&#65288;前一个小节说了&#65289;每个层次会向上一个层次提供服务&#65288;API 调用&#65289;&#12290;对上层而言&#65292;调用下层提供的 API 发送信息&#65292;其效果相当于在使用某种&#12304;信道&#12305;进行通讯&#65292;这也就是俺在 <q style="background-color:#DDD;">&#9733;基本概念</q> 那个章节所说的&#8220;逻辑信道&#8221;&#12290;<br>
<br>
<center><img src="../../images/2021/03/OzflASXF1Xv5c3-eg-RiT4ENcwjZx4jpeVYlj01YI6I-1L-Wgjl3FE47Rc94Dn9JAcTnHGcEES1KcaSSjHkZQeG1iKWgamZWrMtC0QTMpbHnO7NQeZvuMIeS9Sx8pI7gNg7DlakovkY" alt="不见图 请翻墙"><br>
&#65288;&#8220;逻辑信道&#8221;示意图&#65289;</center>
<br>
<h3>&#9671;数据格式的原理</h3>
<br>
&#12288;&#12288;大部分协议会把要传送的数据切割为 N 份&#65292;每一份就是一个数据包&#12290;<br>
&#12288;&#12288;通常来说&#65292;数据包的格式有如下三部分&#65306;<br>
<blockquote style="background-color:#DDD;">
头部<br>
身体&#65288;也称作&#8220;有效载荷&#8221;&#65289;<br>
尾部&#65288;注&#65306;很多协议没有尾部&#65289;</blockquote>
&#12288;&#12288;如果你收过快递&#65292;可以把&#8220;网络数据包&#8221;与&#8220;快递包裹&#8221;作一个对照&#8212;&#8212;<br>
数据包的&#8220;头/尾&#8221;&#65292;就类似于快递包裹的&#12304;包装袋&#12305;&#12290;数据包的&#8220;身体&#8221;&#65292;就类似于快递包裹里面的东西&#12290;<br>
<br>
&#12288;&#12288;对于&#12304;相邻&#12305;两层的协议&#65292;&#12304;下&#12305;层包含&#12304;上&#12305;层&#12290;也就是说&#65306;下层协议的&#12304;载荷&#12305;就是上层协议的&#12304;整体&#12305;&#12290;<br>
&#12288;&#12288;还是以快递举例&#65306;<br>
&#12288;&#12288;假设你从网上买了一台笔记本电脑&#12290;电脑出厂时&#65292;电脑厂商肯定会提供一个包装盒&#12290;快递公司在寄送这台笔记本的时候&#65292;又会在笔记本的盒子外面再加一个包装袋&#12290;对应到网络协议&#8212;&#8212;&#8220;快递公司的包装袋&#8221;相当于&#12304;下层&#12305;协议&#65307;&#8220;电脑厂商的包装盒&#8221;&#65292;相当于&#12304;上层&#12305;协议&#12290;<br>
<br>
<center><img src="../../images/2021/03/bz_Gg8ow_9ZM4dqw9wEfGaEXZmpusHPT9pwhILsvusYq6XPZa__M5GsfF07xCnoAV-S2udQ0unbuAbUgWqx9vCgF71t7RgQhsgkNL6Ol76wueKdvWU-nukPat8i7VlVFXs2FDrthrt0" alt="不见图 请翻墙"><br>
&#65288;上下层协议的格式及包含关系&#65289;</center>
<br>
<h3>&#9671;网络分层的参考模型</h3>
<br>
&#12288;&#12288;上述所说的&#8220;分层 &#65286; 协议栈&#8221;只是一个抽象的&#65288;笼统的&#65289;思路&#12290;具体要分几层&#65311;每一层要干啥事儿&#65311;这些都是很有讲究滴&#65281;网络技术发展了几十年&#65292;已经有很多牛人提出了各种不同的划分方案&#65292;称之为&#8220;网络分层的参考模型&#8221;&#65288;为了打字省力&#65292;以下简称&#8220;模型&#8221;&#65289;&#12290;<br>
&#12288;&#12288;在各种模型中&#65292;名气最大的当然是&#8220;OSI 模型&#8221;&#65288;洋文称作&#8220;<a href="https://en.wikipedia.org/wiki/OSI_model" target="_blank" rel="nofollow">OSI model</a>&#8221;&#65289;&#12290;在后续的章节中&#65292;俺会以这个模型为主体&#65292;进行介绍&#12290;<br>
&#12288;&#12288;除了&#8220;OSI 模型&#8221;还有一个很出名的模型是&#8220;TCP/IP 模型&#8221;&#65288;因为互联网很成功&#65292;它才跟着出名&#65289;&#12290;<br>
&#12288;&#12288;对&#8220;TCP/IP 模型&#8221;的分层&#65292;不同的文章或书籍&#65292;说法不太一样&#65288;&#8220;3层&#12289;4层&#12289;5层&#8221;皆有&#65289;&#65292;这就引发了一些争议&#12290;包括几位热心读者也在博客留言&#65292;表达不同意见&#12290;为了避免一家之言&#65292;贴出维基百科的&#8220;<a href="https://en.wikipedia.org/wiki/Internet_protocol_suite#Layer_names_and_number_of_layers_in_the_literature" target="_blank" rel="nofollow">这个链接</a>&#8221;&#65292;其中给出了几种比较有名的说法&#12290;<br>
&#12288;&#12288;另外&#65292;俺想提醒一下&#65306;<br>
&#12288;&#12288;由于本文是基于&#12304;OSI 模型&#12305;进行展开&#12290;对于 TCP/IP 模型到底算几层&#65292;这方面的争论&#12304;不&#12305;影响本文后续的内容&#12290;<br>
<br>
<br>
<h2>&#9733;OSI 概述</h2>
<br>
<h3>&#9671;OSI 的历史</h3>
<br>
&#12288;&#12288;&#8220;OSI&#8221;的全称是&#8220;Open System Interconnection&#8221;&#12290;先说说它的历史&#12290;<br>
&#12288;&#12288;上世纪70年代&#65292;&#8220;国际电信联盟&#8221;&#65288;ITU&#65289;想对各国的电信系统&#65288;电话/电报&#65289;建立标准化的规格&#65307;与此同时&#65292;&#8220;国际标准化组织&#8221;&#65288;ISO&#65289;想要建立某种统一的标准&#65292;使得不同公司制造的大型主机可以相互联网&#12290;<br>
&#12288;&#12288;后来&#65292;这两个国际组织意识到&#65306;&#8220;电信系统互联&#8221;与&#8220;电脑主机互联&#8221;的性质差不多&#12290;于是 ISO 与 ITU 就决定合作&#65292;两家一起干&#12290;这2个组织的2套班子&#65292;从上世纪70年代开始搞&#65292;搞来搞去&#65292;搞了很多年&#65292;一直到1984年才终于正式发布 OSI 标准&#12290;<br>
<br>
<h3>&#9671;OSI 标准的两个组成部分</h3>
<br>
&#12288;&#12288;严格来讲&#65292;OSI 包括两大部分&#8212;&#8212;<br>
其一&#65292;抽象的概念模型&#65292;也就是前面提到的&#12304;OSI model&#12305;&#65307;<br>
其二&#65292;针对这个概念模型的具体实现&#65288;具体的通讯协议&#65289;&#65292;洋文叫做&#12304;OSI protocols&#12305;&#12290;<br>
<br>
&#12288;&#12288;&#65288;前面说了&#65289;OSI 是由 ISO &#65286; ITU 联手搞出来滴&#12290;这两个国际组织里面的人&#65292;要么是来自各国的电信部门&#65292;要么是来自各国的高校学者&#12290;总而言之&#65292;既有严重的官僚风气&#65292;又有明显的学究风气&#12290;&#65288;正是因为这两种风气叠加&#65292;所以搞了很多年&#65292;才搞出 OSI&#65289;<br>
&#12288;&#12288;OSI 的协议实现&#65288;OSI protocols&#65289;&#65292;不客气地说&#65292;就是一堆垃圾&#8212;&#8212;据说把 OSI protocols 所有的协议文档&#65292;全部打印成 A4 纸&#65292;摞起来得有一米多高&#65281;是不是很吓人&#65311;协议搞得如此复杂&#65292;严重违背了 IT 设计领域的 <a href="https://en.wikipedia.org/wiki/KISS_principle" target="_blank" rel="nofollow">KISS 原则</a>&#12290;<br>
&#12288;&#12288;由于 OSI protocols 实在太复杂&#65292;后来基本没人用&#12290;但 OSI model 反而广为流传&#65292;并且成为&#8220;网络分层模型&#8221;中名气最大&#65292;影响力最广的一个&#12290;<br>
&#12288;&#12288;因此&#65292;本文后续章节中&#65292;凡是提到 OSI&#65292;指的是&#12304;OSI model&#12305;&#12290;<br>
<br>
<h3>&#9671;OSI 模型的7层</h3>
<br>
&#12288;&#12288;OSI 模型总共分7层&#65292;示意图参见如下表格&#65306;<br>
<center><table border="1" cellspacing="0" cellpadding="5"><tbody>
<tr style="background:lightgrey;"><th>层次</th><th>中文名</th><th>洋文名</th></tr>
<tr><td>第7层</td><td>应用层</td><td>Application Layer</td></tr>
<tr><td>第6层</td><td>表示层</td><td>Presentation Layer</td></tr>
<tr><td>第5层</td><td>会话层</td><td>Session Layer</td></tr>
<tr><td>第4层</td><td>传输层</td><td>Transport Layer</td></tr>
<tr><td>第3层</td><td>网络层</td><td>Network Layer</td></tr>
<tr><td>第2层</td><td>数据链路层</td><td>Data Link Layer</td></tr>
<tr><td>第1层</td><td>物理层</td><td>Physical Layer</td></tr>
</tbody></table>
&#65288;注&#65306;为了打字省力&#65292;在后续章节把&#8220;数据链路层&#8221;直接称为&#8220;链路层&#8221;&#65289;</center>
<br>
&#12288;&#12288;考虑到本文是针对一般性读者的&#12304;扫盲教程&#12305;&#65292;俺重点聊第1~4层&#12290;搞明白这几个层次之后&#65292;有助于你更好地理解网络的很多概念&#65292;也有助于你更好地理解很多信息安全的概念&#12290;<br>
&#12288;&#12288;网上已经有很多关于 OSI 的文章&#65292;可惜大部分写得粗糙&#8212;&#8212;很多文章只是在照抄定义&#12290;<br>
&#12288;&#12288;俺曾经写过一篇&#12298;<a href="../../2009/02/study-technology-in-three-steps.html">学习技术的三部曲&#65306;WHAT&#12289;HOW&#12289;WHY</a>&#12299;&#65292;其中提到&#12304;理解技术&#12305;的不同层次&#12290;要想更好地理解 OSI 模型&#65292;你得搞明白&#65306;为啥需要引入某某层&#65311;&#65288;请注意&#65306;这是一个 WHY 型的问题&#65289;<br>
&#12288;&#12288;接下来在讨论 OSI 的每个层次时&#65292;俺都会专门写一个小节&#65292;谈该层次的&#12304;必要性&#12305;&#12290;搞明白&#12304;必要性&#12305;&#65292;你就知道为啥要引入这个层次&#12290;<br>
<br>
<br>
<h2>&#9733;物理层&#65306;概述</h2>
<br>
<h3>&#9671;物理层的必要性</h3>
<br>
&#12288;&#12288;通俗地说&#65306;直接与物理介质打交道的层次&#65292;就是物理层&#12290;这一层的必要性比较明显&#12290;<br>
&#12288;&#12288;因为所有的通讯&#65292;归根结底都要依赖于&#12304;物理介质&#12305;&#12290;与物理介质打交道&#65292;需要牵涉到很多与&#12304;物理学&#12305;相关的东东&#12290;比如&#65306;&#8220;无线电通讯&#8221;需要关心&#8220;频率/波长&#8221;&#65307;电缆通讯需要跟&#8220;电压&#8221;打交道&#65307;&#8220;光纤通讯&#8221;需要关心&#8220;玻璃的折射率&#65286;光线的入射角&#8221; ......<br>
&#12288;&#12288;&#8220;物理层&#8221;的主要职责是&#65306;屏蔽这些细节&#65292;使得&#8220;物理层&#8221;之上的层次不用再去操心物理学&#12290;<br>
<br>
<h3>&#9671;物理信道的类型</h3>
<br>
&#12288;&#12288;何为&#8220;物理信道&#8221;&#65292;在本文开篇的&#8220;基本概念&#8221;已经提到了&#12290;<br>
&#12288;&#12288;对于&#8220;物理信道&#8221;&#65292;还可以进一步细分为如下三大类&#65306;<br>
1. 有线信道&#65288;比如&#65306;双绞线&#12289;同轴电缆&#12289;光纤&#12289;等等&#65289;<br>
2. 无线信道&#65288;比如&#65306;微波通讯&#12289;电台广播&#12289;卫星通讯&#12289;等等&#65289;<br>
3. 存储信道<br>
<br>
&#12288;&#12288;&#8220;存储信道&#8221;比较少见&#65292;很多人没听说过&#65292;稍微解释一下&#12290;<br>
&#12288;&#12288;假设你要把一大坨信息传送给另一个人&#65292;除了用&#8220;有线 or 无线&#8221;这两种通讯方式&#65292;还可以把信息先保存到某种&#12304;存储介质&#12305;&#65288;比如硬盘&#65289;&#65292;然后再把存储介质用某种方式&#65288;比如快递&#65289;转交给对方&#12290;这就是所谓的&#8220;存储信道&#8221;&#12290;<br>
<br>
<h3>&#9671;<a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E5%99%AA%E6%AF%94" target="_blank" rel="nofollow">信噪比</a>&#65288;Signal-to-noise ratio&#65289;</h3>
<br>
&#12288;&#12288;俺在很多篇关于&#8220;学习&#65286;心理学&#8221;的博文中提到过&#12304;信噪比&#12305;这个概念&#12290;其实这个概念是从通讯领域借用的术语&#12290;<br>
&#12288;&#12288;对于&#8220;物理信道&#8221;&#65292;总是会存在某些环境干扰&#65292;称之为&#8220;噪声&#8221;&#65288;Noise&#65289;&#12290;&#8220;信道传输的有用信息&#8221;与&#8220;无用的干扰噪声&#8221;&#65292;这两者的比值就是&#8220;信噪比&#8221;&#12290;<br>
&#12288;&#12288;&#8220;信噪比&#8221;单位是&#12304;分贝&#12305;&#12290;&#8220;分贝&#8221;洋文叫做&#8220;<a href="https://en.wikipedia.org/wiki/Decibel" target="_blank" rel="nofollow">decibel</a>&#8221;&#65288;简写为 dB&#65289;&#12290;&#8220;deci&#8221;表示&#8220;十进制&#8221;&#65307;&#8220;bel&#8221;是为了纪念大名鼎鼎的贝尔&#65288;电话它爹&#65289;&#12290;<br>
<br>
<h3>&#9671;带宽的限制因素</h3>
<br>
&#12288;&#12288;&#8220;物理信道&#8221;要依赖于物理传输介质&#12290;不管使用何种物理介质&#65292;都要受限于某些基本的物理学定律&#65288;比如&#8220;光速上限&#8221;&#65289;&#12290;另外&#65292;不管何种物理介质&#65292;总是会有或多或少的环境干扰&#65288;噪声&#65289;&#12290;这两个因素导致了&#65306;任何&#8220;物理信道&#8221;的最大传输率总是有限滴&#12290;<br>
&#12288;&#12288;由于物理层是最底下的一层&#65292;物理层之上的其它层次总是要直接或间接地依赖&#12304;物理信道&#12305;&#12290;因此&#65292;其它层次建立的&#8220;逻辑信道&#8221;&#65292;其带宽只会比&#8220;物理信道&#8221;的最大带宽更小&#12290;换句话说&#65306;&#8220;物理信道&#8221;的带宽上限也就是整个协议栈的带宽上限&#12290;<br>
<br>
<h3>&#9671;<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8" target="_blank" rel="nofollow">多路复用</a>&#65288;Multiplexing&#65289;</h3>
<br>
&#12288;&#12288;一般来说&#65292;凡是能实现&#12304;长距离&#12305;通讯的&#8220;物理信道&#8221;&#65292;都有相当的经济成本&#12290;比如铺设&#8220;光纤&#12289;同轴电缆&#8221;都要花钱&#12290;无线电通讯虽然免去了铺设线路的成本&#65292;但需要竞标购买频段&#12290;因此&#65292;物理信道非常强调&#8220;多路复用&#8221;&#12290;<br>
&#12288;&#12288;所谓的&#8220;多路复用&#8221;&#65292;通俗地说就是&#65306;尽可能地共享物理信道&#65292;不要浪费了&#12290;<br>
&#12288;&#12288;&#8220;多路复用&#8221;有很多种类型&#65307;不同的类型&#65292;原理也不同&#12290;为了展示各种不同的原理&#65292;俺拿&#12304;无线通信&#12305;来说事儿&#12290;<br>
&#12288;&#12288;无线通信领域的&#8220;多路复用&#8221;&#65292;&#12304;至少&#12305;有如下几种&#65306;<br>
<br>
&#12288;&#12288;<b>频分多路复用/FDM&#65288;Frequency-Division Multiplexing&#65289;</b><br>
&#12288;&#12288;这个最简单&#65292;就是根据频率拆分&#12290;不同的线路占用不同的频段&#65292;互不干扰&#12290;&#65288;电台广播用的就是这个思路&#65289;<br>
&#12288;&#12288;但这个思路的缺点很明显&#8212;&#8212;<br>
其一&#65292;要依赖足够宽的频段&#65288;频段是稀缺资源&#65289;&#65307;<br>
其二&#65292;不同线路的流量可能会动态变化&#12290;如果某个线路空闲&#65292;其占用的频段就浪费了&#12290;<br>
&#12288;&#12288;&#65288;注&#65306;光纤通讯中有个&#8220;波分多路复用/WDM&#8221;&#65292;本质上就是 FDM&#65289;<br>
<br>
&#12288;&#12288;<b>时分多路复用/TDM&#65288;Time-Division Multiplexing&#65289;</b><br>
&#12288;&#12288;这种思路只用一个很窄的频段&#12290;为了在同一个频道发送多个信道&#65292;采用&#12304;分时机制&#12305;&#65292;把时间切割成很小的时间片&#65292;每个线路占用一个时间片&#12290;周而往复&#12290;<br>
&#12288;&#12288;这个思路有点像十字路口的红绿灯&#8212;&#8212;每隔一段时间&#65292;其中一条路可以通行&#12290;<br>
&#12288;&#12288;这个思路的优点是&#65306;可以只使用一个很窄的频段&#12290;缺点是&#65306;线路越多&#65292;每条线路等待越久&#65307;即使某个线路空闲&#65292;依然会占用时间片&#65288;浪费了资源&#65289;&#12290;<br>
<br>
&#12288;&#12288;<b>码分多路复用/CDM&#65288;Code-Division Multiplexing&#65289;</b><br>
&#12288;&#12288;这种思路采用某种&#12304;编码&#12305;的技巧&#65292;使得多个端点可以在同一个时间点使用同一频段发送数据&#65307;由于他们采用不同的编码方式&#65292;不会相互干扰&#12290;<br>
&#12288;&#12288;一般来说&#65292;CDM 要依赖于&#8220;扩频技术&#8221;&#65288;<a href="https://en.wikipedia.org/wiki/Spread_spectrum" target="_blank" rel="nofollow">spread spectrum</a>&#65289;&#65292;需占用一个比较宽的频道范围&#12290;这算是缺点&#12290;但其优点很明显&#8212;&#8212;<br>
其一&#65292;可以支持 N 个线路&#65288;N 动态变化&#65289;&#65307;<br>
其二&#65292;即使任何一个线路的流量动态变化&#65292;也不会浪费物理信道的资源&#12290;<br>
&#12288;&#12288;显然&#65292;这种思路明显优于 FDM &#65286; TDM&#12290;如今在移动通讯领域大名鼎鼎的 CDMA&#65288;码分多址&#65289;&#65292;采用的就是这个思路&#12290;<br>
<br>
<br>
<h2>&#9733;物理层&#65306;具体实例</h2>
<br>
<h3>&#9671;物理层的&#12304;协议&#12305;</h3>
<br>
&#12288;&#12288;物理层的协议主要有如下&#65306;<br>
<a href="https://en.wikipedia.org/wiki/Universal_Serial_Bus" target="_blank" rel="nofollow">USB 协议</a><br>
<a href="https://en.wikipedia.org/wiki/List_of_Bluetooth_protocols" target="_blank" rel="nofollow">蓝牙协议</a>的一部分<br>
<a href="https://en.wikipedia.org/wiki/IEEE_802.11" target="_blank" rel="nofollow">IEEE 802.11</a> 的一部分&#65288;Wi-Fi&#65289;<br>
<a href="https://en.wikipedia.org/wiki/IEEE_802.16" target="_blank" rel="nofollow">IEEE 802.16</a>&#65288;WiMAX&#65289;<br>
<a href="https://en.wikipedia.org/wiki/IEEE_1394" target="_blank" rel="nofollow">IEEE 1394</a>&#65288;火线接口&#65289;<br>
<a href="https://en.wikipedia.org/wiki/RS-232" target="_blank" rel="nofollow">RS-232 协议</a>&#65288;串行接口/串口&#65289;<br>
......<br>
&#65288;考虑到篇幅&#65289;俺不可能具体细聊这些协议&#65292;只是贴出每个的维基百科链接&#65292;感兴趣的同学自己点进去看&#12290;<br>
<br>
<h3>&#9671;物理层的&#12304;协议实现&#12305;</h3>
<br>
&#12288;&#12288;对于电脑主机&#65288;含移动设备&#65289;&#65292;&#8220;网卡硬件&#8221;包含了物理层的协议实现&#65288;参见如下示意图&#65289;<br>
&#12288;&#12288;另外&#65292;还有一些专门的&#12304;1层&#12305;网络设备&#65292;也提供物理层的功能&#65288;参见下一个小节&#65289;&#12290;<br>
<br>
<center><img src="../../images/2021/03/uYGaEvDYmziV-6EZ1AnRskoGpyKwxBcHgV5wgVtsDKmyP37OQgfX_zPYYeV3drFWBATFb95DYIwMPCgNApfg9Vtxrrpyvept6LNDQi0Vh3Fp6d31LFarI4ZjY1mSaQqP94HJaVQHBEQ" alt="不见图 请翻墙"><br>
&#65288;OSI 模型中&#65292;不同层次的协议实现&#65289;</center>
<br>
<h3>&#9671;物理层相关的&#12304;网络设备&#12305;</h3>
<br>
&#12288;&#12288;<b><a href="https://zh.wikipedia.org/wiki/%E8%B0%83%E5%88%B6%E8%A7%A3%E8%B0%83%E5%99%A8" target="_blank" rel="nofollow">调制解调器</a>&#65288;modem&#65289;</b><br>
&#12288;&#12288;通俗地说&#65292;&#8220;调制解调器&#8221;就是用来翻译&#8220;数字信号 &#65286; 模拟信号&#8221;&#12290;<br>
&#12288;&#12288;在发送信息时&#65292;modem 把电脑要发送的&#8220;字节流&#8221;&#65288;数字信号&#65289;翻译成&#8220;模拟信号&#8221;&#65292;然后通过物理介质发送出去&#65307;当它从物理介质收到&#8220;模拟信号&#8221;&#65292;再翻译成&#8220;数字信号&#8221;&#65292;传回给电脑&#12290;<br>
&#12288;&#12288;早期的拨号上网&#65292;modem 面对的物理介质是&#8220;固话线路&#8221;&#65307;如今家庭宽带普及&#65292;光纤入户&#65292;modem 面对的物理介质是&#8220;光纤线路&#8221;&#12290;<br>
<br>
<center><img src="../../images/2021/03/nfl3YFl3Bgg13u0xQV0CsGvLSObLDDbGI5wuDcGTulde_klpLWZX9fhpGbiE1SgAJYBDVUtrM4MwjV5Hy6DYA5YC7gKyVaQs-xy_kUdC1jm1hWnAuHdq9q3VDhxoMPbJxEYlL6pONFw" alt="不见图 请翻墙"><br>
&#65288;老式 modem&#65292;用于固定电话线路&#65289;</center>
<br>
&#12288;&#12288;<b><a href="https://en.wikipedia.org/wiki/Repeater" target="_blank" rel="nofollow">中继器</a>&#65288;repeater&#65289;</b><br>
&#12288;&#12288;信号在物理介质中传输&#65292;会出现&#12304;衰减&#12305;&#65288;不论是&#8220;有线 or 无线&#8221;都有可能衰减&#65289;&#12290;&#8220;中继器&#8221;的作用是&#12304;信号增益&#12305;&#65292;使得信号能传得更远&#12290;<br>
&#12288;&#12288;另外&#65292;比如&#8220;微波通讯&#8221;是直线传播&#65292;而地球表面有弧度&#65292;还有地形的起伏&#12290;所以每隔一定距离要建&#8220;微波塔&#8221;&#12290;这玩意儿也相当于&#8220;中继器&#8221;&#12290;<br>
<br>
<center><img src="../../images/2021/03/DQOkSWCmJO86Vc1hNJhGONs8j2oHbjS8hlA1XxFL7OIrdPsGT9amhbHzoKHjo8S0aTfVQYgKoBPvP0vEw8lvLEby6OubBeTkHZaV1sikpzIgvVGmLYT_nSmHMZqfJFmUowukZ5pbOoY" alt="不见图 请翻墙"><br>
&#65288;微波塔示意图&#65289;</center>
<br>
&#12288;&#12288;<b><a href="https://zh.wikipedia.org/wiki/%E9%9B%86%E7%B7%9A%E5%99%A8" target="_blank" rel="nofollow">集线器</a>&#65288;hub&#65289;</b><br>
&#12288;&#12288;可以把&#8220;集线器&#8221;视作更牛逼的&#8220;中继器&#8221;&#8212;&#8212;&#8220;中继器&#8221;只有两个口&#65288;只能连接两个通讯端点&#65289;&#65292;而&#8220;集线器&#8221;有多个口&#65288;同时连接多个通讯端点&#65289;&#12290;<br>
&#12288;&#12288;通常所说的&#8220;集线器&#8221;是指&#8220;以太网集线器&#8221;&#12290;这种设备如今已经逐步淘汰&#65292;很少见到了&#12290;<br>
<br>
<center><img src="../../images/2021/03/JdWYf1BMAyz3Td7XLh7Yuu0YxQLtIzhWHvPhp_xXszrTH-MPiarsWjh9zyL-0Mx0ysRbxANYwaoH6J5OAUC8Hkd58Wx0TIu5D5-AtmWoDpGnGs9aOu7T3Uzc8bYWcUmu5ZCVEH14L44" alt="不见图 请翻墙"><br>
&#65288;老式的10兆以太网集线器&#65289;</center>
<br>
&#12288;&#12288;另外&#65292;很多同学应该都用过&#8220;USB hub&#8221;&#65292;就是针对 USB 线的&#8220;集线器&#8221;&#65288;&#8220;USB 线&#8221;也可以视作某种通讯介质&#65289;&#12290;<br>
<br>
<br>
<h2>&#9733;链路层&#65306;概述</h2>
<br>
<h3>&#9671;链路层的必要性</h3>
<br>
&#12288;&#12288;<b>对信息的打包</b><br>
&#12288;&#12288;物理层传输的信息&#65292;通俗地说就是&#12304;比特流&#12305;&#65288;也就是一长串比特&#65289;&#12290;但是对于计算机来说&#65292;&#8220;比特流&#8221;太低级啦&#65292;处理起来极不方便&#12290;&#8220;链路层&#8221;要干的第一个事情&#65292;就是把&#8220;比特流&#8221;打包成更大的一坨&#65292;以方便更上层的协议进行处理&#12290;在 OSI 模型中&#65292;链路层的一坨&#65292;称之为&#8220;帧&#8221;&#65288;frame&#65289;&#12290;<br>
<br>
&#12288;&#12288;<b>差错控制</b><br>
&#12288;&#12288;物理介质的传输&#65292;可能受到环境的影响&#12290;这种影响不仅仅体现为&#8220;噪声&#8221;&#65292;有时候会出现严重的干扰&#65292;导致物理层传输的&#8220;比特流&#8221;出错&#65288;某个比特&#8220;从0变1&#8221;或&#8220;从1变0&#8221;&#65289;&#12290;因此&#65292;链路层还需要负责检查物理层的传输是否出错&#12290;在 IT 行话中&#65292;检测是否出错&#65292;称之为&#8220;差错控制机制&#8221;&#65288;后面有一个小节会简单说一下这个话题&#65289;&#12290;<br>
<br>
&#12288;&#12288;<b>流量控制</b><br>
&#12288;&#12288;假设两个端点通过同一个物理信道进行通讯&#65292;这两个端点处理信息的速度可能不同&#12290;如果发送方输出信息的速度超过接收方处理信息的速度&#65292;通讯就会出问题&#12290;于是就需要有某种机制来协调&#65292;确保发送方的发送速度不会超出接收方的处理速度&#12290;在技术行话中&#65292;这称之为&#8220;流量控制&#8221;&#65292;简称&#8220;流控&#8221;&#12290;<br>
<br>
&#12288;&#12288;<b>信道复用</b><br>
&#12288;&#12288;在上一个章节已经讲到&#65306;用于远距离通讯的&#8220;物理介质&#8221;&#65292;总是有成本&#12290;因此需要对物理信道进行&#8220;多路复用&#8221;&#65292;就会导致多个端点共用同一个物理信道&#12290;如果同时存在多个发送者和多个接收者&#12290;接收者如何知道某个信息是发给自己而不是别人&#65311;<br>
&#12288;&#12288;另外&#65292;某些物理介质可能不支持并发&#65288;无法同时发送信息&#65289;&#12290;某些物理介质可能是&#12304;半双工&#12305;&#65292;所有这些物理层的限制&#65292;都使得&#8220;多路复用&#8221;变得复杂&#12290;为了解决这些问题&#65292;链路层需要提供了某种相应的机制&#65288;协议&#65289;&#65292;术语叫做&#8220;介质访问控制&#8221;&#65288;洋文是&#8220;Media Access Control&#8221;&#65292;简称 MAC&#65289;&#12290;后续小节会聊它&#12290;<br>
<br>
<h3>&#9671;差错控制</h3>
<br>
&#12288;&#12288;为了发现传输的信息是否出错&#65292;设计了很多相应的数学算法&#12290;这些算法大体分为两类&#65306;&#8220;检错算法 &#65286; 纠错算法&#8221;&#12290;<br>
&#12288;&#12288;简而言之&#65292;&#8220;检错算法&#8221;只能检测出错误&#65292;而&#8220;纠错算法&#8221;不但能检测出错误&#65292;还能纠正错误&#12290;很显然&#65292;&#8220;纠错算法&#8221;更牛逼&#65292;但是它也更复杂&#12290;<br>
&#12288;&#12288;常见的&#8220;检错算法&#8221;对传输的数据计算出一个&#12304;校验值&#12305;&#65292;接收方收到数据会重新计算校验和&#65292;如果算出来不对&#65292;就把收到的数据丢弃&#65292;让对方重发&#12290;&#8220;校验算法&#8221;的原理类似于&#12298;<a href="../../2013/02/file-integrity-check.html">扫盲文件完整性校验&#8212;&#8212;关于散列值和数字签名</a>&#12299;一文中提到的&#8220;散列算法/哈希算法&#8221;&#12290;<br>
&#12288;&#12288;&#8220;纠错算法&#8221;更高级&#65292;由于涉及到更多数学&#65292;俺就不展开啦&#12290;<br>
&#12288;&#12288;对于&#12304;无线&#12305;物理信道&#65292;由于出错的概率更高&#65292;并且重新传输数据的成本也更高&#12290;所以&#12304;无线&#12305;通讯的链路层协议&#65292;更倾向于用&#12304;纠错&#12305;机制&#65307;作为对比&#65292;&#12304;有线&#12305;通讯的链路层协议&#65292;更倾向于用&#12304;检错&#12305;机制&#12290;<br>
<br>
<h3>&#9671;<a href="https://en.wikipedia.org/wiki/Medium_access_control" target="_blank" rel="nofollow">MAC 协议</a></h3>
<br>
&#12288;&#12288;&#8220;MAC 协议&#8221;用来确保对下层物理介质的使用&#65292;不会出现冲突&#12290;为了形象&#65292;俺拿&#8220;铁路系统&#8221;来比喻&#65292;说明&#8220;MAC 协议&#8221;的用途&#12290;<br>
&#12288;&#12288;假设有一条&#12304;单轨&#12305;铁路连接 A/B 两地&#12290;有很多火车想从 A 开到 B&#65292;同时还有很多火车想从 B 开到 A&#12290;<br>
&#12288;&#12288;首先&#65292;要确保不发生撞车&#65288;如果已经有车在 A 开往 B 的途中&#65292;那么 B 就不能再发车&#65289;&#65307;其次&#65292;即使是同一个方向的车&#65292;出发时间也要错开一个时间间隔&#12290;<br>
&#12288;&#12288;所有这些协调工作&#65292;都是靠&#8220;MAC 协议&#8221;来搞定&#12290;<br>
<br>
<h3>&#9671;MAC 地址</h3>
<br>
&#12288;&#12288;为了完成上述任务&#65292;光有&#8220;MAC 协议&#8221;还不够&#65292;还需要为每一个端点引入&#12304;惟一的&#12305;标识&#12290;这个标识就称作&#8220;MAC 地址&#8221;&#12290;<br>
&#12288;&#12288;通俗地说&#65292;每个网卡都内置了一个&#8220;MAC 地址&#8221;&#12290;这个地址是网卡在出厂的时候就已经设置好的&#65292;并且用某种机制确保该地址&#12304;全球唯一&#12305;&#12290;<br>
<br>
&#12288;&#12288;如何保证 MAC 地址全球唯一捏&#65311;简单说一下&#65306;<br>
&#12288;&#12288;MAC 地址包含6个字节&#65288;48个比特&#65289;&#65292;分为两半&#12290;第一部分称作&#12304;OUI&#12305;&#65292;OUI 的24个比特中&#65292;其中2个比特有特殊含义&#65292;其它22个比特&#65292;用来作为网卡厂商的唯一编号&#12290;这个编号由国际组织 IEEE 统一分配&#12290;<br>
&#12288;&#12288;MAC 地址第二部分的24比特&#65292;由网卡厂商自己决定如何分配&#12290;每个厂商只要确保自己生产的网卡&#65292;后面这24比特是唯一的&#65292;就行啦&#12290;<br>
<center><img src="../../images/2021/03/p1BJLdyURQLXwjaX9w6zrYxmzkFitCfuXYxEnQ8o2WaciD67PpWKUzx2MM4s7ay2Ds9Ltn4oHERF0uq17z_zaEIZFvRBqDb2U7WUPtAVM9Cve1_BUtd8Emx-073rj3jpizDMZRwdQ5o" alt="不见图 请翻墙"><br>
&#65288;MAC 地址的构成&#65289;</center>
<br>
&#12288;&#12288;由于俺在很多安全教程中鼓吹大伙儿使用&#8220;<a href="../../2012/10/system-vm-0.html">操作系统虚拟机</a>&#8221;&#65292;再顺便说说&#12304;虚拟网卡&#12305;的 MAC 地址&#12290;<br>
&#12288;&#12288;&#8220;虚拟网卡&#8221;是由&#12304;虚拟化软件&#12305;创建滴&#12290;IEEE 也给每个虚拟化软件的厂商&#65288;含开源社区&#65289;分配了唯一的 OUI&#12290;因此&#65292;虚拟化软件在创建&#8220;虚拟网卡&#8221;时&#65292;会使用自己的 OUI 生成前面24个比特&#65307;后面的24比特&#65292;会采用某种算法使之尽可能&#12304;随机化&#12305;&#12290;由于&#8220;2的24次方&#8221;很大&#65288;<code>2<sup>24</sup> = 16777216</code>&#65289;&#65292;碰巧一样的概率很低&#12290;<br>
&#12288;&#12288;&#65288;注&#65306;如果手工修改 MAC 地址&#65292;故意把两块网卡的 MAC 地址搞成一样&#65292;那确实就做不到唯一性了&#12290;并且会导致链路层的通讯出问题&#65289;<br>
<br>
<br>
<h2>&#9733;链路层&#65306;具体实例</h2>
<br>
<h3>&#9671;链路层的&#12304;协议&#12305;</h3>
<br>
&#12288;&#12288;链路层的协议主要有如下&#65306;<br>
<a href="https://en.wikipedia.org/wiki/Media_access_control" target="_blank" rel="nofollow">MAC 协议</a>&#65288;介质访问控制&#65289;<br>
<a href="https://en.wikipedia.org/wiki/Logical_link_control" target="_blank" rel="nofollow">LLC 协议</a>&#65288;逻辑链路控制&#65289;<br>
<a href="https://en.wikipedia.org/wiki/Address_Resolution_Protocol" target="_blank" rel="nofollow">ARP 协议</a>&#65288;解析 MAC 地址&#65289;<br>
<a href="https://en.wikipedia.org/wiki/IEEE_802.3" target="_blank" rel="nofollow">IEEE 802.3</a>&#65288;以太网&#65289;<br>
<a href="https://en.wikipedia.org/wiki/IEEE_802.11" target="_blank" rel="nofollow">IEEE 802.11</a> 的一部分&#65288;Wi-Fi&#65289;<br>
<a href="https://en.wikipedia.org/wiki/Layer_2_Tunneling_Protocol" target="_blank" rel="nofollow">L2TP 协议</a>&#65288;2层VPN&#65289;<br>
<a href="https://en.wikipedia.org/wiki/Point-to-Point_Protocol" target="_blank" rel="nofollow">PPP 协议</a>&#65288;拨号上网&#65289;<br>
<a href="https://en.wikipedia.org/wiki/Serial_Line_Internet_Protocol" target="_blank" rel="nofollow">SLIP 协议</a>&#65288;拨号上网&#65289;<br>
......<br>
&#65288;考虑到篇幅&#65289;俺不可能具体细聊这些协议&#65292;只是贴出每个的维基百科链接&#65292;感兴趣的同学自己点进去看&#12290;<br>
<br>
<h3>&#9671;链路层的&#12304;协议实现&#12305;</h3>
<br>
&#12288;&#12288;对于电脑主机&#65288;含移动设备&#65289;&#65292;&#8220;网卡硬件 &#65286; 网卡驱动&#8221;会包含链路层协议的实现&#65288;参见如下示意图&#65289;&#12290;<br>
&#12288;&#12288;另外&#65292;还有一些专门的&#12304;2层&#12305;网络设备&#65292;也提供链路层的功能&#65288;参见下一个小节&#65289;&#12290;<br>
<br>
<center><img src="../../images/2021/03/uYGaEvDYmziV-6EZ1AnRskoGpyKwxBcHgV5wgVtsDKmyP37OQgfX_zPYYeV3drFWBATFb95DYIwMPCgNApfg9Vtxrrpyvept6LNDQi0Vh3Fp6d31LFarI4ZjY1mSaQqP94HJaVQHBEQ" alt="不见图 请翻墙"><br>
&#65288;OSI 模型中&#65292;不同层次的协议实现&#65289;</center>
<br>
<h3>&#9671;链路层相关的&#12304;网络设备&#12305;</h3>
<br>
&#12288;&#12288;<b><a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E4%BA%A4%E6%8F%9B%E5%99%A8" target="_blank" rel="nofollow">网络交换机</a>&#65288;network switch&#65289;</b><br>
&#12288;&#12288;&#65288;注&#65306;一般提到&#8220;网络交换机&#8221;&#65292;如果不加定语&#65292;指的就是&#8220;2层交换机&#8221;&#65307;此外还有更高层的交换机&#65292;在后续章节介绍&#65289;<br>
&#12288;&#12288;为啥要有交换机捏&#65311;俺拿&#8220;以太网的发展史&#8221;来说事儿&#12290;<br>
&#12288;&#12288;以太网刚诞生的时候&#65292;称之为&#8220;经典以太网&#8221;&#65292;电脑是通过&#12304;集线器&#12305;相连&#12290;&#8220;集线器&#8221;前面提到过&#65292;工作在&#12304;1层&#12305;&#65288;物理层&#65289;&#65292;并不理解链路层的协议&#12290;因此&#65292;集线器的原理是&#12304;广播&#12305;模式&#8212;&#8212;它从某个网线接口收到的数据&#65292;会复制 N 份&#65292;发送到其它&#12304;每个&#12305;网线接口&#12290;假设有4台电脑&#65288;A&#12289;B&#12289;C&#12289;D&#65289;都连在集线器上&#65292;A 发数据给 B&#65292;其实 C &#65286; D 也都收到 A 发出的数据&#12290;显然&#65292;这种工作模式很傻逼&#65288;低效&#65289;&#12290;由于&#8220;经典以太网&#8221;的工作模式才&#8220;10兆&#8221;&#65292;所以集线器虽然低效&#65292;还能忍受&#12290;<br>
&#12288;&#12288;后来要发展&#8220;百兆以太网&#8221;&#65292;再用这种傻逼的广播模式&#65292;就不能忍啦&#12290;于是&#8220;经典以太网&#8221;就发展为&#8220;交换式以太网&#8221;&#12290;用&#12304;交换机&#12305;代替&#8220;集线器&#8221;&#12290;<br>
&#12288;&#12288;交换机是工作在2层&#65288;链路层&#65289;的设备&#65292;能够理解链路层协议&#12290;当交换机从某个网线接口收到一份数据&#65288;链路层的&#8220;帧&#8221;&#65289;&#65292;它可以识别出&#8220;链路帧&#8221;里面包含的目标地址&#65288;接收方的 MAC 地址&#65289;&#65292;然后只把这份数据转发给&#8220;目标 MAC 地址相关的网线接口&#8221;&#12290;<br>
&#12288;&#12288;由于交换机能识别2层协议&#65292;它不光比集线器的性能高&#65292;而且功能也强得多&#12290;比如&#65288;稍微高级点的&#65289;交换机可以实现&#8220;MAC 地址过滤&#12289;VLAN&#12289;QoS&#8221;等多种额外功能&#12290;<br>
<br>
&#12288;&#12288;<b><a href="https://zh.wikipedia.org/wiki/%E6%A1%A5%E6%8E%A5%E5%99%A8" target="_blank" rel="nofollow">网桥/桥接器</a>&#65288;network bridge&#65289;</b><br>
&#12288;&#12288;&#8220;交换机&#8221;通常用来连接&#12304;同一种&#12305;网络的设备&#12290;有时候&#65292;需要让两台不同网络类型的电脑相连&#65292;就会用到&#12304;网桥&#12305;&#12290;<br>
&#12288;&#12288;下面以&#8220;操作系统虚拟机&#8221;来举例&#65288;完全没用过虚拟机的同学&#65292;请跳过这个举例&#65289;&#12290;<br>
&#12288;&#12288;在<a href="../../2012/12/system-vm-5.html">这篇博文</a>&#65292;俺介绍了虚拟机的几种&#8220;网卡模式&#8221;&#65292;其中有一种模式叫做&#12304;bridge 模式&#12305;&#12290;一旦设置了这种模式&#65292;Guest OS 的虚拟网卡&#65292;对于 Host OS 所在的外部网络&#65292;是&#12304;双向&#12305;可见滴&#12290;也就是说&#65292;物理主机所在的外部网络&#65292;也可以看见这块虚拟网卡&#12290;<br>
&#12288;&#12288;现在&#65292;假设你的物理电脑&#65288;Host OS&#65289;只安装了&#12304;无线网卡&#12305;&#65288;WiFi&#65289;&#65292;而虚拟化软件给 Guest OS 配置的通常是&#12304;以太网卡&#12305;&#12290;显然&#65292;这是两种&#12304;不同&#12305;的网络&#12290;为啥 Guest OS 的以太网卡设置为&#8220;bridge 模式&#8221;之后&#65292;外部 WiFi 网络可以看到它捏&#65311;<br>
&#12288;&#12288;奥妙在于&#8212;&#8212;虚拟化软件在内部悄悄地帮你实现了一个&#8220;网桥&#8221;&#12290;这个网桥把&#8220;Host OS 的 WiFi 网卡&#8221;与&#8220;Guest OS 的以太网卡&#8221;关联起来&#12290;WiFi 网卡收到了链路层数据之后&#65292;如果接收方的 MAC 地址对应的是 Guest OS&#65292;网桥会把这份数据丢给 Guest OS 的网卡&#12290;<br>
&#12288;&#12288;这种网卡模式之所以称作&#8220;bridge 模式&#8221;&#65292;原因就在于此&#12290;<br>
<br>
<h3>&#9671;链路层相关的&#12304;软件工具&#12305;</h3>
<br>
&#12288;&#12288;<b>嗅探抓包工具&#65288;Sniffer&#65289;</b><br>
&#12288;&#12288;要了解链路层的数据包结构&#65292;需要用到&#8220;嗅探工具&#8221;&#12290;这类工具能捕获流经你网卡的所有&#12304;链路层&#12305;数据包&#12290;前面聊&#8220;协议栈&#8221;的时候说过&#65306;下层数据包的载荷就是上层数据包的整体&#12290;因此&#65292;拿到&#12304;链路层&#12305;数据包也就意味着&#65306;你已经拿到2层之上的所有数据包的信息了&#12290;<br>
&#12288;&#12288;有些抓包工具自带图形界面&#65292;可以直接显示数据包的内容给你看&#12290;还有些只提供命令行&#65288;只是把获取的数据包保存为文件&#65289;&#65292;然后要搭配其它图形化的工具来展示数据包的内容&#12290;<br>
&#12288;&#12288;抓包的工具有很多&#65292;名气最大的是 <a href="https://en.wikipedia.org/wiki/Wireshark" target="_blank" rel="nofollow">Wireshark</a>&#65288;原先叫做 Ethereal&#65289;&#12290;<br>
<br>
&#12288;&#12288;<b>ARP 命令</b><br>
&#12288;&#12288;首先&#65292;ARP 是&#8220;MAC 地址解析协议&#8221;的洋文名称&#12290;该协议根据&#8220;IP 地址&#8221;解析&#8220;MAC 地址&#8221;&#12290;<br>
&#12288;&#12288;Windows 自带一个同名的 <code>arp</code> 命令&#65292;可以用来诊断与&#8220;MAC 地址&#8221;相关的信息&#12290;比如&#65306;列出当前子网中其它主机的 IP 地址以及对应的 MAC 地址&#12290;这个命令在 Linux &#65286; Mac OS 上也有&#12290;<br>
<br>
<br>
<h2>&#9733;网络层&#65306;概述</h2>
<br>
<h3>&#9671;网络层的必要性</h3>
<br>
&#12288;&#12288;<b>路由机制&#65288;routing&#65289;</b><br>
&#12288;&#12288;在 OSI 模型中&#65292;链路层本身&#12304;不&#12305;提供路由功能&#12290;你可以通俗地理解为&#65306;链路层只处理&#12304;直接相连&#12305;的两个端点&#65288;注&#65306;这么说不完全严密&#65292;只是帮助外行理解&#65289;<br>
&#12288;&#12288;对于某个复杂网络&#65292;可能有很多端点&#65292;有很复杂的拓扑结构&#12290;当拓扑足够复杂&#65292;总有一些端点之间&#12304;没有直连&#12305;&#12290;那么&#65292;如何在这些&#12304;没有直连&#12305;的端点之间建立通讯捏&#65311;此时就需要提供某种机制&#65292;让其它端点帮忙转发数据&#12290;这就需要引入&#8220;路由机制&#8221;&#12290;<br>
&#12288;&#12288;为了避免把&#8220;链路层&#8221;搞得太复杂&#65292;路由机制放到&#8220;链路层&#8221;之上来实现&#65292;也就是&#8220;网络层&#8221;&#12290;<br>
<br>
&#12288;&#12288;<b>基于&#12304;路由&#12305;的地址编码方式</b><br>
&#12288;&#12288;链路层已经提供了某种全球唯一的地址编码方式&#65288;MAC 地址&#65289;&#12290;但&#8220;MAC 地址&#8221;有如下几个问题&#65306;<br>
其一&#65292;它是固定的&#65288;虽然可以用技术手段去修改 MAC 地址&#65292;但很少这么干&#65289;<br>
其二&#65292;MAC 地址的编码是基于&#12304;厂商&#12305;&#65292;无法体现网络拓扑结构&#12290;或者说&#65292;&#8220;MAC 地址&#8221;对于&#8220;路由机制&#8221;是不够友好滴&#12290;<br>
&#12288;&#12288;因此&#65292;需要引入一种更抽象&#65288;更高层&#65289;的地址&#65292;也就是&#8220;网络层地址&#8221;&#12290;咱们常说的&#8220;IP 地址&#8221;&#65292;是&#8220;网络层地址&#8221;的实现方式之一&#12290;<br>
<br>
&#12288;&#12288;为了帮你理解&#65292;举个例子&#65306;<br>
&#12288;&#12288;每个人都有身份证号&#65288;这就类似于&#8220;MAC 地址&#8221;&#65289;&#12290;当某人加入了某个公司&#65292;公司会为此人再分配一个&#8220;员工号&#8221;&#65288;这就类似于&#8220;网络地址&#8221;&#65289;&#12290;既然有身份证号&#65292;为啥公司还要另搞一套&#8220;员工编号&#8221;捏&#65311;因为&#8220;员工编号&#8221;有额外的好处&#12290;比如说&#65306;可以把员工号划分为不同的区间&#65292;对应不同的部门&#12290;这样一来&#65292;只要看到员工号&#65292;就知道此人来自哪个部门&#12290;<br>
&#12288;&#12288;类似道理&#65292;每个网卡都有自己固定的 MAC 地址&#65292;当这个网卡接入到不同的网络&#65292;每次都可以再分配不同的&#8220;网络地址&#8221;&#12290;通过&#8220;网络地址&#8221;可以看出这个网卡属于哪个网络&#65288;对路由比较方便&#65289;&#12290;<br>
<br>
&#12288;&#12288;<b>网际互联&#65288;<a href="https://en.wikipedia.org/wiki/Internetworking" target="_blank" rel="nofollow">internetwork</a>&#65289;</b><br>
&#12288;&#12288;引入&#8220;网络层&#8221;的另一个目的是&#65306;屏蔽不同类型的网络之间的差异&#65292;从而有利于&#12304;网际互联&#12305;&#65288;也就是建立&#8220;网络的网络&#8221;&#65289;&#12290;<br>
&#12288;&#12288;一般来说&#65292;要想联通&#12304;异种&#12305;网络&#65292;就要求每个网络中都有一台主机充当&#12304;网关&#12305;&#65288;gateway&#65289;&#12290;&#12304;网关&#12305;起到&#8220;中介/翻译&#8221;的作用&#8212;&#8212;帮不同的网络翻译协议&#65292;使得不同的网络可以互相联通&#12290;<br>
&#12288;&#12288;假设&#12304;没有&#12305;统一的网络层&#65292;网关的工作就很难做&#12290;就好比说&#65306;如果全球没有某种通用的自然语言&#65292;就需要培养非常多不同类型的翻译人才&#65288;假设有30种主要语言&#65292;任意两种互译&#65292;就需要几百种不同的翻译人才&#65289;&#12290;<br>
&#12288;&#12288;反之&#65292;如果有了某种统一的网络层标准&#65292;问题就好办多了&#65288;还是假设有30种主要语言&#65292;只要选定某种作为通用语&#65292;然后培养29种翻译人才&#65292;就可以实现任意两种语言互译&#65289;&#12290;<br>
&#12288;&#12288;如今的互联网时代&#65292;&#12304;IP 协议&#12305;就是那个充当统一标准的网络层协议&#12290;<br>
<br>
<center><img src="../../images/2021/03/zrXBFWSDp-D4VebTx73Un03rN3zKCjVL6Ax_VURmxZyaIj_bfr09TwYya1F6GyNz3W5JLmEvzDggkDPYuHpCdHfWjKHDHp-pBVubeDazpi7Ie9CHYbhJkVP1c48JSZJhpKn8zftthOo" alt="不见图 请翻墙"><br>
&#65288;互联网整合了各种类型的网络&#65289;</center>
<br>
<h3>&#9671;网络拓扑&#65288;network topology&#65289;</h3>
<br>
&#12288;&#12288;网络的拓扑结构有很多种&#65292;有简单的&#65292;有复杂的&#12290;一般来说&#65292;再复杂的拓扑&#65292;也可以逐步分解为若干简单拓扑的组合&#12290;<br>
&#12288;&#12288;对拓扑的研究&#65292;有专门一个数学分支&#65288;拓扑学&#65289;&#12290;考虑到本文只是扫盲&#65292;俺不可能再去聊&#8220;拓扑学&#8221;&#12290;因此&#65292;只挑几种简单的拓扑结构&#65292;让大伙儿有个直观的印象&#12290;<br>
<br>
<center><img src="../../images/2021/03/ccFqOwvxYuPyelLkW1KRh77tNfUR3TCMMSFN0YgJKJSUfBWISxnzj7mRKLvAP5FvCb2YJDZ8aZO7wRKslvltbWm5fn0QJk3uWp5F3xQy_GFXWVx__c1kDD-cV7HHejxuwqvR6ombf_M" alt="不见图 请翻墙"><br>
&#65288;常见的网状拓扑结构&#65306;星形拓扑&#12289;环形拓扑&#12289;总线拓扑&#12289;网状拓扑&#12289;等等&#65289;</center>
<br>
&#12288;&#12288;如今的互联网&#65292;整体的拓扑结构超级复杂&#12290;但还是可以逐步分解为上述几种基本的拓扑结构&#12290;<br>
<br>
<center><img src="../../images/2021/03/l2JVK5up10o5jLkXzIgrcNcTBpnXtmeBKxyHqhuxmqDFlAGDF8pXDqHhRfTf7kAeNLYrgnnI0HVElnFE-JKZXpwcC2Y1f12v5bftW4_6KIYQqY-77tI_pE---r3L3Fwle2i0PTgAnEc" alt="不见图 请翻墙"><br>
&#65288;互联网的复杂拓扑&#65292;右下角是图中某个小点的放大&#12290;<br>
为节省大伙儿的翻墙流量&#65292;俺贴的是缩小图&#12290;点&#8220;<a href="https://upload.wikimedia.org/wikipedia/commons/d/d2/Internet_map_1024.jpg" target="_blank" rel="nofollow">这里</a>&#8221;看原始图&#65289;</center>
<br>
<h3>&#9671;互联网的拓扑&#8212;&#8212;从&#8220;历史&#8221;的角度看其健壮性</h3>
<br>
&#12288;&#12288;从上面那张图可以看出&#65306;互联网拓扑的&#12304;局部&#12305;有很多是&#8220;星形拓扑&#8221;&#65288;当然也有其它的&#65289;&#12290;但从&#12304;宏观&#12305;上看&#65292;更像是&#8220;网状拓扑&#8221;&#12290;<br>
&#12288;&#12288;在现实生活中&#65292;对于复杂结构&#65292;通常都会采用&#8220;树状层次结构&#8221;&#65292;以便于管理&#12290;比如&#65306;域名系统&#12289;公司组织结构&#12289;官僚系统 ...... 那为啥互联网的&#12304;宏观&#12305;拓扑结构是&#8220;网状&#8221;捏&#65311;这就要说到互联网的历史&#12290;<br>
<br>
&#12288;&#12288;在上世纪50年代&#65288;冷战高峰期&#65289;&#65292;美国军方的指挥系统高度依赖于电信公司提供的电话网络&#12290;当时的电话网络大致如下&#8212;&#8212;<br>
在基层&#65292;每个地区有电话交换局&#65292;每一部电话都连入当地的交换局&#12290;<br>
在全国&#65292;设有若干个长途局&#65292;每个交换局都接入某个特定的长途局&#65288;不同地区的交换局通过长途局中转&#65289;&#12290;<br>
&#12288;&#12288;简而言之&#65292;当时美国的电话网络是典型的&#12304;多级星形拓扑&#12305;&#12290;这种拓扑的优点是&#65306;简单&#12289;高效&#12289;便于管理&#65307;但缺点是&#65306;健壮性很差&#12290;从这个案例中&#65292;大伙儿可以再次体会到&#8220;效率&#8221;与&#8220;健壮性&#8221;之间的矛盾&#12290;俺写过一篇很重要的博文&#65288;<a href="../../2020/04/Government-and-System-Robustness.html">这里</a>&#65289;深入讨论了这个话题&#12290;<br>
&#12288;&#12288;话说1957年的时候&#65292;苏联成功试射第一颗洲际弹道导弹&#65288;ICBM&#65289;&#65292;美国军方开始担心&#65306;一旦苏联先用洲际导弹攻击美国&#65292;只要把少数几个长途局轰掉&#65292;军方的指挥系统就会瘫痪&#12290;也就是说&#65292;&#8220;长途局&#8221;已经成为美国军方的&#12304;单点故障&#12305;&#65288;何为&#8220;单点故障&#8221;&#65311;参见<a href="../../2015/04/Single-Point-of-Failure.html">这篇博文</a>&#65289;&#12290;<br>
&#12288;&#12288;1960年&#65292;美国国防部找来大名鼎鼎的兰德公司进行咨询&#65292;要求提供一个应对核打击的方案&#12290;该公司的研究员 <a href="https://en.wikipedia.org/wiki/Paul_Baran" target="_blank" rel="nofollow">Paul Baran</a> 设计了一个方案&#65292;把&#8220;星形拓扑&#8221;改为&#12304;网状拓扑&#12305;&#12290;采用&#12304;网状拓扑&#12305;的好处在于&#65306;即使发生全面核大战&#65292;大量骨干节点被摧毁&#65292;整个网络也不会被分隔成几个孤岛&#65292;军方的指挥系统依然能正常运作&#12290;<br>
<br>
<center><img src="../../images/2021/03/IE-FTOWlH2Z5OjbyXQ18nnjCRMoQrk1jfjoyIuLApcwU1AGPhu0mFgJL65IkOsvADshV1Fxbfb4bSn54Xy4m08lDE-n-mtnaSYAAGCgIUZSvVZo-8IAPPzFyLUcZdvq_JWsoUOsfdZQ" alt="不见图 请翻墙"><br>
&#65288;左边&#65306;互联网诞生前&#8212;&#8212;美国的电话网络&#12288;&#12288;右边&#65306;兰德公司的&#8220;Baran 方案&#8221;&#65289;</center>
<br>
&#12288;&#12288;有了兰德公司的方案&#65292;美国军方找到当时最大的电信公司 AT&#65286;T&#65292;想要实现这个系统&#65292;结果被否决了&#12290;AT&#65286;T 高层认为&#65306;搞这样一种系统根本不切实际&#12290;于是 Baran 的方案中途夭折&#12290;<br>
&#12288;&#12288;为啥 AT&#65286;T 反对这个方案捏&#65311;一方面&#65292;成功的大公司总是有很强的思维定势&#65288;关于这点&#65292;参见<a href="../../2016/04/Andy-Grove-Quotes-on-Leadership.html">这篇文章</a>&#65289;&#65307;另一方面&#65292;Baran 的设计方案确实很超前&#8212;&#8212;其前瞻性不仅包括&#8220;拓扑结构&#8221;&#65292;而且把当时电信行业的几大核心观念完全颠覆掉了&#65288;具体如何颠覆&#65292;后续章节还会再聊&#65289;&#12290;<br>
&#12288;&#12288;时间一晃又过了好多年&#65292;到了60年代末&#65292;由于一系列机缘巧合&#65292;英国佬发现了&#8220;Baran 方案&#8221;的价值&#65292;并据此搞了一个小型的 NPL 网络&#65288;NPL 是&#8220;国家物理实验室&#8221;的缩写&#65289;&#12290;然后在某次 ACM 会议上&#65292;美国佬看到英国佬的论文&#65292;才意识到&#65306;Baran 方案完全可行&#12290;经历了&#8220;出口转内销&#8221;的命运之后&#65292;该方案重新被美国国防部重视&#12290;之后&#65292;&#65288;国防部下属的&#65289;&#8220;<a href="https://zh.wikipedia.org/wiki/%E5%9C%8B%E9%98%B2%E9%AB%98%E7%AD%89%E7%A0%94%E7%A9%B6%E8%A8%88%E5%8A%83%E7%BD%B2" target="_blank" rel="nofollow">高级计划研究局</a>&#8221;&#65288;ARPA&#65289;开始筹建&#8220;阿帕网&#8221;&#65288;ARPANET&#65289;&#65292;才有了如今的互联网&#12290;<br>
<br>
<h3>&#9671;路由的大致原理</h3>
<br>
&#12288;&#12288;聊完&#8220;拓扑&#8221;&#65292;再来聊&#8220;路由&#8221;&#12290;<br>
&#12288;&#12288;当主机 A 向主机 B 发送网络层的数据时&#65292;大致会经历如下步骤&#65306;<br>
1.<br>
A 主机的协议栈先判断&#8220;A B 两个地址&#8221;是否在同一个子网&#65288;&#8220;子网掩码&#8221;就是用来干这事儿滴&#65289;&#12290;<br>
如果是同一个子网&#65292;直接发给对方&#65307;如果不是同一个子网&#65292;发给本子网的&#12304;默认网关&#12305;&#12290;<br>
&#65288;此处所说的&#8220;网关&#8221;指&#8220;3层网关/网络层网关&#8221;&#65289;<br>
2.<br>
对于&#8220;默认网关&#8221;&#65292;有可能自己就是路由器&#65307;也可能自己不是路由器&#65292;但与其它路由器相连&#12290;<br>
也就是说&#65292;&#8220;默认网关&#8221;要么自己对数据包进行路由&#65292;要么丢给能进行路由的另一台设备&#12290;<br>
&#65288;万一找不到能路由的设备&#65292;这个数据就被丢弃&#65292;于是网络通讯出错&#65289;<br>
3.<br>
当数据到达某个路由器之后&#65292;有如下几种可能&#8212;&#8212;<br>
3.1<br>
该路由器正好是 B 所在子网的网关&#65288;与 B 直连&#65289;&#65292;那就把数据包丢给 B&#65292;路由过程就结束啦&#65307;<br>
3.2<br>
亦或者&#65292;路由器会把数据包丢给另一个路由器&#65288;另一个路由器再丢给另一个路由器&#65289; ...... 如此循环往复&#65292;最终到达目的地 B&#12290;<br>
3.3<br>
还存在一种可能性&#65306;始终找不到&#8220;主机 B&#8221;&#65288;有可能该主机&#8220;断线 or 关机 or 根本不存在&#8221;&#65289;&#12290;为了避免数据包长时间在网络上闲逛&#65292;还需要引入某种&#12304;数据包存活机制&#12305;&#65288;洋文叫做&#8220;Time To Live&#8221;&#65292;简称 TTL&#65289;&#12290;<br>
通常会采用某个整数&#65288;TTL 计数&#65289;表示数据包能活多久&#12290;当主机 A 发出这个数据包的时候&#65292;这个&#8220;TTL 计数&#8221;就已经设置好了&#12290;每当这个数据包被路由器转发一次&#65292;&#8220;TTL 记数&#8221;就减一&#12290;当 TTL 变为零&#65292;这个数据包就死了&#65288;被丢弃&#65289;&#12290;<br>
<br>
&#12288;&#12288;对于某些大型的复杂网络&#65288;比如互联网&#65289;&#65292;每个路由器可能与其它 N 个路由器相连&#65288;N 可能很大&#65289;&#12290;对于上述的 3.2 情形&#65292;它如何判断&#65306;该转发给谁捏&#65311;<br>
&#12288;&#12288;这时候&#65292;&#8220;路由算法&#8221;就体现出价值啦&#8212;&#8212;<br>
一般来说&#65292;路由器内部会维护一张&#12304;路由表&#12305;&#12290;每当收到一个网络层的数据包&#65292;先取出数据包中的&#12304;目标地址&#12305;&#65292;然后去查这张路由表&#65292;看谁距离目标最近&#65292;就把数据包转发给谁&#12290;<br>
&#12288;&#12288;上面这段话看起来好像很简单&#65292;其实路由算法挺复杂滴&#12290;考虑到本文是&#8220;扫盲性质&#8221;&#65292;而且篇幅已经很长&#65292;不可能再去聊&#8220;路由算法&#8221;的细节&#12290;对此感兴趣的同学&#65292;可以去看&#12298;<a href="https://docs.google.com/document/d/1XQwaAMzuGuvmq5fCiTDMrh_pTUpCHJJ5C17btTv8kdE/" target="_blank">计算机网络</a>&#12299;的第5章&#12290;<br>
<br>
<h3>&#9671;路由算法的演变史&#65288;以互联网为例&#65289;</h3>
<br>
&#12288;&#12288;&#65288;技术菜鸟可以跳过这个小节&#65289;<br>
&#12288;&#12288;由于互联网的 IP 协议已经成为&#8220;网络层协议&#8221;的事实标准&#65292;俺简单聊一下互联网的路由机制是如何进化滴&#12290;<br>
<br>
&#12288;&#12288;<b>第1阶段&#65306;静态全局路由表</b><br>
&#12288;&#12288;&#65288;前面说了&#65289;互联网的前身是&#8220;阿帕网/ARPANET&#8221;&#12290;在阿帕网诞生初期&#65288;上世纪70年代&#65289;&#65292;全球的主机很少&#12290;因此&#65292;早期的路由表很简单&#65292;既是&#8220;全局&#8221;滴&#65292;又是&#8220;静态&#8221;滴&#12290;简而言之&#65292;每个路由器内部都维护一张&#8220;全局路由表&#8221;&#65292;这个&#8220;路由表&#8221;包含了全球所有其它路由器的关联信息&#12290;每当来了一个数据包&#65292;查一下这张全局路由表&#65292;自然就清楚要转发给谁&#65292;才能最快到达目的地&#12290;<br>
&#12288;&#12288;早期的阿帕网&#65292;主机的变化比较少&#65292;也很少增加路由器&#12290;每当出现一个新的路由器&#65292;其它路由器的管理员就手工编辑各自的&#8220;全局路由表&#8221;&#12290;<br>
&#12288;&#12288;为了加深大伙儿印象&#65292;特意找来两张70年代初的阿帕网拓扑图&#65288;注&#65306;图中的 IMP 是&#8220;Interface Message Processor&#8221;的缩写&#65292;也就是如今所说的&#8220;路由器&#8221;&#65289;&#12290;<br>
<br>
<center><img src="../../images/2021/03/lgeICZCix4CsAg_VubQ00XSJr4eMmdOBSyINs3lbGOV25l1slX5K-6L_HHWWnj-sMQlNTVY0b01JzWL-g1zEn5y-VafJHEwLaJIwwqLEaP4I7JzxbMAk_3wvmnHO34NZYkb5rs98BtY" alt="不见图 请翻墙"><br>
&#65288;1973年的阿帕网&#65289;</center>
<br>
<center><img src="../../images/2021/03/miI68qcASC4oz00YtHW6Pv_O0nLK_BZ0PWAxs4J5x-yteT2ya0gkiheH_RCIkX6ZX_soaf2tPPWbXNOYqdhtNaNbLA5OJ3w5Ko47pwXK4hmCtKmHrBmvciP1JYnZCwvUvRqlAtGllG8" alt="不见图 请翻墙"><br>
&#65288;1977年的阿帕网&#65289;</center>
<br>
&#12288;&#12288;<b>第2阶段&#65306;动态全局路由表</b><br>
&#12288;&#12288;后来&#65292;&#8220;阿帕网/互联网&#8221;的规模猛增&#65292;路由器数量也跟着猛增&#65292;隔三差五都有新的路由器冒出来&#12290;再用&#8220;静态路由表&#8221;这种机制&#65292;&#65288;编辑路由表的&#65289;管理员会被活活累死&#12290;于是改用&#8220;动态路由表&#8221;&#65292;并引入某种&#8220;路由发现机制&#8221;&#12290;但&#8220;路由表&#8221;依然是&#12304;全局&#12305;滴&#12290;<br>
<br>
&#12288;&#12288;<b>第3阶段&#65306;动态分级路由表</b><br>
&#12288;&#12288;再到后来&#65292;全球的路由器越来越多&#65292;成千上万&#65292;再搞&#8220;全局路由表&#8221;已经不太现实了&#8212;&#8212;<br>
一方面&#65292;&#8220;全局路由表&#8221;越来越大&#65288;查询的速度就越来越慢&#65289;<br>
另一方面&#65292;由于互联网的流量越来越大&#65292;每来一个数据包都要查表&#65292;查询越来越频繁&#12290;<br>
&#12288;&#12288;于是&#65292;路由器开始吃不消了&#12290;为了解决困境&#65292;想出一个新招数&#65306;引入&#8220;分级路由&#8221;&#65288;hierarchical routing&#65289;&#12290;所谓的&#8220;分级路由&#8221;就是&#65306;把整个互联网分为多个大区域&#65292;每个大区域内部再分小区域&#65292;小区域内部再分小小区域 ...... 看到这里&#65292;熟悉&#8220;数据结构与算法&#8221;的同学就会意识到&#8212;&#8212;这相当于构造了一个&#12304;树状&#12305;层次结构&#12290;<br>
&#12288;&#12288;有了这个层次结构&#65292;每个路由器重点关注&#65306;自己所在的那个最小化区域里面的网络拓扑&#12290;如此一来&#65292;每个路由器的&#8220;路由表&#8221;都会大幅度减小&#12290;<br>
<br>
<center><img src="../../images/2021/03/29WAIkuNnd2KC88vhFr7UG1ozUqnYQzt6k4VDmra_7Fiqu4lG4WKzEskw12GCuZgL8VKGd7aXI3KIqyGWNX8gwSRf_HzY8rDaG2VzFU9dp9q-wWYN1xyUixlefPu_MLtugsWWVBZfkE" alt="不见图 请翻墙"><br>
&#65288;全局路由表 VS 分级路由表&#65289;</center>
<br>
<h3>&#9671;互联网的路由&#8212;&#8212;从&#8220;CAS&#8221;的角度看其健壮性</h3>
<br>
&#12288;&#12288;去年&#65288;2020&#65289;俺写了一篇博文&#12298;<a href="../../2020/04/Government-and-System-Robustness.html">&#8220;政治体制&#8221;与&#8220;系统健壮性&#8221;&#8212;&#8212;基于&#8220;复杂性科学&#8221;的思考</a>&#12299;&#65292;其中介绍了&#8220;CAS&#8221;&#65288;复杂自适应系统&#65289;的概念&#12290;互联网的路由机制&#65292;就是一个典型的 CAS&#12290;<br>
&#12288;&#12288;如果把互联网视作一个系统&#65292;每个公网上的路由器都是一个自适应的主体&#12290;假如某个地区的网络流量突然暴涨&#65292;骨干网路由器会自动分流&#65307;假如因为地震或战争&#65292;导致某个地区的骨干网路由器全部下线&#65292;周边地区的路由器也会自动避开这个区域 .....<br>
&#12288;&#12288;所有这些工作&#65292;&#12304;不需要&#12305;依靠任何最高指挥中枢&#65292;去进行协调&#12290;<br>
&#12288;&#12288;相反&#65292;如果互联网的路由系统中&#65292;设立了某种&#8220;中央委员会&#8221;进行实时调度&#65292;那互联网早就完蛋了&#65292;根本无法成长为今天这种规模&#12290;<br>
<br>
<h3>&#9671;网络层的两种交换技术&#8212;&#8212;电路交换&#65288;<a href="https://en.wikipedia.org/wiki/Circuit_switching" target="_blank" rel="nofollow">circuit switching</a>&#65289; VS 分组交换&#65288;<a href="https://en.wikipedia.org/wiki/Packet_switching" target="_blank" rel="nofollow">packet switching</a>&#65289;</h3>
<br>
&#12288;&#12288;&#65288;技术菜鸟可以跳过这个小节&#65289;<br>
&#12288;&#12288;前面聊&#8220;互联网诞生&#8221;&#65292;说到兰德公司的&#8220;Baran 方案&#8221;&#12290;该方案对当时的电信系统提出几大革命性的变化&#65292;其中之一就是&#8220;分组交换&#8221;技术&#65288;也称&#8220;数据包交换&#8221;or&#8220;封包交换&#8221;&#65289;&#12290;<br>
&#12288;&#12288;一般来说&#65292;网络层的设计有两种截然不同的风格&#65306;&#12304;电路交换 VS 分组交换&#12305;&#12290;有时候也分别称之为&#8220;有连接的网络层 VS 无连接的网络层&#8221;&#12290;此处所说的&#8220;连接&#8221;指的是某种&#8220;虚电路&#8221;&#65288;洋文叫做&#8220;<a href="https://en.wikipedia.org/wiki/Virtual_circuit" target="_blank" rel="nofollow">virtual circuit</a>&#8221;&#65292;简称 VC&#65289;&#12290;<br>
<br>
&#12288;&#12288;要理解&#8220;虚电路&#8221;&#65292;首先要从老式的电话系统说起&#12290;<br>
&#12288;&#12288;最早期的电话&#65292;既没有拨号盘也没有按键&#65292;全靠一张嘴&#12290;当你拿起电话&#65292;先告诉接线员你要打给谁&#65292;接线员会用一根跳接线&#65292;插入电话交换设备的某个插孔&#65292;从而把你的电话机与对方的电话机相连&#12290;于是建立了一条两人之间的电话通路&#65292;也就是&#8220;电路&#8221;&#12290;你可以把&#8220;接线员&#8221;想象成某种&#8220;人肉路由器&#8221; :)<br>
<br>
<center><img src="../../images/2021/03/Ry_GjLe2vTj2fr1dnvGbwn4O6JbFbaEYKPKQyP1UMNba0AKt85b_SmM_fZhlnhBePly-ByLsI3v_r978aUKRY4AAG54ws1yPZglIbOuXZOKvP3vqjvqNdX8MOk0L0CW2vhoGpnI-Jcc" alt="不见图 请翻墙"><br>
&#65288;1900年法国巴黎的电话交换局&#65292;可以看到接线员在操作电话交换设备&#65289;</center>
<br>
&#12288;&#12288;后来发明了&#8220;自动电话交换机&#8221;&#65292;导致&#8220;接线员&#8221;全体下岗&#12290;虽然自动化了&#65292;但原理还是一样&#8212;&#8212;当你在电话上拨了某人的号码&#65292;电话局的交换机会自动选择一条线路&#12290;只有当这条线路建立起来&#65292;对方的电话才会响&#12290;一旦双方开始通话&#65292;双方之间的语音都是通过这条线路传输&#12290;并且这条线路是独占的&#8212;&#8212;只要通话不挂断&#65292;这条线路就不会再分配给其他人使用&#12290;<br>
<br>
&#12288;&#12288;前面提到&#8220;互联网诞生的历史&#8221;&#65292;当时军方推动的&#8220;Baran 方案&#8221;被 AT&#65286;T 断然拒绝&#12290;因为这个方案完全颠覆了传统的电话系统&#8212;&#8212;<br>
颠覆之1&#65306;把&#8220;模拟信号&#8221;颠覆为&#8220;数字信号&#8221;&#65288;这点比较好理解&#65292;俺就不解释了&#65289;<br>
颠覆之2&#65306;把&#8220;星形拓扑&#8221;颠覆为&#8220;网状拓扑&#8221;&#65288;关于这点&#65292;前面的小节已经讨论了&#65289;<br>
颠覆之3&#65306;把&#8220;电路交换&#8221;颠覆为&#8220;分组交换&#8221;&#65288;这就是本小节的重点&#65289;<br>
<br>
&#12288;&#12288;为了帮大伙儿理解上述第3点&#65292;举个例子&#65306;<br>
&#12288;&#12288;假设主机 A 要向主机 B 发送一大坨数据&#12290;因为数据太多&#65292;肯定要分成好几坨小一点的&#65288;分成多个数据包&#65289;&#12290;如何把这些数据包发送给对方捏&#65311;<br>
<br>
&#12288;&#12288;<b>&#8220;电路交换&#8221;的实现方式</b><br>
在发送数据之前&#65292;要先建立连接通道&#65288;通过路由算法&#65292;找出 A &#65286; B 之间的某条通路&#65289;&#12290;这条通路就是所谓的&#8220;虚电路/VC&#8221;&#12290;一旦 VC 建立&#65292;每一个数据包都是从这条拓扑路径进行路由&#12290;<br>
<br>
&#12288;&#12288;<b>&#8220;分组交换&#8221;的实现方式</b><br>
在发送数据之前&#65292;&#12304;不需要&#12305;建立通道&#65292;让每个数据包独立进行路由&#12290;这种情况下&#65292;这几个数据包可能会走&#12304;不同的&#12305;拓扑路径&#12290;因此&#65292;数据包到达的顺序与发送的顺序&#12304;不一定&#12305;相同&#12290;接收方收到所有数据包之后&#65292;还要自己进行排序&#12290;<br>
&#12288;&#12288;维基百科上有一个 GIF 动画&#65288;<a href="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f6/Packet_Switching.gif/480px-Packet_Switching.gif" target="_blank" rel="nofollow">这个链接</a>&#65289;&#65292;比较直观地演示&#8220;分组交换/封包交换&#8221;的效果&#12290;由于这个动画稍微有点大&#65288;超过 1MB&#65289;&#65292;俺就不贴到博文中了&#12290;<br>
<br>
&#12288;&#12288;当时的电话系统主要承载语音传输&#65292;&#8220;电路交换&#8221;显然性能更高&#12290;那为啥 Baran 的设计要采用&#8220;分组交换&#8221;捏&#65311;俺又要再次提到&#12304;效率 VS 健壮性&#12305;之间的矛盾与均衡&#12290;<br>
&#12288;&#12288;对于&#8220;电路交换&#8221;&#65292;一旦建立连接&#65292;同一个连接的所有数据都走相同的路径&#65288;会经过完全相同的路由器&#65289;&#12290;也就是说&#65292;传输的过程中&#65292;如果某个路由器挂掉了&#65288;网络掉线 or 硬件当机 or 软件崩溃&#65289;&#12290;那么&#65292;该路由器正在处理的 N 个连接全都要报废&#12290;而&#8220;分组交换&#8221;则更加灵活&#8212;&#8212;即使某个路由器挂掉了&#65292;后续的数据包会自动转向另外的路由器&#65292;损失很小&#12290;<br>
&#12288;&#12288;&#8220;Baran 方案&#8221;之所以采用&#8220;分组交换&#8221;的设计&#65292;因为人家这个方案是提交给军方用来应对&#12304;全面核战争&#12305;滴&#65292;当然要考虑健壮性啦&#12290;<br>
<br>
&#12288;&#12288;话说这两种交换机制&#65292;各有很多支持者&#65292;并分裂为两大阵营&#65292;分别是&#65306;&#8220;电信阵营 VS 互联网阵营&#8221;&#12290;两大阵营的口水战持续了 N 年&#65292;都无法说服对方&#12290;到了后来设计 OSI 模型的时候&#65292;为了保持中立性与通用性&#65292;OSI 模型本身并没有强制要求网络层采用哪一种风格&#12290;<br>
&#12288;&#12288;经过几十年之后&#65292;咱们已经可以看出来&#65306;&#8220;互联网阵营&#8221;占据主导地位&#12290;如今&#65292;连电信系统都是架构在互联网之上&#12290;<br>
<br>
<br>
<h2>&#9733;网络层&#65306;具体实例</h2>
<br>
<h3>&#9671;网络层的&#12304;协议&#12305;</h3>
<br>
&#12288;&#12288;网络层的协议有很多&#12290;由于&#8220;互联网&#8221;已经成为全球的事实标准&#65292;因此俺只列出属于&#8220;互联网协议族&#8221;的那些&#8220;网络层协议&#8221;&#65306;<br>
IP 协议&#65288;含 <a href="https://en.wikipedia.org/wiki/IPv4" target="_blank" rel="nofollow">IPv4</a> &#65286; <a href="https://en.wikipedia.org/wiki/IPv6" target="_blank" rel="nofollow">IPv6</a>&#65289;<br>
<a href="https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol" target="_blank" rel="nofollow">ICMP</a><br>
<a href="https://en.wikipedia.org/wiki/Internet_Group_Management_Protocol" target="_blank" rel="nofollow">IGMP</a><br>
<a href="https://en.wikipedia.org/wiki/IPsec" target="_blank" rel="nofollow">IPSec</a><br>
......<br>
&#65288;考虑到篇幅&#65289;俺不可能具体细聊这些协议&#65292;只是贴出每个的维基百科链接&#65292;感兴趣的同学自己点进去看&#12290;<br>
&#12288;&#12288;对上述这些协议&#65292;最重要的当然是 IP 协议&#12290;如果你想要深入了解 IP 协议&#65292;可以参考如下这本书&#12290;关于 IP 协议的书&#65292;此书的影响力最大&#12290;这本书共3卷&#65292;通常只需看第1卷&#12290;<br>
&#12298;<a href="https://docs.google.com/document/d/1Fw2wSr-MgNm1d_M6F-rF1t_n3LwFWWBHrJt6vcYGta4/" target="_blank">TCP-IP 详解</a>&#12299;<br>
<br>
<h3>&#9671;网络层的&#12304;协议实现&#12305;</h3>
<br>
&#12288;&#12288;对于电脑主机&#65288;含移动设备&#65289;&#65292;网络层的协议实现通常包含在操作系统自带的网络模块中&#65288;也就是&#8220;操作系统协议栈&#8221;&#65289;&#12290;具体参见如下示意图&#12290;<br>
&#12288;&#12288;另外&#65292;还有一些专门的&#12304;3层&#12305;网络设备&#65292;也提供网络层的功能&#65288;参见本章节的后续小节&#65289;&#12290;<br>
<br>
<center><img src="../../images/2021/03/uYGaEvDYmziV-6EZ1AnRskoGpyKwxBcHgV5wgVtsDKmyP37OQgfX_zPYYeV3drFWBATFb95DYIwMPCgNApfg9Vtxrrpyvept6LNDQi0Vh3Fp6d31LFarI4ZjY1mSaQqP94HJaVQHBEQ" alt="不见图 请翻墙"><br>
&#65288;OSI 模型中&#65292;不同层次的协议实现&#65289;</center>
<br>
<h3>&#9671;IP 地址的格式及含义</h3>
<br>
&#12288;&#12288;当年设计阿帕网的时候&#65292;采用了&#12304;4字节&#12305;&#65288;32比特&#65289;来表示&#8220;网络层地址&#8221;&#65288;也就是 IP 地址&#65289;&#12290;<br>
&#12288;&#12288;&#8220;IP 地址&#8221;的含义很重要&#65292;俺有必要解释一下&#65306;<br>
&#12288;&#12288;咱们平时所说的 IP 地址&#65292;采用&#12304;点分十进制&#12305;来表示&#12290;就是把地址的4个字节&#65292;先翻译为十进制&#65292;然后每个字节用一个小数点分隔开&#65288;参见如下示意图&#65289;&#65306;<br>
<center><img src="../../images/2021/03/MCf0UTOAGLTbDJ5l46RlSHfidNm4PY7xqHrOBTP0P9OOneffxtC1B-VH_W2uBE7kCetsEMqTuLcS4niwj4MvqsXEA6QLeIvjTXQlGtBmgzL1d7VgrA5Na7YguV7OBKGzk9qvx_FrFHM" alt="不见图 请翻墙"><br>
&#65288;4字节 IP 地址&#65306;&#8220;二进制&#8221;与&#8220;点分十进制&#8221;的对照示意图&#65289;</center>
<br>
&#12288;&#12288;&#8220;IP 地址&#8221;的32比特&#65292;分为两部分&#65306;第1部分用来标识&#12304;子网&#12305;&#65292;第2部分用来标识该子网中的&#12304;主机&#12305;&#12290;<br>
&#12288;&#12288;这两部分各占用多少比特&#65292;是不确定的&#12290;在这种情况下&#65292;&#8220;操作系统协议栈&#8221;如何知道哪些比特标识&#8220;子网&#8221;&#65292;哪些比特标识&#8220;主机&#8221;捏&#65311;奥妙在于&#12304;子网掩码&#12305;&#12290;所以&#65292;大伙儿在给系统配置 IP 地址的时候&#65292;通常都需要再设置一个&#12304;子网掩码&#12305;&#65292;就这个用途&#12290;<br>
<br>
<h3>&#9671;IP 地址枯竭&#65292;及其解决方法</h3>
<br>
&#12288;&#12288;前一个小节提到&#65306;IP地址包含&#12304;4字节&#12305;&#65288;32比特&#65289;&#12290;因此&#65292;最多只能表示&#12304;2的32次方&#12305;&#65288;42亿左右&#65289;的不同地址&#12290;考虑到还有很多地址保留给特殊用途&#65292;实际可用地址远远不到42亿&#12290;<br>
&#12288;&#12288;到了如今&#65292;全球网民都已经几十亿了&#65292;IP 地址开始枯竭&#12290;咋办捏&#65311;为了解决这个问题&#65292;发展出若干技术手段&#12290;简单说一下最常见的几种手段&#65306;<br>
<br>
&#12288;&#12288;<b>IPv6</b><br>
&#12288;&#12288;名气最大&#65288;最多人知道&#65289;的技术手段&#65292;大概是 IPv6 了&#12290;这招想要一劳永逸地解决地址枯竭的问题&#65292;采用了16字节&#65288;128比特&#65289;来表示 IP 地址&#12290;<br>
&#12288;&#12288;设计 IPv6 的人自豪地宣称&#65306;即使给地球上的每一粒沙子分配一个 IPv6 地址&#65292;依然绰绰有余&#65288;确实没有吹牛&#65292;&#8220;2的128次方&#8221;是天文数字&#65289;&#12290;<br>
&#12288;&#12288;但 IPv6 的缺点在于&#65292;&#12304;无法&#12305;向下兼容原有的 IP 协议&#65288;原有的协议叫&#8220;IPv4&#8221;&#65289;&#12290;IPv6 的普及一直比较慢&#65292;这是主要原因&#12290;<br>
<br>
&#12288;&#12288;<b>代理服务器&#65288;proxy&#65289;</b><br>
&#12288;&#12288;一看到代理&#65292;很多人就想到翻墙&#12290;其实它也可以用来解决&#8220;地址枯竭&#8221;的问题&#12290;<br>
&#12288;&#12288;比如说&#65292;某个公司有100人&#65292;100台电脑&#12290;如果每台电脑都分配公网 IP 地址&#65292;就要消耗100个公网地址&#65288;太浪费啦&#65289;&#12290;<br>
&#12288;&#12288;可以只申请一个公网 IP&#65292;然后在内网搞一个代理服务器&#65292;公网 IP 分配给它&#65288;代理服务器有两个网卡&#65292;一个接内网&#65292;一个接公网&#65289;&#12290;然后在其它电脑上设置代理&#65292;指向这台代理服务器&#65292;就都可以上外网啦&#12290;<br>
&#12288;&#12288;&#65288;注&#65306;在本文的末尾有一个 <q style="background-color:#DDD;">&#9733;杂项</q> 的章节&#65292;会专门聊一下&#8220;代理&#8221;这个话题&#65289;<br>
<br>
&#12288;&#12288;<b><a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2" target="_blank" rel="nofollow">网络地址转换</a>&#65288;NAT&#65289;</b><br>
&#12288;&#12288;前面 proxy 那招有个缺点&#65306;内网的每台电脑里面的每个上网软件&#65292;都要单独设置代理&#12290;实在太麻烦啦&#65281;<br>
&#12288;&#12288;后来就发明了某种更牛逼的招数&#8212;&#8212;网络地址转换&#65288;洋文是&#8220;Network Address Translation&#8221;&#65292;简称 NAT&#65289;&#12290;<br>
&#12288;&#12288;用了这招&#65292;还是只要申请一个公网 IP&#65292;分配给内网的网关&#65288;网关有两个网卡&#65292;一个接内网&#65292;一个接公网&#65289;&#12290;然后在内网的网关配置 NAT 功能&#65292;自动就可以让内网的每台电脑访问外网&#12290;<br>
&#12288;&#12288;在<a href="../../2012/12/system-vm-5.html">这篇博文</a>&#65292;俺介绍了虚拟机的几种&#8220;网卡模式&#8221;&#65292;其中有一种模式叫做&#12304;NAT 模式&#12305;&#65292;就是指这个玩意儿&#12290;<br>
&#12288;&#12288;采用了 NAT 技术之后&#65292;可能会对某些应用软件&#65288;尤其是 P2P 类型的&#65289;造成兼容性问题&#65292;于是又发明了一些&#8220;NAT 穿透技术&#8221;&#65288;<a href="https://en.wikipedia.org/wiki/NAT_traversal" target="_blank" rel="nofollow">NAT traversal</a>&#65289;&#12290;这类技术有好几种&#65292;如果有空的话&#65292;俺会单独写教程介绍&#12290;<br>
<br>
&#12288;&#12288;<b>其它解决方法</b><br>
&#12288;&#12288;关于&#8220;IPv4 地址空间耗尽&#8221;&#65292;解决方法肯定不止上面这几招&#12290;限于篇幅&#65292;就此打住&#12290;更多的讨论参见维基百科的&#8220;<a href="https://en.wikipedia.org/wiki/IPv4_address_exhaustion" target="_blank" rel="nofollow">这个链接</a>&#8221;&#12290;<br>
<br>
<h3>&#9671;网络层相关的&#12304;网络设备&#12305;</h3>
<br>
&#12288;&#12288;<b><a href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E5%99%A8" target="_blank" rel="nofollow">路由器</a>&#65288;router&#65289;</b><br>
&#12288;&#12288;&#65288;前面章节聊&#8220;路由原理&#8221;的时候&#65292;已经介绍过它&#65307;这里就不再浪费口水啦&#65289;<br>
<br>
&#12288;&#12288;<b>3层交换机&#65288;Layer 3 switching&#65289;</b><br>
&#12288;&#12288;&#8220;3层交换机&#8221;是在&#8220;2层交换机&#8221;的基础上&#65292;增加了对网络层的处理&#12290;因此&#65292;它可以做到类似路由器的效果&#8212;&#8212;在几个子网之间转发数据&#12290;<br>
&#12288;&#12288;与路由器的差别在于&#8212;&#8212;&#8220;3层交换机&#8221;链接的几个子网是&#12304;同种&#12305;网络&#65307;而路由器可以连接&#12304;异种&#12305;网络&#12290;<br>
&#12288;&#12288;从上面这句话看&#65292;&#8220;3层交换机&#8221;的能力显然不如&#8220;路由器&#8221;&#12290;既然已经有&#8220;路由器&#8221;&#65292;为啥还要发明&#8220;3层交换机&#8221;捏&#65311;这就要说到&#12304;单臂路由器&#12305;的弊端&#12290;<br>
&#12288;&#12288;对于企业内网的&#8220;2层交换机&#8221;&#65292;通常都支持 VLAN 功能&#12290;通俗地说&#65306;可以在交换机中划分多个&#12304;虚拟子网&#12305;&#12290;其实这些子网的中所有的电脑&#65292;都还是接入这台交换机&#65292;只不过这些子网配置了不同的网络地址&#12290;对于同一个 VLAN 内部的通讯&#65292;&#8220;2层交换机&#8221;自己就可以搞定&#65288;只需要用到2层协议&#65289;&#65307;但对于&#12304;跨&#12305;VLAN 主机之间的通讯&#65292;&#8220;2层交换机&#8221;就没戏啦&#65288;它没有路由功能&#65289;&#12290;因此&#65292;就必须在它旁边外加一个路由器&#65292;形成如下拓扑结构&#12290;在这个拓扑中&#65292;路由器只与单个设备&#65288;2层交换机&#65289;相连&#65292;所以称之为&#8220;单臂&#8221;&#12290;<br>
&#12288;&#12288;请注意&#65306;如下示意图只画了两台电脑&#65292;位于两个 VLAN&#12290;实际上可能有很多个 VLAN&#65292;每个里面有几十台电脑&#12290;于是&#65292;交换机与路由器之间的传输通道就会成为瓶颈&#8212;&#8212;&#12304;跨&#12305;VLAN 的任意两台电脑通讯&#65292;数据包都要到路由器那里兜一圈&#12290;为了消除这种瓶颈&#65292;才发明了&#8220;3层交换机&#8221;&#8212;&#8212;把路由功能直接集成到交换机内部&#12290;<br>
<br>
<center><img src="../../images/2021/03/FTo8x8w2DwhPaz10fDJ2LdwywSaaPLlciSaH4wg0HY_sHKT0MHvDN6k2ZxAvyzojuzGpklzg7hBV1iolR40_1_LaxIqYeOa1lo0IWQrb0_cpJzoGQbdZCu7fPcgieH897MuEPwlA5Gw" alt="不见图 请翻墙"><br>
&#65288;&#8220;单臂路由器&#8221;的拓扑结构&#65289;</center>
<br>
&#12288;&#12288;<b><a href="https://zh.wikipedia.org/wiki/%E7%84%A1%E7%B7%9A%E6%8E%A5%E5%85%A5%E9%BB%9E" target="_blank" rel="nofollow">无线热点</a>&#65288;Wireless Access Point&#65289;</b><br>
&#12288;&#12288;&#8220;无线热点&#8221;通常用来提供无线接入&#65292;使得某个&#12304;无线&#12305;设备能接入到某个&#12304;有线&#12305;网络中&#12290;一般来说&#65292;热点都内置了路由功能&#65292;那么它就是&#8220;无线路由器&#8221;&#65292;对应到&#8220;3层&#8221;&#65288;网络层&#65289;&#12290;反之&#65292;如果没有路由功能&#65292;它就是&#8220;网桥&#8221;&#65292;属于&#8220;2层&#8221;&#65288;链路层&#65289;&#12290;<br>
<br>
<h3>&#9671;网络层相关的&#12304;软件工具&#12305;</h3>
<br>
&#12288;&#12288;<b><a href="https://en.wikipedia.org/wiki/Ping_(networking_utility)" target="_blank" rel="nofollow">ping</a></b><br>
&#12288;&#12288;这个命令&#65292;很多人应该都知道&#12290;早在 Win9x 就有这个命令了&#12290;它使用&#65288;网络层的&#65289;ICMP 协议来测试某个远程主机是否可达&#12290;<br>
&#12288;&#12288;提醒一下&#65306;<br>
&#12288;&#12288;如果 ping 命令显示某个 IP 地址不可达&#65292;有很多种情况&#12290;比如说&#65306;<br>
<blockquote style="background-color:#DDD;">
这个 IP 地址对应的主机已经关机<br>
这个 IP 地址对应的主机已经断线<br>
这个 IP 地址对应的主机拒绝响应 ICMP 协议<br>
从你本机到这个 IP 地址之间&#65292;有某个防火墙拦截了 ICMP 协议<br>
......</blockquote>
<br>
&#12288;&#12288;<b><a href="https://en.wikipedia.org/wiki/Traceroute" target="_blank" rel="nofollow">traceroute</a></b><br>
&#12288;&#12288;这是一个通用的工具&#65292;用来测试路由&#12290;很早以前的 Windows 就已经内置了它&#65292;命令是 <code>tracert</code>&#12290;在 POSIX&#65288;Linux&#65286;UNIX&#65289;上通常叫 <code>traceroute</code><br>
&#12288;&#12288;你可以用这个命令&#65292;测试你本机与互联网另一台主机之间的路由&#65288;也就是&#65306;从你本机到对方主机&#65292;要经过哪些路由器&#65289;<br>
<br>
<br>
<h2>&#9733;传输层&#65306;概述</h2>
<br>
<h3>&#9671;传输层的必要性</h3>
<br>
&#12288;&#12288;<b>屏蔽&#8220;有连接 or 无连接&#8221;的差异</b><br>
&#12288;&#12288;&#65288;上一个章节提到&#65289;网络层本身已经屏蔽了&#12304;异种网络&#12305;的差异&#65288;比如&#8220;以太网&#12289;ATM&#12289;帧中继&#8221;之间的差异&#65289;&#65292;而且网络层也屏蔽了路由的细节&#12290;但网络层本身还有一个差异&#65292;也就是网络层的两种交换技术&#65306;电路交换&#65288;有连接&#65289; VS 分组交换&#65288;无连接&#65289;&#12290;<br>
&#12288;&#12288;前面章节也提到了&#65306;上述两种交换技术各有很多支持者&#65292;并分裂为两大阵营&#12290;当年设计 OSI 模型的时候&#65292;为了保持中立性与通用性&#65292;并没有强制规定&#8220;网络层&#8221;必须采用何种交换机制&#12290;<br>
&#12288;&#12288;对于开发网络软件的程序员来说&#65292;当然不想操心&#8220;网络层用的是哪一种交换机制&#8221;&#12290;因此&#65292;需要对网络层的上述差异再加一个抽象层&#65288;也就是&#8220;传输层&#8221;&#65289;&#12290;<br>
<br>
&#12288;&#12288;<b>从&#8220;主机&#8221;到&#8220;进程&#8221;</b><br>
&#12288;&#12288;前面介绍的&#8220;网络层&#8221;&#65292;其设计是面向主机&#65288;电脑&#65289;&#12290;&#8220;网络层地址&#8221;也就是某个主机的地址&#12290;<br>
&#12288;&#12288;而&#8220;传输层&#8221;是面向&#12304;进程&#12305;滴&#65281;因为传输层要提供给&#12304;网络软件&#12305;使用&#65292;而网络软件打交道的对象是&#12304;另一个网络软件&#12305;&#12290;因此&#65292;传输层必须在&#8220;网络层地址&#8221;的基础上&#65292;再引入某种新的标识&#65292;用来区分同一台主机上的不同&#12304;进程&#12305;&#12290;<br>
<br>
<h3>&#9671;传输层的特殊性</h3>
<br>
&#12288;&#12288;在 OSI 7层模型中&#65292;传输层正好居中&#12290;这是一个很特殊的位置&#12290;<br>
&#12288;&#12288;OSI 模型最下面3层&#65292;与&#12304;网络设备&#12305;比较密切&#12290;这里面所说的&#8220;网络设备&#8221;&#65292;既包括那些独立的主机&#65288;比如&#8220;路由器&#12289;交换机&#12289;等&#8221;&#65289;&#65292;也包括电脑上的硬件&#65288;比如&#8220;网卡&#8221;&#65289;&#12290;<br>
&#12288;&#12288;OSI 模型最上面3层&#65292;与&#12304;网络软件&#12305;比较密切&#65288;或者说&#65292;与&#8220;用户的业务逻辑&#8221;比较密切&#65289;&#12290;<br>
&#12288;&#12288;而中间的传输层&#65292;正好是承上启下&#12290;对于开发应用软件的程序猿/程序媛&#65292;&#8220;传输层&#8221;是他们能感知的最低一层&#12290;<br>
<br>
<h3>&#9671;传输层的&#12304;端口&#12305;</h3>
<br>
&#12288;&#12288;刚才谈&#8220;传输层的必要性&#8221;&#65292;提到说&#8212;&#8212;&#8220;网络层地址&#8221;只能标识&#12304;主机&#12305;&#65292;而传输层必须要能标识&#12304;进程&#12305;&#12290;为了达到这个目的&#65292;于是就引入了&#8220;传输层端口&#8221;这个概念&#65288;为了打字省力&#65292;后续讨论简称为&#8220;端口&#8221;&#65289;&#12290;<br>
&#12288;&#12288;在 OSI 模型中&#65292;&#8220;端口&#8221;的官方称呼是&#8220;传输服务访问点&#8221;&#65288;洋文缩写 TSAP&#65289;&#12290;但是作为程序员&#65292;俺已经习惯于&#8220;端口&#8221;这个称呼&#12290;后续介绍依然用&#8220;端口&#8221;一词&#12290;<br>
&#12288;&#12288;当程序员使用传输层提供的 API 开发网络软件时&#65292;通常把&#8220;端口&#8221;与&#8220;网络地址&#8221;一起使用&#65288;构成&#8220;二元组&#8221;&#65289;&#65292;就可以定位到某个主机上的某个进程&#12290;<br>
<br>
<br>
<h2>&#9733;传输层&#65306;具体实例</h2>
<br>
<h3>&#9671;传输层的&#12304;协议&#12305;</h3>
<br>
&#12288;&#12288;为了让程序员可以更爽地使用传输层来开发网络软件&#65292;传输层既要提供&#8220;有连接&#8221;的风格&#65292;也要提供&#8220;无连接&#8221;的风格&#12290;关于这两种风格的对比&#65292;前面已经聊过&#65292;这里不再浪费口水&#12290;<br>
&#12288;&#12288;具体到&#8220;互联网协议族&#8221;&#65292;有两个主要的传输层实现&#65292;分别是 TCP &#65286; UDP&#65288;前者是&#8220;有连接&#8221;&#65292;后者是&#8220;无连接&#8221;&#65289;&#12290;<br>
&#12288;&#12288;除了 TCP &#65286; UDP&#65292;&#8220;互联网协议族&#8221;还提供了其它一些传输层协议&#12290;因为比较冷门&#65292;俺就不介绍啦&#12290;<br>
<br>
<h3>&#9671;传输层的&#12304;协议实现&#12305;</h3>
<br>
&#12288;&#12288;对于电脑主机&#65288;含移动设备&#65289;&#65292;传输层的协议实现通常包含在操作系统自带的网络模块中&#65288;也就是&#8220;操作系统协议栈&#8221;&#65289;&#12290;具体参见如下示意图&#12290;<br>
&#12288;&#12288;另外&#65292;还有一些专门的&#12304;4层&#12305;网络设备&#65292;也提供传输层的功能&#65288;参见后续的小节&#65289;&#12290;<br>
<br>
<center><img src="../../images/2021/03/uYGaEvDYmziV-6EZ1AnRskoGpyKwxBcHgV5wgVtsDKmyP37OQgfX_zPYYeV3drFWBATFb95DYIwMPCgNApfg9Vtxrrpyvept6LNDQi0Vh3Fp6d31LFarI4ZjY1mSaQqP94HJaVQHBEQ" alt="不见图 请翻墙"><br>
&#65288;OSI 模型中&#65292;不同层次的协议实现&#65289;</center>
<br>
<h3>&#9671;套接字&#65288;socket API&#65289;</h3>
<br>
&#12288;&#12288;前面说了&#65306;传输层是面向程序员&#65288;让他们可以更方便地开发网络软件&#65289;&#12290;因此&#65292;就需要提供一些封装传输层的&#12304;库&#12305;&#65288;API&#65289;&#12290;程序员只需要调用这些&#12304;库&#12305;&#65292;就可以使用传输层的协议进行通讯啦&#12290;<br>
&#12288;&#12288;影响力最大的传输层封装库&#65292;当然是 socket API&#12290;它来自加州大学伯克利分校&#12290;<br>
&#12288;&#12288;在互联网诞生初期&#65292;伯克利分校开发了一个 UNIX 操作系统的的变种&#65292;叫做&#8220;伯克利 UNIX 发行版&#8221;&#65288;BSD Unix&#65289;&#65292;也就是如今 BSD 操作系统的前身&#12290;伯克利发行版内置了一套用来进行网络编程的 API&#65292;当时叫做&#8220;伯克利套接字&#8221;&#65288;<a href="https://en.wikipedia.org/wiki/Berkeley_sockets" target="_blank" rel="nofollow">Berkeley sockets</a>&#65289;&#12290;由于这套 API 用起来很方便&#65292;很多其它的 UNIX 变种也移植了这套 API&#65292;于是就逐渐成了业界的事实标准&#12290;到了上世纪90年代&#65292;Windows &#65286; Linux 也都提供了这套 API&#12290;<br>
&#12288;&#12288;由于大部分读者不是程序员&#65292;&#8220;套接字&#8221;这个话题就到此为止&#12290;如果你是个程序员&#65292;并且对网络编程感兴趣&#65292;可以参考<a href="https://github.com/programthink/books" target="_blank">俺的电子书清单</a>&#65292;其中有一个分类目录是&#12304;IT 类 / 软件开发 / 网络相关&#12305;&#12290;<br>
<br>
<h3>&#9671;传输层相关的&#12304;网络设备&#12305;</h3>
<br>
&#12288;&#12288;<b>4层交换机&#65288;Layer 4 switching&#65289;</b><br>
&#12288;&#12288;前面已经介绍了&#8220;3层交换机&#8221;&#65292;&#8220;4层交换机&#8221;是其进一步的改良&#65292;可以识别传输层的协议&#65292;获取 TCP or UDP 的端口号&#12290;<br>
&#12288;&#12288;有了这个能力&#65292;网管就可以在这种交换机上配置一些管理策略&#12290;比如说&#65306;&#65288;根据传输层端口号&#65289;过滤掉某种流量&#65292;或者对某种流量设置转发的优先级&#12290;<br>
<br>
&#12288;&#12288;<b>状态防火墙&#65288;<a href="https://en.wikipedia.org/wiki/Stateful_firewall" target="_blank" rel="nofollow">stateful firewall</a>&#65289;</b><br>
&#12288;&#12288;网络防火墙分好几种&#65292;大部分属于这种&#12290;它能完全处理 TCP 协议的状态&#65292;显然它属于&#8220;4层&#8221;&#65288;传输层&#65289;&#12290;<br>
<br>
<h3>&#9671;传输层相关的&#12304;软件工具&#12305;</h3>
<br>
&#12288;&#12288;<b><a href="https://en.wikipedia.org/wiki/Netcat" target="_blank" rel="nofollow">netcat</a> 家族</b>&#8212;&#8212;传输层的&#8220;瑞士军刀&#8221;<br>
&#12288;&#12288;关于 netcat&#65292;俺已经写过一篇比较详细的教程&#65306;&#12298;<a href="../../2019/09/Netcat-Tricks.html">扫盲 netcat&#65288;网猫&#65289;的 N 种用法&#8212;&#8212;从&#8220;网络诊断&#8221;到&#8220;系统入侵&#8221;</a>&#12299;&#12290;看完这篇教程&#65292;你肯定能体会它功能的强大&#8212;&#8212;很多与 TCP/UDP 相关的事情&#65292;都可以用 netcat 搞定&#12290;<br>
&#12288;&#12288;另外&#65292;netcat 还有很多衍生品&#65288;衍生的开源项目&#65289;&#65292;构成一个丰富的 netcat 家族&#12290;在上述教程也有介绍&#12290;<br>
<br>
&#12288;&#12288;<b>netstat &#65286; ss</b><br>
&#12288;&#12288;Windows 和 POSIX&#65288;Linux&#65286;UNIX&#65289;都有一个 <code>netstat</code> 命令&#65292;可以查看当前系统的 TCP/UDP 状态&#65288;包括当前系统开启了哪些监听端口&#65289;&#12290;<br>
&#12288;&#12288;另外&#65292;Linux 上还有一个 <code>ss</code> 命令&#65292;功能更强&#65288;但这个命令在 Windows 上默认没有&#65289;<br>
<br>
&#12288;&#12288;<b><a href="https://en.wikipedia.org/wiki/Nmap" target="_blank" rel="nofollow">nmap</a></b><br>
&#12288;&#12288;这是最著名的开源的扫描器&#65292;可以扫描远程主机监听了哪些传输层端口&#65288;注&#65306;前面提到的&#8220;netcat 家族&#8221;也可以干这事儿&#65289;<br>
&#12288;&#12288;<code>nmap</code> 的功能很强&#65292;&#8220;端口扫描&#8221;只是其功能之一&#12290;<br>
<br>
<br>
<h2>&#9733;业务层&#65288;OSI 上三层&#65289;&#65306;概述</h2>
<br>
&#12288;&#12288;一不小心&#65292;这篇教程已经写了这么长&#12290;为了照顾那些有&#8220;阅读障碍&#8221;的读者&#65292;俺要稍微控制一下篇幅&#65292;就把 OSI 的&#12304;上三层&#12305;合在一起讨论&#12290;<br>
&#12288;&#12288;前面的章节说过&#65306;&#12304;上三层&#12305;更接近于&#8220;网络软件&#8221;&#65292;对应的是应用软件的业务逻辑&#65292;因此俺统称为&#8220;业务层&#8221;&#12290;<br>
&#12288;&#12288;注&#65306;有些书&#65288;比如&#12298;<a href="https://docs.google.com/document/d/1XQwaAMzuGuvmq5fCiTDMrh_pTUpCHJJ5C17btTv8kdE/" target="_blank">计算机网络</a>&#12299;&#65289;会把 OSI 的上三层统称为&#8220;应用层&#8221;&#12290;由于 OSI 模型中本来就有一个&#8220;应用层&#8221;&#65292;俺认为这样容易搞混&#65288;尤其不利于技术菜鸟&#65289;&#65292;所以另外起了一个&#8220;业务层&#8221;的名称&#12290;<br>
<br>
<h3>&#9671;业务层的必要性</h3>
<br>
&#12288;&#12288;业务层显然是必要滴&#12290;因为传输层位于操作系统&#65292;它不可能去了解网络软件的业务逻辑&#12290;为了让网络软件能够相互通讯&#65292;肯定要在传输层之上再定义更高层的协议&#12290;<br>
&#12288;&#12288;问题在于&#65306;网络软件千奇百怪&#65292;其业务逻辑各不相同&#65292;因此&#65292;&#8220;业务层如何设计&#8221;&#65292;&#12304;无&#12305;一定之规&#12290;有些软件只用一个协议来搞定所有的业务逻辑&#65288;只有一层&#65289;&#65307;有些软件会参考 OSI&#65292;把业务逻辑的协议分为三层&#65307;还有些软件可能会分出更多的层次&#12290;<br>
&#12288;&#12288;再强调一下&#65306;业务层的协议如何分层&#65292;完全看具体的业务逻辑&#65292;不要生搬硬套任何现有的参考模型&#12290;<br>
<br>
<h3>&#9671;会话层 &#65286; 表示层 &#65286; 应用层</h3>
<br>
&#12288;&#12288;对于大部分读者来说&#65292;&#12304;没必要&#12305;花时间去了解 OSI 最上面三层之间的区别&#12290;你只需把最上面三层视作&#12304;一坨&#12305;&#8212;&#8212;他们都是与网络软件的业务逻辑密切相关滴&#12290;<br>
&#12288;&#12288;那么&#65292;哪些人需要详细了解&#8220;这三层的差异&#8221;捏&#65311;<br>
&#12288;&#12288;如果你是个程序员&#65292;并且你正好是开发&#12304;网络&#12305;软件&#65292;俺建议你了解一下 OSI 模型的最上面三层&#65292;有助于你更深刻地思考某些网络协议的设计&#12290;所谓的&#8220;更深刻&#8221;指的是&#65306;你不能光停留在 WHAT 层面&#65292;要提升到 HOW 甚至 WHY 层面&#65288;参见&#12298;<a href="../../2009/02/study-technology-in-three-steps.html">学习技术的三部曲&#65306;WHAT&#12289;HOW&#12289;WHY</a>&#12299;&#65289;<br>
<br>
<br>
<h2>&#9733;业务层&#65288;OSI 上三层&#65289;&#65306;具体实例</h2>
<br>
<h3>&#9671;业务层的&#12304;协议&#12305;</h3>
<br>
&#12288;&#12288;业务层的协议非常多&#12290;即使光把各种协议的名称列出来&#65292;也很费劲&#12290;所以俺就偷懒一下&#65292;只点评几个特别重要的协议&#12290;<br>
<br>
&#12288;&#12288;<b>HTTP 协议</b><br>
&#12288;&#12288;如果让俺评选最重要的业务层协议&#65292;俺首推 HTTP 协议&#12290;互联网的普及推动了 Web 的普及&#65292;而 Web 的普及使得 HTTP 成为信息时代的重要支柱&#12290;当你上网的时候&#65292;你看到的网页&#65288;HTML 页面&#65289;就是通过 HTTP 协议传输到你的浏览器上&#12290;<br>
&#12288;&#12288;如今 HTTP 已经不仅仅用来展示网页&#65292;还有很多业务层的协议是建立在 HTTP 协议之上&#12290;比如说&#65306;如果你用 RSS 订阅俺的博客&#65292;RSS 阅读器需要调用 blogspot 博客平台提供的 RSS 接口&#65292;这些 RSS 接口就是基于 HTTP 协议传输滴&#12290;<br>
&#12288;&#12288;考虑到本文的篇幅&#65292;俺不可能在这里细聊 HTTP 协议的规格&#65292;有兴趣的同学可以去看&#12298;<a href="https://docs.google.com/document/d/1TgujhFUzyVlf1W5e48lSMTIwJuCTElvXw2LgQ_Ng0Cs/" target="_blank">HTTP 权威指南</a>&#12299;这本书&#12290;<br>
<br>
&#12288;&#12288;<b>SSL/TLS 协议</b><br>
&#12288;&#12288;最早的 HTTP 协议是&#12304;明文&#12305;滴&#65307;为了强化安全性&#65292;后来又设计了 SSL 协议&#65292;用来&#12304;加密&#12305;HTTP 流量&#65307;再后来&#65292;SSL 升级为 TLS&#65288;这俩是同义词&#65289;&#12290;如今经常看到的 HTTPS 相当于&#8220;HTTP over TLS&#8221;&#12290;<br>
&#12288;&#12288;SSL/TLS 设计得比较优雅&#65288;很灵活&#65289;&#65292;使得其它业务层的协议可以很方便地架构在 SSL/TLS 之上&#12290;这样的好处是&#65306;其它协议就不用自己再设计一套加密机制&#65286;认证机制&#12290;<br>
&#12288;&#12288;SSL/TLS 对于安全性很重要&#65292;因此俺专门写了一个系列教程&#65288;如下&#65289;&#65292;详细介绍该协议的技术细节&#12290;<br>
&#12298;<a href="../../2014/11/https-ssl-tls-0.html">扫盲 HTTPS 和 SSL&#65295;TLS 协议</a>&#12299;&#65288;系列&#65289;<br>
<br>
&#12288;&#12288;<b>域名相关的协议&#65288;DNS 及其它&#65289;</b><br>
&#12288;&#12288;域名相关的协议&#65292;也很重要&#12290;因为域名系统是整个互联网的基础设施&#12290;最早的域名查询协议是&#8220;DNS 协议&#8221;&#65292;由于这个协议&#12304;没有&#12305;加密&#65292;导致了一些安全隐患&#12290;比如 GFW 就利用 DNS 的这个弱点&#65292;搞&#8220;域名污染/域名投毒&#8221;&#12290;因此&#65292;后来又设计了一系列新的域名协议&#65292;引入了加密的机制&#12290;<br>
&#12288;&#12288;关于这些协议的扫盲教程&#65292;可以参考如下几篇博文&#65306;<br>
&#12298;<a href="../../2014/01/dns.html">扫盲 DNS 原理&#65292;兼谈&#8220;域名劫持&#8221;和&#8220;域名欺骗&#65295;域名污染&#8221;</a>&#12299;<br>
&#12298;<a href="../../2018/10/Comparison-of-DNS-Protocols.html">对比4种强化域名安全的协议&#8212;&#8212;DNSSEC&#65292;DNSCrypt&#65292;DNS over TLS&#65292;DNS over HTTPS</a>&#12299;<br>
<br>
<h3>&#9671;业务层相关的&#12304;网络设备&#12305;</h3>
<br>
&#12288;&#12288;<b>应用层防火墙&#65288;<a href="https://en.wikipedia.org/wiki/Application_firewall" target="_blank" rel="nofollow">application firewall</a>&#65289;</b><br>
&#12288;&#12288;前面提到了&#65306;大多数网络防火墙处于4层&#65288;状态防火墙&#65289;&#65292;另外还有少数处于7层&#65292;也就是&#8220;应用层防火墙&#8221;&#65288;有时候也称之为&#8220;7层防火墙&#8221;&#65289;&#12290;<br>
&#12288;&#12288;一般来说&#65292;这类防火墙具备了&#12304;深度包检测&#12305;&#65288;deep packet inspection&#65292;简称 DPI&#65289;的能力&#65292;可以分析应用层协议的&#12304;内容&#12305;&#12290;<br>
&#12288;&#12288;简单说一下&#8220;深度包检测&#8221;&#65306;<br>
&#12288;&#12288;如果某个网络设备&#65292;仅仅分析&#8220;应用层协议&#8221;本身&#65292;它还&#12304;不够格&#12305;称之为 DPI&#12290;为了做到 DPI&#65292;还要能理解应用层协议所承载的&#12304;内容&#12305;&#12290;<br>
&#12288;&#12288;比如说&#65306;某人通过&#12304;明文&#12305;的 HTTP 协议从网上下载了一个 zip 压缩包&#12290;对于这个下载行为&#65292;那些做得好的 DPI 设备不光能识别出&#8220;HTTP 协议的内容是 ZIP 压缩包&#8221;&#65292;而且还能从 ZIP 压缩包中提取出里面的文件&#12290;<br>
<br>
&#12288;&#12288;<b>入侵检测&#65288;<a href="https://en.wikipedia.org/wiki/Intrusion_detection_system" target="_blank" rel="nofollow">intrusion detection system</a>&#65289;</b><br>
&#12288;&#12288;一般来说&#65292;&#8220;入侵检测&#8221;如果不加定语&#65292;通常指&#8220;&#12304;网络&#12305;入侵检测&#8221;&#65288;洋文叫 NIDS&#65289;&#65307;另外还有一种&#8220;&#12304;主机&#12305;入侵检测&#8221;&#65288;洋文叫 HIDS&#65289;&#12290;HIDS 与本文无关&#12290;<br>
&#12288;&#12288;&#8220;入侵检测&#8221;是一种网络安全设备&#65292;它通过嗅探&#65288;sniffer&#65289;的方式抓取网上的数据包&#65292;然后进行分析&#65292;尝试发现网络中是否存在黑客/骇客的入侵的行为&#12290;故名&#8220;入侵检测&#8221;&#12290;<br>
&#12288;&#12288;由于 IDS 需要理解&#12304;应用层&#12305;&#65288;7层&#65289;的内容&#65292;因此它与&#8220;应用层防火墙&#8221;有个共同点&#65292;需要具备某种程度的 DPI&#65288;深度包检测&#65289;能力&#12290;它俩的一大差异是&#12304;部署方式&#12305;&#12290;<br>
&#12288;&#12288;考虑到很多读者是 IT 外行&#65292;简单说一下&#8220;旁路部署&#8221;&#8212;&#8212;<br>
如果你学过中学物理&#65292;应该知道电路有&#8220;串联 &#65286; 并联&#8221;&#12290;所谓的&#8220;旁路部署&#8221;类似于电路中的&#12304;并联&#12305;&#12290;通俗地说&#65306;IDS 是&#12304;并联&#12305;部署&#65292;防火墙是&#12304;串联&#12305;部署&#12290;<br>
<br>
&#12288;&#12288;<b>GFW&#65288;Great Firewall&#65289;</b><br>
&#12288;&#12288;本博客已经写了很多翻墙教程&#65292;大伙儿肯定都知道 GFW 了&#12290;<br>
&#12288;&#12288;由于&#8220;Great Firewall&#8221;中有&#8220;Firewall&#8221;字样&#65292;很多天朝网民&#12304;误以为&#12305;GFW 是防火墙&#65292;其实不然&#65281;GFW 本质上就是 IDS&#8212;&#8212;其部署方式类似于 IDS&#65288;旁路部署&#65289;&#65292;其工作方式有很大一部分也类似于 IDS&#65288;当然啦&#65292;GFW 的功能比 IDS 更多&#65289;&#12290;<br>
&#12288;&#12288;大约七八年前&#65292;就有热心读者建议俺写一篇技术博文&#65292;介绍 GFW 的工作原理&#12290;由于俺比较懒&#65292;拖到今年&#65288;2021&#65289;都没动手&#65292;很惭愧 :(<br>
<br>
<br>
<h2>&#9733;杂项</h2>
<br>
&#12288;&#12288;有些概念&#65292;并不属于某个特定的层次&#65292;单独放到这个章节&#12290;<br>
<br>
<h3>&#9671;VPN&#65288;<a href="https://en.wikipedia.org/wiki/Virtual_private_network" target="_blank" rel="nofollow">virtual private network</a>&#65289;</h3>
<br>
&#12288;&#12288;咱们天朝的网民使用 VPN&#65292;一多半是为了翻墙&#12290;其实 VPN 的本意&#65288;如其名称所示&#65289;是为了提供某种虚拟化的私有的网络&#65292;让身处异地的多个人&#65292;可以用 VPN 构建出一个虚拟的内网&#65292;从而能在这个内网中协同工作&#12290;<br>
&#12288;&#12288;VPN 的类型很多&#65292;使用的技术也各不相同&#65292;因此 VPN 对应的 OSI 层次很宽&#65288;&#8220;1层&#8221;到&#8220;6层&#8221;&#65289;&#12290;俺到维基百科剽窃了如下这张图&#65292;让你见识一下 VPN 的多样性&#12290;<br>
<br>
<center><img src="../../images/2021/03/qXbaBYZBvZ5k6gn4mp2M0dCYFW1rK_HR3JTCRYoWpGyNo9AZ6i90LgQzZgvL0OqImrf6j5FNAbDQDHG5k9I4iHVsm7FCSSHYhCV0yKJsz5vAH9Fil_4ZxclOoHSjlUH2aLA8Gv3hMcU" alt="不见图 请翻墙"><br>
&#65288;名目繁多的 VPN&#65292;分类示意图&#65289;</center>
<br>
<h3>&#9671;代理&#65288;proxy&#65289;</h3>
<br>
&#12288;&#12288;那些经常翻墙的同学&#65292;对&#8220;代理&#8221;应该都很熟悉了&#12290;&#8220;代理&#8221;与 VPN 类似&#65292;一开始并不是用来翻墙滴&#65292;&#8220;翻墙&#8221;只是这俩的副业&#12290;<br>
<br>
&#12288;&#12288;<b>代理服务器&#65288;proxy server&#65289;</b><br>
&#12288;&#12288;&#8220;代理服务器&#8221;部署在&#8220;客户端 &#65286; 服务端&#8221;之间&#65292;起到某种&#8220;中介&#8221;的作用&#12290;&#8220;代理服务器&#8221;的类型有很多&#65292;干的事情各不相同&#12290;<br>
<br>
<center><img src="../../images/2021/03/wklKf5goUVXTzmjccmfjIRpKKxZd-9vhT_0HMy3KknjAU7Oxj0GPgC7jjjO0BAfl6f-fapaBgHSp0mtsE1sS6ZyypE-ESB4idMi-ReKKU17Z1k_oVKupiOQcX3uQTlfU_P0VjoiZnG4" alt="不见图 请翻墙"><br>
&#65288;&#8220;代理服务器&#8221;的简单示意图&#65289;</center>
<br>
&#12288;&#12288;<b>代理客户端&#65288;proxy client&#65289;</b><br>
&#12288;&#12288;早期的代理服务器&#65292;&#12304;不&#12305;需要&#8220;代理客户端&#8221;&#12290;因为早期的&#8220;代理服务器&#8221;支持的是&#12304;标准协议&#12305;&#12290;比如&#8220;HTTP proxy server&#8221;支持的是标准 HTTP协议&#65292;而用户的电脑上&#65292;已经有浏览器&#65288;原生支持 HTTP 协议&#65289;&#12290;这种情况下&#65292;自然不需要再有&#8220;代理客户端&#8221;&#12290;<br>
&#12288;&#12288;后来&#65292;为了满足某些特殊需求&#65288;比如翻墙&#65289;&#65292;&#8220;代理服务器&#8221;必须使用某种特殊的&#65288;非标准的&#65289;协议&#12290;因此&#65292;就必须在用户的环境中安装&#8220;代理客户端&#8221;&#12290;对于翻墙来说&#65292;你装的翻墙软件&#65292;相当于&#8220;代理客户端&#8221;&#12290;<br>
<br>
&#12288;&#12288;<b>代理的层次</b><br>
&#12288;&#12288;&#8220;代理&#8221;也分不同的层次&#12290;比较常见的有如下几种&#65306;<br>
<blockquote style="background-color:#DDD;">
TCP 代理&#65288;TCP 端口转发&#65289;&#8212;&#8212;4层&#65288;传输层&#65289;<br>
SOCKS 代理&#8212;&#8212;5层&#65288;会话层&#65289;<br>
HTTP 代理&#8212;&#8212;7层&#65288;应用层&#65289;<br>
......</blockquote>
<br>
<h3>&#9671;网关&#65288;<a href="https://en.wikipedia.org/wiki/Gateway_(telecommunications)" target="_blank" rel="nofollow">gateway</a>&#65289;</h3>
<br>
&#12288;&#12288;前面的某些章节&#65292;已经稍微提及了&#8220;网关&#8221;这个概念&#65292;但还没有具体介绍它&#12290;<br>
&#12288;&#12288;严格来讲&#65292;&#8220;网关&#8221;是一个逻辑概念&#65292;&#12304;不要&#12305;把它当成具体的网络设备&#12290;充当&#8220;网关&#8221;的东东&#65292;可能是&#65306;路由器 or XX层交换机 or XX层防火墙 or 代理服务器 ......<br>
&#12288;&#12288;&#8220;网关&#8221;也分不同的层次&#12290;如果不加定语&#65292;通常指的是&#8220;3层网关&#8221;&#65288;网络层网关&#65289;&#12290;列几种比较常见的&#65292;供参考&#65306;<br>
<blockquote style="background-color:#DDD;">
路由器充当网关&#8212;&#8212;3层&#65288;网络层&#65289;<br>
3层交换机充当网关&#8212;&#8212;3层&#65288;网络层&#65289;<br>
4层交换机充当网关&#8212;&#8212;4层&#65288;传输层&#65289;<br>
应用层防火墙充当网关&#8212;&#8212;7层&#65288;应用层&#65289;<br>
代理服务器充当网关&#8212;&#8212;&#65288;取决于代理的层次&#65292;参见前一个小节&#65289;<br>
......</blockquote>
<br>
<h3>&#9671;隧道协议&#65288;<a href="https://en.wikipedia.org/wiki/Tunnelling_protocol" target="_blank" rel="nofollow">tunneling protocol</a>&#65289;</h3>
<br>
&#12288;&#12288;所谓的&#8220;隧道协议&#8221;&#65292;通俗地说就是&#65306;用某种协议包裹另一种协议&#65292;以满足某些特殊的需求&#12290;<br>
&#12288;&#12288;看到这里&#65292;估计某些同学会感到纳闷&#8212;&#8212;因为俺在本文开头介绍&#8220;协议栈&#8221;的时候提到说&#65306;相邻的两层协议&#65292;下层会包裹上层&#12290;&#8220;隧道协议的包裹&#8221;与&#8220;上下层协议的包裹&#8221;&#65292;差别在哪捏&#65311;<br>
&#12288;&#12288;俺来解释一下&#65306;<br>
&#12288;&#12288;&#8220;隧道协议&#8221;可以做到更灵活的包裹&#8212;&#8212;既可以对层次相隔很远的协议进行包裹&#65292;也可以对同一层的协议进行包裹&#65292;甚至可以&#8220;倒挂&#8221;&#8212;&#8212;所谓的&#8220;倒挂&#8221;就是让&#12304;上&#12305;层反过来包裹&#12304;下&#12305;层&#12290;<br>
&#12288;&#12288;举例&#65306;<br>
&#12288;&#12288;俺曾经写过一篇&#12298;<a href="../../2019/04/Proxy-Tricks.html">如何让&#12304;不支持&#12305;代理的网络软件&#65292;通过代理进行联网&#65288;不同平台的 N 种方法&#65289;</a>&#12299;&#65292;其中介绍了&#8220;HTTP 代理&#8221;的两种模式&#65306;&#8220;转发模式 &#65286; 隧道模式&#8221;&#12290;对于&#8220;HTTP 代理&#8221;的隧道模式&#65292;可以实现&#12304;TCP over HTTP&#12305;&#65288;把 TCP 协议打包到 HTTP 协议内部&#65289;&#65292;这就是刚才所说的&#8220;倒挂&#8221;&#12290;<br>
&#12288;&#12288;另外&#65292;VPN 小节的那张图中&#65292;有些类型的 VPN 就是用&#8220;隧道协议&#8221;的机制实现&#12290;<br>
<br>
<h3>&#9671;&#65288;其它杂项&#65289;</h3>
<br>
&#12288;&#12288;可能还有一些杂七杂八的东东&#65292;没来得及聊&#12290;如果你觉得有些&#12304;网络相关&#12305;的概念&#65292;不太明白&#65292;欢迎到博客留言&#65292;进行反馈&#12290;<br>
&#12288;&#12288;俺会根据大伙儿的反馈&#65292;再对这篇教程进行补充&#12290;<br>
<br>
<br>
<h2>&#9733;参考书目</h2>
<br>
&#12288;&#12288;如下几本书&#65292;都在<a href="https://github.com/programthink/books" target="_blank">俺的网盘</a>上分享了电子版&#12290;<br>
<br>
<center><table border="1" cellspacing="0" cellpadding="5"><tbody>
<tr style="background:lightgrey;"><th>中文书名</th><th>英文书名</th><th>作者</th></tr>
<tr><td>&#12298;<a href="https://docs.google.com/document/d/1XQwaAMzuGuvmq5fCiTDMrh_pTUpCHJJ5C17btTv8kdE/" target="_blank">计算机网络</a>&#12299;</td><td>&#12298;Computer Networks&#12299;</td><td><a href="https://en.wikipedia.org/wiki/Andrew_S._Tanenbaum" target="_blank" rel="nofollow">Andrew Tanenbaum</a><br>David Wetherall</td></tr>
<tr><td>&#12298;<a href="https://docs.google.com/document/d/1tlbsKWyddVLeB3HSWUiq7KtkltLeClIbPtkyN6642O4/" target="_blank">计算机网络&#8212;&#8212;自顶向下方法</a>&#12299;</td><td>&#12298;Computer Networking&#8212;&#8212;A Top-Down Approach&#12299;</td><td><a href="https://en.wikipedia.org/wiki/Jim_Kurose" target="_blank" rel="nofollow">James Kurose</a><br><a href="https://en.wikipedia.org/wiki/Keith_W._Ross" target="_blank" rel="nofollow">Keith Ross</a></td></tr>
<tr><td>&#12298;<a href="https://docs.google.com/document/d/1Fw2wSr-MgNm1d_M6F-rF1t_n3LwFWWBHrJt6vcYGta4/" target="_blank">TCP-IP 详解</a>&#12299;</td><td>&#12298;TCP-IP Illustrated&#12299;</td><td><a href="https://zh.wikipedia.org/wiki/%E7%90%86%E6%9F%A5%E5%BE%B7%C2%B7%E5%8F%B2%E8%92%82%E6%96%87%E6%96%AF" target="_blank" rel="nofollow">Richard Stevens</a></td></tr>
<tr><td>&#12298;<a href="https://docs.google.com/document/d/1eB4BLE9PDXDfrb-ioXNfrHlOthMqUe0MXs8PmRsm3Os/" target="_blank">UNIX 网络编程</a>&#12299;</td><td>&#12298;UNIX Network Programming&#12299;</td><td><a href="https://zh.wikipedia.org/wiki/%E7%90%86%E6%9F%A5%E5%BE%B7%C2%B7%E5%8F%B2%E8%92%82%E6%96%87%E6%96%AF" target="_blank" rel="nofollow">Richard Stevens</a></td></tr>
<tr><td>&#12298;<a href="https://docs.google.com/document/d/1TgujhFUzyVlf1W5e48lSMTIwJuCTElvXw2LgQ_Ng0Cs/" target="_blank">HTTP 权威指南</a>&#12299;</td><td>&#12298;HTTP&#8212;&#8212;The Definitive Guide&#12299;</td><td>David Gourley<br>Brian Totty<br>Marjorie Sayer<br>Sailu Reddy<br>Anshu Aggarwal</td></tr>
</tbody></table></center>
<br>
<br>
<b>俺博客上&#65292;和本文相关的帖子&#65288;需翻墙&#65289;</b>&#65306;<br>
&#12298;<a href="../../2014/11/https-ssl-tls-0.html">扫盲 HTTPS 和 SSL&#65295;TLS 协议</a>&#12299;&#65288;系列&#65289;<br>
&#12298;<a href="../../2014/01/dns.html">扫盲 DNS 原理&#65292;兼谈&#8220;域名劫持&#8221;和&#8220;域名欺骗&#65295;域名污染&#8221;</a>&#12299;<br>
&#12298;<a href="../../2018/10/Comparison-of-DNS-Protocols.html">对比4种强化域名安全的协议&#8212;&#8212;DNSSEC&#65292;DNSCrypt&#65292;DNS over TLS&#65292;DNS over HTTPS</a>&#12299;<br>
&#12298;<a href="../../2010/04/howto-cover-your-tracks-0.html">如何隐藏你的踪迹&#65292;避免跨省追捕</a>&#12299;&#65288;系列&#65289;<br>
&#12298;<a href="../../2019/09/Netcat-Tricks.html">扫盲 netcat&#65288;网猫&#65289;的 N 种用法&#8212;&#8212;从&#8220;网络诊断&#8221;到&#8220;系统入侵&#8221;</a>&#12299;<br>
&#12298;<a href="../../2019/04/Proxy-Tricks.html">如何让&#12304;不支持&#12305;代理的网络软件&#65292;通过代理进行联网&#65288;不同平台的 N 种方法&#65289;</a>&#12299;<br>
&#12298;<a href="../../2017/09/Introduction-DHT-Kademlia-Chord.html">聊聊分布式散列表&#65288;DHT&#65289;的原理&#8212;&#8212;以 Kademlia&#65288;Kad&#65289; 和 Chord 为例</a>&#12299;<br>
&#12298;<a href="../../2012/10/system-vm-0.html">扫盲操作系统虚拟机</a>&#12299;&#65288;系列&#65289;<br>
&#12298;<a href="../../2019/11/POSIX-TUI-from-TTY-to-Shell-Programming.html">扫盲 Linux&#65286;UNIX 命令行&#8212;&#8212;从&#8220;电传打字机&#8221;聊到&#8220;shell 脚本编程&#8221;</a>&#12299;<br>
&#12298;<a href="../../2019/10/Systematic-Learning.html">如何&#12304;系统性学习&#12305;&#8212;&#8212;从&#8220;媒介形态&#8221;聊到&#8220;DIKW 模型&#8221;</a>&#12299;<br>
&#12298;<a href="../../2009/02/study-technology-in-three-steps.html">学习技术的三部曲&#65306;WHAT&#12289;HOW&#12289;WHY</a>&#12299;
<div class='post-copyright'>
<b>版权声明</b><br>本博客所有的原创文章&#65292;作者皆保留版权&#12290;转载必须包含本声明&#65292;保持本文完整&#65292;并以超链接形式注明作者<a href='mailto:program.think@gmail.com'>编程随想</a>和本文原始地址&#65306;<br>
<a href="../../2021/03/Computer-Networks-Overview.html" id="OriginalPostUrl">https://program-think.blogspot.com/2021/03/Computer-Networks-Overview.html</a>
</div>
<div style='clear: both;'></div>

          </div>

          <div>
            <hr style="margin-left: 30px;">
          </div>

          <div class="comments" id="comments" init_num="499">
            <a name="comments"></a>
            <h4 id="comments-label"></h4>
            <div id="comments-toolbar"></div>
            <div id="comments-warning">
              <noscript>
                由于你的浏览器【禁用了】JavaScript 脚本，所以无法发布新的评论 :(

                <br>另外，本文的评论数超过200，缺乏 JS 脚本支持，只能显示前面的200条 :(
              </noscript>
            </div>
            <div id="comments-loading"></div>
            <div id="comments-content">
              <div id="comment-holder">
              </div>
            </div>
            <p class="comment-footer">
            </p>
            <div class="comment-form">
              <a name="comment-form"></a>
              <p>
              </p>
              <a href="https://www.blogger.com/comment/frame/2781999363022286437?postID=2781999363022286437&amp;hl=zh-CN"
                id="comment-editor-src"></a>
            </div>
            <p></p>
            <div id="backlinks-container">
              <div id="Blog1_backlinks-container">
              </div>
            </div>
          </div>
        </div>

      </div>

      <script src="../../scripts/slogan.js"></script>
      <script src="../../scripts/pako.es5.min.js"></script>
      <script src="../../comments/2781999363022286437.js"></script>
      <script src="../../scripts/comments.js"></script>

      <div id="sidebar-wrapper">
        <div class="sidebar section" id="sidebar">

          <div class="widget HTML" id="BlogAbout">
            <div class="widget-content">
              <img src="../../images/thinker.jpg" alt="编程随想的Logo" title="编程随想的Logo"><br>
              <br>
              <img src="../../images/favicon/blogspot.ico" height="16" width="16" />
              <a href="https://program-think.blogspot.com/" target="_blank">博客主站点 (BlogSpot)</a><br>
              <img src="../../images/favicon/gmail.ico" height="16" width="16" />
              <a href="mailto:program.think@gmail.com" target="_blank">俺的邮箱 (Gmail)</a><br>
              <img src="../../images/favicon/github.ico" height="16" width="16" />
              <a href="https://github.com/programthink" target="_blank">俺的收藏 (GitHub)</a><br>
              <img src="../../images/favicon/twitter.ico" height="16" width="16" />
              <a href="https://twitter.com/programthink" target="_blank">俺的推特 (@programthink)</a><br>
            </div>
          </div>

          <div class="widget HTML" id="BlogFeed">
            <h2 class="title">订阅博客</h2>
            <div class="widget-content">
              <a href="https://feeds2.feedburner.com/programthink" target="_blank" title="RSS 订阅">
                <img src="../../images/feed-icon-animated.gif" alt="RSS 订阅" border="0"></a>　　　
              <a href="2013/06/email-subscription.html" title="邮件订阅">
                <img src="../../images/email-icon.png" alt="邮件订阅" border="0"></a><br>
            </div>
          </div>

          <div class="widget Text" id="BlogDesc">
            <h2 class="title">博客主要内容</h2>
            <div class="widget-content">
              ★提升思维能力<br>
              ★普及政治常识<br>
              ★扫盲翻墙姿势<br>
              ★揭露党国嘴脸<br>
              ★网络安全教程<br>
              ★软件开发技术
            </div>
          </div>

          <div class="widget Label" id="BlogTags">
            <h2>分类标签</h2>
            <div class="widget-content list-label-widget-content">
              <ul>
                <li><a href="../../tags/IT.html" class="tag">IT</a> (208)</li>
                <li><a href="../../tags/IT.Linux.html" class="tag">IT.Linux</a> (6)</li>
                <li><a href="../../tags/IT.E4B89AE7958CE8AF84E8AEBA.html" class="tag">IT.业界评论</a> (16)</li>
                <li><a href="../../tags/IT.E4BABAE5B7A5E699BAE883BD.html" class="tag">IT.人工智能</a> (3)</li>
                <li><a href="../../tags/IT.E4BFA1E681AFE5AE89E585A8.html" class="tag">IT.信息安全</a> (100)</li>
                <li><a href="../../tags/IT.E7BD91E7BB9C.html" class="tag">IT.网络</a> (22)</li>
                <li><a href="../../tags/IT.E7BFBBE5A299.html" class="tag">IT.翻墙</a> (50)</li>
                <li><a href="../../tags/IT.E8BDAFE4BBB6E4BB8BE7BB8D.html" class="tag">IT.软件介绍</a> (50)</li>
                <li><a href="../../tags/E4B9A6E8AF842FE5BDB1E8AF84.html" class="tag">书评/影评</a> (56)</li>
                <li><a href="../../tags/E5869BE4BA8B.html" class="tag">军事</a> (17)</li>
                <li><a href="../../tags/E58D9AE5AEA2E9809AE5918A.html" class="tag">博客通告</a> (34)</li>
                <li><a href="../../tags/E58E86E58FB2.html" class="tag">历史</a> (85)</li>
                <li><a href="../../tags/E5A496E4BAA4.html" class="tag">外交</a> (26)</li>
                <li><a href="../../tags/E5ADA6E4B9A0E696B9E6B395.html" class="tag">学习方法</a> (14)</li>
                <li><a href="../../tags/E5ADA6E4BC9AE6809DE88083.html" class="tag">学会思考</a> (24)</li>
                <li><a href="../../tags/E5BF83E79086E5ADA6.html" class="tag">心理学</a> (31)</li>
                <li><a href="../../tags/E694BFE6B2BB.html" class="tag">政治</a> (281)</li>
                <li><a href="../../tags/E694BFE6B2BB.E585ABE58DA6.html" class="tag">政治.八卦</a> (19)</li>
                <li><a href="../../tags/E694BFE6B2BB.E585B1E4BAA7E8BF90E58AA8.html" class="tag">政治.共产运动</a> (12)</li>
                <li><a href="../../tags/E694BFE6B2BB.E5B8B8E8AF86.html" class="tag">政治.常识</a> (22)</li>
                <li><a href="../../tags/E694BFE6B2BB.E69D83E8B4B5.html" class="tag">政治.权贵</a> (27)</li>
                <li><a href="../../tags/E694BFE6B2BB.E6B395E588B6.html" class="tag">政治.法制</a> (22)</li>
                <li><a href="../../tags/E694BFE6B2BB.E79C9FE79086E983A8.html" class="tag">政治.真理部</a> (37)</li>
                <li><a href="../../tags/E694BFE6B2BB.E88590E8B4A5.html" class="tag">政治.腐败</a> (26)</li>
                <li><a href="../../tags/E69599E882B2.html" class="tag">教育</a> (9)</li>
                <li><a href="../../tags/E697B6E4BA8BE8AF84E8AEBA.html" class="tag">时事评论</a> (176)</li>
                <li><a href="../../tags/E78EAFE4BF9D.html" class="tag">环保</a> (13)</li>
                <li><a href="../../tags/E7A791E699AE.html" class="tag">科普</a> (8)</li>
                <li><a href="../../tags/E7AEA1E79086.html" class="tag">管理</a> (16)</li>
                <li><a href="../../tags/E7BB8FE6B58E.html" class="tag">经济</a> (44)</li>
                <li><a href="../../tags/E7BC96E7A88B.html" class="tag">编程</a> (69)</li>
                <li><a href="../../tags/E7BC96E7A88B.C.html" class="tag">编程.C</a> (15)</li>
                <li><a href="../../tags/E7BC96E7A88B.Java.html" class="tag">编程.Java</a> (12)</li>
                <li><a href="../../tags/E7BC96E7A88B.Python.html" class="tag">编程.Python</a> (8)</li>
                <li><a href="../../tags/E7BC96E7A88B.E5A49AE7BABFE7A88B.html" class="tag">编程.多线程</a> (6)</li>
                <li><a href="../../tags/E7BC96E7A88B.E5BC80E6BA90E9A1B9E79BAE.html" class="tag">编程.开源项目</a> (10)</li>
                <li><a href="../../tags/E7BC96E7A88B.E680A7E883BDE4BC98E58C96.html" class="tag">编程.性能优化</a> (6)</li>
                <li><a href="../../tags/E7BC96E7A88B.E69EB6E69E84.html" class="tag">编程.架构</a> (7)</li>
                <li><a href="../../tags/E7BC96E7A88B.E7AE97E6B395.html" class="tag">编程.算法</a> (3)</li>
                <li><a href="../../tags/E7BC96E7A88B.E8BDAFE4BBB6E5B7A5E7A88B.html" class="tag">编程.软件工程</a> (13)</li>
                <li><a href="../../tags/E8818CE59CBAE782B9E6BBB4.html" class="tag">职场点滴</a> (22)</li>
                <li><a href="../../tags/E8BDACE8BDBD.html" class="tag">转载</a> (153)</li>
              </ul>
            </div>
          </div>

          <div class="widget Label" id="BlogRecommend">
            <div class="widget-content">
              <h2>推荐帖子（翻墙技术）</h2>
              <ul>
                <li><a href='../../2009/05/how-to-break-through-gfw.html'>如何翻墙（全方位入门扫盲）</a></li>
                <li><a href='../../2011/09/gfw-faq.html'>常见翻墙问题答疑</a></li>
                <li><a href='../../2011/03/how-to-get-gfw-tools.html'>获取翻墙软件方法大全</a></li>
                <li><a href='../../2013/01/cross-host-use-gfw-tool.html'>多台电脑如何共享翻墙通道</a></li>
                <li><a href='../../2013/11/tor-faq.html'>关于 Tor 的常见问题解答</a></li>
                <li><a href='../../2009/07/break-through-berlin-wall.html'>学习一下德国人民的翻墙精神</a></li>
              </ul>
              <h2>推荐帖子（信息安全）</h2>
              <ul>
                <li><a href='../../2021/03/Computer-Networks-Overview.html'>计算机网络通讯的【系统性】扫盲——从“基本概念”到“OSI 模型”</a></li>
                <li><a href='../../2019/01/Security-Guide-for-Political-Activists.html'>为啥朝廷总抓不到俺——十年反党活动的安全经验汇总</a>
                </li>
                <li><a href='../../2015/08/Technology-and-Freedom.html'>“对抗专制、捍卫自由”的 N 种技术力量</a></li>
                <li><a href='../../2010/06/howto-prevent-hacker-attack-0.html'>如何防止黑客入侵（系列）</a></li>
                <li><a href='../../2013/06/privacy-protection-0.html'>如何保护隐私（系列）</a></li>
                <li><a href='../../2010/04/howto-cover-your-tracks-0.html'>如何隐藏你的踪迹，避免跨省追捕（系列）</a></li>
                <li><a href='../../2012/10/system-vm-0.html'>扫盲操作系统虚拟机 (系列)</a></li>
                <li><a href='../../2015/10/VeraCrypt.html'>扫盲 VeraCrypt——跨平台的 TrueCrypt 替代品</a></li>
                <li><a href='../../2011/05/recommend-truecrypt.html#index'>TrueCrypt 的扫盲教程和高级教程（VeraCrypt 也适用）</a></li>
                <li><a href='../../2011/05/file-encryption-overview.html'>文件加密的扫盲介绍</a></li>
                <li><a href='../../2013/07/online-backup-virtual-encrypted-disk.html'>文件备份技巧：组合“虚拟加密盘”与“网盘”</a></li>
                <li><a href='../../2013/02/file-integrity-check.html'>扫盲文件完整性校验——关于散列值和数字签名</a></li>
                <li><a href='../../2009/05/social-engineering-0-overview.html'>扫盲“社会工程学”（系列）</a></li>
              </ul>
              <h2>推荐帖子（提升个人能力）</h2>
              <ul>
                <li><a href='../../2020/12/Study-and-Life.html'>学习与人生——700篇博文之感悟</a></li>
                <li><a href='../../2019/10/Systematic-Learning.html'>如何【系统性学习】——从“媒介形态”聊到“DIKW 模型”</a></li>
                <li><a href='../../2013/09/knowledge-structure.html'>如何完善自己的知识结构</a></li>
                <li><a href='../../2013/04/how-to-read-book.html'>《如何阅读一本书》——书评及内容纲要</a></li>
                <li><a href='../../2015/12/Hobbies-and-Interests.html'>什么是【真正的】兴趣爱好？以及它有啥好处？</a></li>
                <li><a href='../../2009/02/study-technology-in-three-steps.html'>学习技术的三部曲：WHAT、HOW、WHY</a></li>
                <li><a href='../../2012/03/think-what-how-why.html'>用提问促进思维——再谈 WHAT HOW WHY 三部曲</a></li>
                <li><a href='../../2015/06/The-Mythical-Theories-of-Success.html'>成功学批判——简述其危害性及各种谬误</a></li>
                <li><a
                    href='../../2018/12/Book-Review-Antifragile-Things-That-Gain-from-Disorder.html'>读书笔记：《反脆弱——从不确定性中获益》</a>
                </li>
                <li><a href='../../2009/07/book-review-are-your-lights-on.html'>书评：《你的灯亮着吗？——找到问题的真正所在》</a></li>
              </ul>
              <h2>推荐帖子（洗脑与反洗脑）</h2>
              <ul>
                <li><a href='../../2014/02/brainwash-and-idiot.html'>聊聊洗脑和脑残——分析“脑残的起源”和“脑残的觉醒”</a></li>
                <li><a href='../../2013/05/difference-between-fact-and-opinion.html'>批判性思维扫盲——学会区分“事实”与“观点”</a></li>
                <li><a href='../../2011/03/logical-fallacies.html'>扫盲逻辑谬误——以五毛言论为反面教材</a></li>
                <li><a href='../../2014/12/brainwash-using-real-data.html'>比“欺骗”更狡猾的洗脑——基于【真实数据】进行忽悠</a></li>
                <li><a href='../../2014/01/doublethink.html'>比“欺骗”更有效的洗脑——基于【双重思想】的思维控制</a></li>
                <li><a href='../../2014/01/anti-brainwashing-and-enlightenment.html'>如何用互联网进行“反洗脑”和“政治启蒙”</a></li>
                <li><a href='../../2010/10/book-review-asking-right-questions.html'>书评：《学会提问——批判性思维指南》</a></li>
              </ul>
              <h2>推荐帖子（心理学）</h2>
              <ul>
                <li><a href='../../2019/03/Why-Thinking-Hard-So-Hard.html'>为什么独立思考这么难——谈谈心理学的成因，并分享俺的经验</a></li>
                <li><a href='../../2014/05/fans-and-idolatry.html'>不要成为“粉丝”——谈谈“偶像崇拜”的成因和危害</a></li>
                <li><a href='../../2012/12/emperor-complex.html'>天朝民众的心理分析：圣君情结</a></li>
                <li><a href='../../2012/06/stockholm-syndrome.html'>天朝民众的心理分析：斯德哥尔摩综合症</a></li>
                <li><a href='../../2014/09/oversimplification.html'>各种【一元化思维】的谬误——从“星座理论”到“共产主义社会”</a></li>
                <li><a href='../../2015/05/Survivorship-Bias.html'>思维的误区：幸存者偏见——顺便推荐巴菲特最著名的演讲</a></li>
                <li><a href='../../2014/06/sunk-cost-fallacy-and-loss-aversion.html'>思维的误区：从“沉没成本谬误”到“损失厌恶情结”</a></li>
                <li><a href='../../2010/02/about-mental-model.html'>认识你自己——有关心智模式的扫盲介绍</a></li>
                <li><a href='../../2010/04/how-to-attribute-success-failure.html'>你是如何看待【成败】的？——兼谈【有效归因】</a></li>
                <li><a href='../../2012/01/stockdale-paradox.html'>如何面对【逆境】？——兼谈“斯托克戴尔悖论”</a></li>
                <li><a href='../../2012/06/book-review-road-less-traveled.html'>书评：《少有人走的路——心智成熟的旅程》</a></li>
                <li><a href='../../2009/05/halo-effect.html'>光环效应引发的认知误区</a></li>
              </ul>
              <h2>推荐帖子（政治）</h2>
              <ul>
                <li><a
                    href='../../2018/09/Book-Review-The-Errors-of-Marxism-Leninism.html'>为什么马克思是错的——全面批判马列主义的知名著作导读</a>
                </li>
                <li><a href='../../2020/04/Government-and-System-Robustness.html'>“政治体制”与“系统健壮性”——基于“复杂性科学”的思考</a></li>
                <li><a href='../../2011/06/june-fourth-incident-0.html'>回顾“六四”（系列）</a></li>
                <li><a href='../../2011/12/revolution-0.html'>谈革命（系列）</a></li>
                <li><a href='../../2018/07/Forty-Years-of-China-USA-Relations.html'>从量变到质变——中美关系40年</a></li>
                <li><a href='../../2018/08/USA-Containment-Strategies-in-Cold-War.html'>苏联是如何被慢慢勒死的？——聊聊冷战中美国的遏制战略</a>
                </li>
                <li><a href='../../2015/01/Communism-Nazism-Caesaropapism.html'>人类自由的三大死敌——谈谈“共产运动、纳粹主义、政教合一”的共性</a>
                </li>
                <li><a
                    href='../../2013/12/political-concepts-state-citizenship-etc.html'>政治常识扫盲：理清“国家、政体、公民、政府、政党”等概念</a>
                </li>
                <li><a href='../../2014/02/freedom-of-speech.html'>政治常识扫盲：澄清“言论自由”的各种误区</a></li>
                <li><a href='../../2012/07/form-of-government.html'>扫盲常见的政治体制</a></li>
                <li><a href='../../2016/06/USA-Separation-of-Powers-with-Balances.html'>聊聊美国政体中的权力制衡——不仅仅是三权分立</a></li>
                <li><a href='../../2016/11/USA-Elections.html'>美国选举制度为啥这样设计？——兼谈其历史演变</a></li>
                <li><a href='../../2010/11/institutionalize.html'>谈谈体制化，并推荐《肖申克的救赎》</a></li>
                <li><a href='../../2013/04/more-supervision-less-thankfulness.html'>对政府——多些“监督问责”，少些“煽情感动”</a></li>
                <li><a href='../../2012/03/national-people-congress.html'>看看全国人大代表都是啥货色——兼谈“议会道路的改良”行不通</a></li>
                <li><a href='../../2012/10/history-of-red-khmers.html'>最“纯正”的共产主义政权——红色高棉简史</a></li>
              </ul>
              <h2>推荐帖子（历史）</h2>
              <ul>
                <li><a href='../../2019/11/Brief-History-of-the-Berlin-Wall.html'>美苏冷战的缩影——柏林墙简史</a></li>
                <li><a href='../../2014/07/artists-and-ccp.html'>面对共产党——民国人文大师的众生相</a></li>
                <li><a href='../../2012/05/three-years-famine-0.html'>谈谈三年大饥荒（系列）</a></li>
                <li><a href='../../2016/01/Taiwan-Political-Movements.html'>台湾民主运动与独立运动简史</a></li>
                <li><a href='../../2010/09/censorship-of-images.html'>看看真理部是如何 PS 照片的</a></li>
                <li><a href='../../2013/08/korean-war.html'>谈谈真理部对朝鲜战争的忽悠</a></li>
                <li><a href='../../2010/09/sino-japanese-war.html'>谈谈真理部对抗战历史的篡改</a></li>
                <li><a href='../../2014/04/history-china-fallen-behind-europe.html'>中国是从哪个朝代开始落后于西方？</a></li>
                <li><a href='../../2011/03/ccp-vs-japanese.html'>谁是最可恨的人？——写给仇日愤青们</a></li>
                <li><a href='../../2015/11/Why-Islam-Is-Different-from-Other-Religions.html'>伊斯兰教为何如此奇葩？</a></li>
                <li><a href='../../2015/01/Islamic-Extremism.html'>伊斯兰教极端主义溯源</a></li>
              </ul>
              <h2>推荐帖子（编程技术）</h2>
              <ul>
                <li><a href='../../2012/05/weekly-share-5.html'>学习编程语言的3篇好文章</a></li>
                <li><a href='../../2009/08/why-choose-python-0-overview.html'>为什么俺推荐 Python（系列）</a></li>
                <li><a href='../../2009/03/producer-consumer-pattern-0-overview.html'>架构设计：生产者/消费者模式</a></li>
                <li><a href='../../2009/02/multi-process-vs-multi-thread.html'>架构设计：进程还是线程？</a></li>
                <li><a href='../../2009/02/how-to-choose-opensource-project.html'>如何选择开源项目？</a></li>
                <li><a href='../../2009/02/cxx-object-destroy-overview.html'>C++ 对象是怎么死的？（系列）</a></li>
                <li><a href='../../2009/01/cxx-cross-platform-develop-0-overview.html'>C++ 的移植性和跨平台开发（系列）</a></li>
                <li><a href='../../2009/03/java-performance-tuning-0-overview.html'>Java 性能优化（系列）</a></li>
                <li><a href='../../2009/01/defect-of-java-beginner-0-overview.html'>Java 新手的通病（系列）</a></li>
              </ul>
              <h2>推荐帖子（职场与管理）</h2>
              <ul>
                <li><a href='../../2019/12/Time-and-Life.html'>时间与人生——跨入本世纪20年代的随想</a></li>
                <li><a href='../../2018/06/weekly-share-121.html'>德鲁克谈【自我管理】——《哈佛商业评论》最受欢迎的文章</a></li>
                <li><a href='../../2011/03/hiring-experience-0.html'>俺的招聘经验（系列）</a></li>
                <li><a href='../../2009/04/defect-of-hire.html'>招聘的误区</a></li>
                <li><a href='../../2016/04/Andy-Grove-Quotes-on-Leadership.html'>硅谷 CEO 们的教父——分享安迪·格鲁夫的管理经验</a></li>
                <li><a href='../../2009/01/0.html'>如何成为优秀开发人员（系列）</a></li>
              </ul>

            </div>
          </div>

          <div class="widget HTML" id="BlogSearch">
            <h2 class="title">博客站内搜索 (需联网)</h2>
            <div class="widget-content">
              <img src="../../images/search/google.png" alt="Google" border="0"><br>
              <form method="GET" action="https://encrypted.google.com/search" target="_blank">
                <input name="ie" value="UTF-8" type="hidden">
                <input name="oe" value="UTF-8" type="hidden">
                <input name="sitesearch" value="program-think.blogspot.com" type="hidden">
                <input name="q" size="32" maxlength="128" type="text">
                <input name="search" value="Google" type="submit">
              </form>
              <br>
              <img src="../../images/search/bing.png" alt="Bing" border="0"><br>
              <form method="GET" action="http://www.bing.com/search" target="_blank">
                <input name="q1" value="site:program-think.blogspot.com" type="hidden">
                <input name="q" size="32" maxlength="128" type="text">
                <input name="search" value="Bing" type="submit">
              </form>
            </div>
          </div>

          <div class="widget BlogArchive" id="BlogArchive">
            <h2>历史归档</h2>
            <div class="widget-content">
              <ul>
                <li><a href="../../archive/2021.html">2021</a> (10)</li>
                <li><a href="../../archive/2020.html">2020</a> (28)</li>
                <li><a href="../../archive/2019.html">2019</a> (39)</li>
                <li><a href="../../archive/2018.html">2018</a> (31)</li>
                <li><a href="../../archive/2017.html">2017</a> (34)</li>
                <li><a href="../../archive/2016.html">2016</a> (37)</li>
                <li><a href="../../archive/2015.html">2015</a> (61)</li>
                <li><a href="../../archive/2014.html">2014</a> (76)</li>
                <li><a href="../../archive/2013.html">2013</a> (96)</li>
                <li><a href="../../archive/2012.html">2012</a> (109)</li>
                <li><a href="../../archive/2011.html">2011</a> (58)</li>
                <li><a href="../../archive/2010.html">2010</a> (40)</li>
                <li><a href="../../archive/2009.html">2009</a> (93)</li>
              </ul>
            </div>
          </div>

        </div> <!--sidebar-->
      </div> <!--sidebar-wrapper-->

    </div> <!-- end content-wrapper -->
  </div> <!-- end outer-wrapper -->
</body>
<script>
jQuery(function($)
{
  function initArticleInnerLinks()
  {
    if($(".post h2").length == 0)
    {
      $(".post-inner-index").hide();
      return;
    }

    $(".post-inner-index").css("padding-bottom", "2em")
        .append("<div><b style='font-size:120%;'>文章目录</b></div>");

    $(".post h2").each(
      function(nIndex)
      {
        var sHash = "head-"+(nIndex+1);
        $(this).before("<a name='"+sHash+"'> </a>");
        var sTitle = $(this).html().replace(/<.+?>|/g, "");
        $(".post-inner-index").append("<a href='#"+sHash+"'>"+sTitle+"</a><br/>");
      }
    );
  }

  $(document).ready(
    function()
    {
      try
      {
        initArticleInnerLinks();
        $(document).tooltip({
          content: Tooltip.content,
          open: function(event, ui) { Tooltip.open(event, ui, 3000); }
        });
      }
      catch(err)
      {
        reportError("init: Catch exception:\n" + err);
      }
    }
  );
});
</script>
</html>